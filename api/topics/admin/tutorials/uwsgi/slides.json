{"layout":"tutorial_slides","logo":"assets/images/gat.png","title":"uWSGI","contributors":["natefoo","slugger70"],"subtopic":"deprecated","js_requirements":{"mathjax":null,"mermaid":false},"short_id":"S00028","url":"/topics/admin/tutorials/uwsgi/slides.html","topic_name":"admin","tutorial_name":"uwsgi","dir":"topics/admin/tutorials/uwsgi","symlink":null,"id":"admin/uwsgi","ref_tutorials":[],"ref_slides":["# What is uWSGI?\n\n- Python WSGI (Web Server Gateway Interface) application framework\n- Written in C\n- Forking application server\n- Optional HTTP server\n- Process manager\n\n...and the rest of the kitchen sink\n\n???\n\n- What is uWSGI?\n- It's a framework for writting web applications.\n- uWSGI itself is written in C, but can run programs in different languages with a compatible interface.\n- It handles a lot of the scaling issues for us.\n\n---\n\n# Why do we need uWSGI?\n\n- Galaxy is a Python web application without a web server\n- Implements standard Python WSGI\n- Some other application does the web serving\n- Technically we could use any HTTP/WSGI interface\n  - Traditionally [Python Paste](https://github.com/cdent/paste/)\n\n???\n\n- We need uWSGI because Galaxy doesn't include a web server.\n- So Galaxy implements the standard Python WSGI interface.\n- And another application can handle the web serving.\n\n---\n\n# What is uWSGI used for?\n\n.left[In a production Galaxy server:]\n- To start, manage, and scale web workers\n- Optionally, to start, manage, and scale job handlers\n\n???\n\n- Galaxy uses uWSGI to start, manage, and scale web workers.\n- Additionally it can be used for web-less job handlers if you use that setup.\n\n---\n\n# Why uWSGI?\n\nBecause Python can't multithread.\n\n![Python GIL](../../images/gil.png)\n\n.footnote[Image credit: [Dariusz Fryta](http://www.tivix.com/blog/lets-go-python/)]\n\n???\n\n- Python cannot do multithreading due to the GIL or Global Interpreter Lock.\n- However, python is multiprocess capable.\n- uWSGI will provide our scalability.\n\n---\n\n# Why uWSGI?\n\n- Fork many Galaxy server processes\n- Isolate job functions from web functions\n- Built in load balancing\n- Speak native high performance uWSGI protocol to nginx\n- Uninterrupted restarting\n- Can do anything you can imagine: [uWSGI configuration options](http://uwsgi-docs.readthedocs.io/en/latest/Options.html)\n\n???\n\n- uWSGI can fork as many Galaxy processes as we need.\n- Then it provides some built in load balancing with mules or zerg-mode.\n- It has a high-performance protocol that nginx and apache both speak, for more efficiency.\n- uWSGI enables uninterrupted restarts, which users love.\n\n---\n\n## uWSGI\n\n- **Configuration**\n- uWSGI wheel\n- Job handler mules\n\n???\n\n- There are three main sections we'll cover: Configuration, wheels, and mules.\n- First, configuration.\n\n---\n\n## uWSGI Configuration File\n\nuWSGI configuration is performed in the `uwsgi` key of `galaxy.yml`.\n\n`galaxy.yml.sample` is never consulted.\n\n.left[If using `run.sh`:]\n- If no config exists, all necessary defaults are generated as command line arguments to uWSGI\n- If a config exists, it is parsed, and any missing required options are passed as command line arguments to uWSGI\n\n**Galaxy servers deployed with Ansible do not use `run.sh` and should fully specify their uWSGI configuration.**\n\n???\n\n- uWSGI configuration is done in the uWSGI block of the galaxy yaml file.\n- The run shell script is not used in production, but has convenient behaviour for those users.\n\n---\n\n## uWSGI default command line\n\nWithout a config file, the uWSGI command line is:\n\n```sh-session\n$ /home/nate/galaxy/.venv/bin/python3 .venv/bin/uwsgi \\\n    --module 'galaxy.webapps.galaxy.buildapp:uwsgi_app()' \\\n    --virtualenv /home/nate/galaxy/.venv --pythonpath lib \\\n    --threads 4 --http localhost:8080 \\\n    --static-map /static=/home/nate/galaxy/static --die-on-term \\\n    --hook-master-start 'unix_signal:2 gracefully_kill_them_all' \\\n    --hook-master-start 'unix_signal:15 gracefully_kill_them_all' \\\n    --enable-threads --py-call-osafterfork\n```\n\n???\n\n- The default uWSGI command line is quite complex with numerous arguments.\n- It must specify a module to load and a function to run.\n- A python path and virtualenv are loaded as well.\n- A number of threads is specified and an HTTP port on which to listen.\n- Static files required special mapping and some signal handling to ensure cleanup.\n\n---\n\n## uWSGI command line\n\n.left[Behind the scenes, `run.sh` calls `scripts/get_uwsgi_args.py`, which:]\n- locates your config file (if any),\n- parses it to determine whether you have set any of the default (or conflicting) options,\n- determines the flags needed to run Galaxy.\n\nYou can take \"full control\" over this process by skipping `run.sh` and simply calling `uwsgi` directly, e.g. `uwsgi --yaml config/galaxy.yml`.\n\n???\n\n- If you're using run.sh, it calls a python script to determine the command line.\n- With Ansible this configuration is written in the galaxy yaml file.\n\n---\n\n# uWSGI communication\n\n- uWSGI can serve HTTP directly using the `--http` option\n- uWSGI speaks a native protocol (which nginx also speaks) using `--socket`\n\nA proxy server is not *required,* but its use is strongly encouraged for performance reasons.\n\n???\n\n- uWSGI can speak either HTTP or it's own native protocol.\n- While a proxy server is not required, it is strongly encouraged.\n- It can use this more efficient uWSGI protocol and provide additional performance.\n- A proxy server can proxy static files, freeing uWSGI to focus on computation.\n\n---\n\n## YAML config\n\nuWSGI natively supports YAML configs (and INI, and PasteDeploy INI, and XML, and JSON, and ...)\n\n**WARNING:** \"uWSGI YAML\" is not real YAML!\n\n.pull-left[\nReal YAML\n```yaml\nuwsgi:\n    # quoting forces string\n    socket: '127.0.0.1:8001'\n    # proper YAML list\n    mule:\n      - lib/galaxy/main.py\n      - lib/galaxy/main.py\n```\n]\n\n.pull-right[\nuWSGI \"YAML\"\n```yaml\nuwsgi:\n    # quote chars read literally\n    socket: '127.0.0.1:8001'\n    # a uWSGI YAML \"list\":\n    #  repeat keys\n    mule: lib/galaxy/main.py\n    mule: lib/galaxy/main.py\n```\n]\n\n???\n\n- uWSGI natively supports YAML configuration as well as a number of other formats.\n- However, uWSGI's YAML is not the same as real YAML.\n- It uses repeated keys for lists.\n\n---\n\n## YAML config\n\n- \"uWSGI YAML\" only applies to the `uwsgi` section of `galaxy.yml`\n  - The `galaxy` section must use real YAML\n- uWSGI can be compiled against libyaml for real YAML support\n- Galaxy Ansible role can write *both* uWSGI (default), real YAML\n\n???\n\n- As a result of this uWSGI flavour of YAML, both are mixed in the Galaxy configuration file.\n- The Galaxy section must use proper YAML.\n- But not to worry! Ansible takes care of this dual-language configuration.\n- And you never have to worry about it.\n\n---\n\n## Configuration Schema\n\n.center[`[config_schema.yml][config-schema]` contains possible options **and their types**.]\n\n.left[config_schema.yml is the canonical source for config option documentation, from which:]\n- .left[`[galaxy.yml.sample][config-sample]` is generated]\n- [Galaxy configuration options documentation][config-docs] is generated\n\n[config-schema]: https://github.com/galaxyproject/galaxy/blob/release_20.09/lib/galaxy/webapps/galaxy/config_schema.yml\n[config-sample]: https://github.com/galaxyproject/galaxy/blob/release_20.09/lib/galaxy/config/sample/galaxy.yml.sample\n[config-docs]: https://docs.galaxyproject.org/en/master/admin/config.html\n\n???\n\n- Galaxy has a listing of every configuration option in the config_schema file.\n- This is used to generate the sample file and the documentation.\n\n---\n\n## uWSGI\n\n- Configuration\n- **uWSGI wheel**\n- Job handler mules\n\n???\n\n- The next main aspect of uWSGI is distribution, or wheels.\n\n---\n\n## uWSGI Wheel\n\nGalaxy's uWSGI is not built like standard `pip install uwsgi`\n\nA bit of technical minutiae that might help debugging\n\n???\n\n- Galaxy's uWSGI is not a standard package.\n- This is minutiae but it might help whenever you need to debug uWSGI issues.\n\n---\n\n## uWSGI Wheel\n\n- The challenge:\n  - Unlike Galaxy's other framework dependencies, uWSGI is not a Python library\n  - uWSGI embeds the CPython interpreter\n  - Essentially uWSGI *is* Galaxy's CPython\n\n???\n\n- At the beginning we discussed it was a C program, uWSGI is not a python library.\n- So uWSGI embeds the CPython interpreter.\n\n--\n\n- The goal: Provide a no-compilation-required, no-dependencies installation method for Galaxy that includes uWSGI that:\n  - Doesn't embed statically linked CPython\n  - Doesn't require system `libpythonX.Y.so`\n  - Uses system CPython\n\n???\n\n- There are good reasons for this odd setup.\n- Our goal was to provide a compilation and dependency free method for installation.\n- Additionally it should not require system python libraries.\n\n\n---\n\n## uWSGI Wheel\n\nThe uWSGI wheel is built differently than when built from source with\n\n`pip install uwsgi`\n\n- From source by pip:\n  - Built as a single `uwsgi` ELF binary embedding the CPython interpreter\n- As the pyuwsgi wheel:\n  - Built as a Python C extension into an ELF shared library `pyuwsgi.so`\n  - Loaded by a stub `uwsgi` Python script by the CPython interpreter\n\npyuwsgi wheel: the only way to precompile uWSGI in a way that does not require `libpythonX.Y.so` or ship CPython\n\n???\n\n- The uWSGI wheel is just built differently.\n- When it's built from source by pip, it comes as a single binary with CPython.\n- When it's usgin the wheel, it's built as a Python C extension.\n- This is loaded by a stub uWSGI script.\n- This complex method was the only one to achieve our goals.\n\n---\n\n## uWSGI\n\n- Configuration\n- uWSGI wheel\n- **Job handler mules**\n\n???\n\n- Lastly, we'll talk about job handling and mules.\n\n---\nclass: top\n\n## Processes and Job Handling\n\nuWSGI starts up in a single \"master\" process and then `fork()`s a configured number of anonymous *web worker* processes to **serve web requests**.\n\nBy default, web workers also handle Galaxy job (tool execution) preparation and completion.\n\n???\n\n- So how are processes and jobs handled with uWSGI?\n- uWSGI starts up in a single \"master\" process and forks some copies.\n- By default these also handle jobs.\n\n--\n\nProcessing Galaxy job (tool execution) preparation and finishing is somewhat resource intensive and affects web responsiveness.\n\nProduction Galaxy servers traditionally start additional dedicated Galaxy \"webless\" (do not serve web requests) *job handler* processes.\n\n???\n\n- Processing galaxy jobs is quite resource intensive and can affect web responsiveness.\n- As a result, typically web handling and job handling are in separate processes.\n\n--\n\nuWSGI provides a useful feature for running Galaxy job handlers: [uWSGI Mules](https://uwsgi-docs.readthedocs.io/en/latest/Mules.html).\n\n???\n\n- uWSGI has a feature called mules which we use for handlers.\n\n---\n\n## uWSGI Mules\n\n**Mules** are processes `fork()`ed from the uWSGI master after the application has been loaded and web workers have `fork()`ed.\n\nMules can continue to run the same code or can load and run arbitrary code.\n\nMules can receive messages from the web proceses.\n\nMules can be pooled in to *Farms*, and messages can be sent to the farm to be handled by any mule in that farm.\n\n???\n\n- Mules are processes forked after the application has loaded.\n- Mules can continue to run the same code or load more.\n- Mules can communicate with the master.\n- Optionally they can live in pools called farms, e.g. one for job handlers.\n\n---\n\n## Mule Advantages\n\n.pull-left.reduce90[\nWebless handlers\n- Config is complex\n- Must manage handler processes externally (e.g. w/ systemd)\n- Handler assignment:\n  - At random from configured handlers\n  - No regard as to handler health\n  - Notification via database\n- Can be spread across multiple hosts\n]\n\n.pull-right.reduce90[\nuWSGI Mule handlers\n- Config is trivial\n- Handler processes managed automatically by uWSGI master\n- Handler assignment:\n  - \"Grabbed\" by healthy mule\n  - IPC (messaging) from web worker\n- Mules run on same host as web workers\n]\n\n???\n\n- Webless handlers can be quite complex to setup and manage.\n- Mules offer a very simple alternative.\n- However, this requires they run on the same host, which is usually ok.\n\n---\n\n## Job Handler Mule Configuration\n\nAdding job handler mules is performed by simply instructing uWSGI to start them in `galaxy.yml`:\n\n```yaml\nuwsgi:\n    mule: lib/galaxy/main.py\n    mule: lib/galaxy/main.py\n    farm: job-handlers:1,2\n```\n\nThat's it! This Galaxy instance will now start and use two job handler mules.\n\n???\n\n- Mules can be defined by adding them to Galaxy's configuration in the uWSGI section.\n- Farms collect groups of mules.\n\n---\n\n## The full startup picture\n\n???\n\n- The full startup picture.\n\n---\nclass: top\n\n## uWSGI Start/Run and Job Handling Lifecycle\n\n1. Master process loads Galaxy application.\n\n???\n\n- We'll go quickly through the entire lifecycle of a Galaxy process.\n- First, the master uWSGI process loads Galaxy\n\n--\n\n2. Master `fork()`s web worker processes and begins serving web requests.\n\n???\n\n- This forks worker processes to serve web requests\n\n--\n\n3. Master `fork()`s job handler mules.\n\n???\n\n- Then mules are forked.\n\n--\n\n4. Mules reload Galaxy application as job handlers.\n\n???\n\n- Mules reload the application to behave as handlers.\n\n--\n\n5. The first mule to fully initialize grabs a lock on the farm message queue.\n\n???\n\n- The first mule ready establishes an exclusive lock on the queue\n\n--\n\n6. All additional mules wait on the lock.\n\n???\n\n- Additional mules wait and compete to access the queue.\n\n--\n\n7. A web worker receives a request for a new job.\n\n???\n\n- Next, a user visits Galaxy and submits a job.\n\n--\n\n8. The web worker creates a `job` record in the database but leaves the `handler` field `null`.\n\n???\n\n- The web worker creates a job in the database, but leaves it unassigned.\n\n--\n\n9. The web worker uses uWSGI's `farm_msg()` function to notify the `job-handlers` farm that a new job is ready to run.\n\n???\n\n- The worker pings the job handler farm that a new job is ready to run\n\n--\n\n10. The mule with the lock receives the message, assigns itself, and gives up the lock.\n\n???\n\n- The mule with the lock assigns itself and gives up the lock to go process the job.\n\n--\n\n11. Another mule acquires the lock and waits for the next message.\n\n???\n\n- Another mule acquires a lock and waits patiently.\n\n--\n\n12. Repeat\n\n???\n\n- This process repeats to process jobs.\n\n---\n\n## Advanced: Job Handler Assignment Methods\n\n**Mules can only be used if web workers and job handlers run on the same host.**\n\nThe database can be used like a message queue to get the benefits of mules using webless job handlers.\n\nSee [Job Handler Assignment Methods](https://docs.galaxyproject.org/en/master/admin/scaling.html#job-handler-assignment-methods) for details.\n\nMules are preferred in scenarios where webless handlers are not needed.\n\n???\n\n- Mules are easy to setup, if you can run them on the same host.\n- This is usually the case.\n- If you have a more complex setup you might need webless job handlers.\n- There is documentation for when you need it.\n\n---\n\n## Advanced: Transparent Restart\n\nProvides uninterrupted restart capability (clients do not notice restarts).\n\nSee [Transparent Restart](https://docs.galaxyproject.org/en/master/admin/scaling.html#transparent-restart-zerg-mode) and [uWSGI Zerg Mode documentation](https://uwsgi-docs.readthedocs.io/en/latest/Zerg.html) for details.\n\n???\n\n- Zerg mode (named after the game StarCraft) can be used for transparent restarts.\n- Users really like this, and it gives you freedom to make changes behind the scenes.\n\n---\n\n## Advanced: Zerg Mode + Job Handler Mules\n\nCombining both advanced modes was long thought to be impossible.\n\nHowever, a proof of concept has emerged!\n\n[Watch this space](https://gist.github.com/natefoo/6e45ae363ef434f38a935ff1b05b4b6e).\n\n???\n\n- Combining both was not thought to be possible but there is ongoing work.\n- A proof of concept exists, but it is not in any Ansible playbook yet.\n"],"hands_on":false,"slides":true,"mod_date":"2022-03-01 12:21:57 +0000","pub_date":"2019-01-28 04:08:04 +0000","version":17,"api":"https://training.galaxyproject.org/training-material/api/topics/admin/tutorials/uwsgi/tutorial.json","tools":[],"supported_servers":[],"topic_name_human":"Galaxy Server administration","admin_install":{"install_tool_dependencies":true,"install_repository_dependencies":true,"install_resolver_dependencies":true,"tools":[]},"admin_install_yaml":"---\ninstall_tool_dependencies: true\ninstall_repository_dependencies: true\ninstall_resolver_dependencies: true\ntools: []\n","tours":false,"video":false,"slides_recordings":false,"translations":{"tutorial":[],"slides":[],"video":false},"license":"CC-BY-4.0","type":"tutorial","redirect_from":["/short/admin/uwsgi/slides","/short/S00028"]}
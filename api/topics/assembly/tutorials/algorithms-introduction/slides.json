{"layout":"tutorial_slides","logo":"GTN","title":"Deeper look into Genome Assembly algorithms","questions":["What are the main types of assembly algorithms?","How do they perform with short and long reads?","How to improve assemblies using other technologies?"],"contributors":["abretaud","slugger70","nekrut","delphine-l"],"level":"Intermediate","js_requirements":{"mathjax":null,"mermaid":false},"short_id":"S00029","url":"/topics/assembly/tutorials/algorithms-introduction/slides.html","topic_name":"assembly","tutorial_name":"algorithms-introduction","dir":"topics/assembly/tutorials/algorithms-introduction","symlink":null,"id":"assembly/algorithms-introduction","ref_tutorials":[],"ref_slides":["# Different types of input data\n\n* Short reads (Illumina): numerous üëç, high quality üëç, cheap üëç, short üëé\n* Long reads (PacBio, Nanopore): longer üëç, fewer üëé, (many) more errors üëé\n\nGenome Assembly can be done with:\n* only short reads\n* only long reads\n* both (hybrid assembly)\n\nSpecific algorithms for each\n\n---\n\n# Genome Assembly algorithms\n\nDetect overlaps between reads to build the longest possible sequences\n\nAlgorithms use graphs to represent overlapping reads/words\n\nTwo steps:\n\n* Build a (huge) graph while reading the input data\n* Try to find the longest paths traversing the graph\n\nTwo main types of algorithms:\n\n* Short reads: de Bruijn Graphs\n* Long reads: OLC (Overlap Layout Consensus)\n\n---\n\n# OLC (Overlap Layout Consensus)\n\nThe older, first used for Sanger sequencing\n\nCompare all reads, look for read overlaps\n\nIf a *suffix* of one read is similar to a *prefix* of another read...\n\n```\nTCTATATCTCGGCTCTAGG    <- read 1\n    ||||||| |||||||\n    TATCTCGACTCTAGGCC  <- read 2\n```\n\n...then they may overlap within the genome.\n\n---\n\n## Directed graphs\n\nWe build a *directed graph* where directed *edges* connect *nodes* representing overlapping reads:\n![Image showing example reads represented as nodes, and an overlap between two reads as an edge](../../images/dag.png)\n\n>**Directed graph** representing overlapping reads. (Image from [Ben Langmead](http://www.cs.jhu.edu/~langmea/resources/lecture_notes/assembly_scs.pdf)).\n\n---\n\n## Directed graphs\n\nFor example, consider these 15 three letter reads:\n\nTAA AAT ATG TGC GCC CCA CAT ATG TGG GGG GGA GAT ATG TGT GTT\n\nWe're lucky, we know the corresponding genome sequence is TAATGCCATGGGATGTT\n\nSo the 15 reads can be represented as the following directed graph:\n\n![A graph representing the 15 overlapping example reads](../../images/4.6.png)\n\n---\n\n**However**, in real life we do not know the actual genome! All we have is a collection of reads. Let's first build an overlap graph by connecting two 3-mers if suffix of one is equal to the prefix of the other:\n\n\n>![All possible overlap connections for our 3-mer collection](../../images/4.7.png)\n>\n>**Overlap graph**. All possible overlap connections for our 3-mer collection. (Fig. 4.7 from [CP](http://bioinformaticsalgorithms.com/))\n\nSo to determine the sequence of the underlying genome we are looking for a path in this graph that visits every node (3-mer) once. Such path is called [Hamiltonian path](https://en.wikipedia.org/wiki/Hamiltonian_path) and it may not be unique.\n\n---\n\nFor example for our 3-mer collection there are two possible Hamiltonian paths:\n\n![First possible Hamiltonian path](../../images/4.9a.png)\n![Second possible Hamiltonian path](../../images/4.9b.png)\n\n**Two Hamiltonian paths for the 15 3-mers**. Edges spelling \"genomes\" <code>TAATGCCATGGGATGTT</code> and <code>TAATGGGATGCCATGTT</code> are highlighted in black. (Fig. 4.9. from [[CP](http://bioinformaticsalgorithms.com/)](http://bioinformaticsalgorithms.com/)).\n\n---\n\nThe reason for this \"duality\" is the fact that we have a *repeat*: 3-mer <code>ATG</code> is present three times in our data (<font color=\"green\">green</font>, <font color=\"red\">red</font>, and <font color=\"blue\">blue</font>). Repeats cause a lot of trouble in genome assembly.\n\n---\n\n# Limits of OLC\n\n* Computationally intensive\n* Doesn't perform well with Illumina (massive amount of short reads)\n\n=> deBruijn Graphs\n\n---\n\n# **de Bruijn Graphs**\n\nBased on a counter-intuitive idea\n\n* Hash all reads in overlapping fixed-length words\n* Words = k-mers of size k\n* Build a directed graph where nodes are k-mers and edges represent overlaps between k-mers\n\n---\n\n# **What are K-mers?**\n![K-mers are subwords of length k of a string](../../images/kmers01.png)\n\n---\n\n# **K-mers de Bruijn graph**\n![Example with 4 english words](../../images/ex1-1.png)\n\n---\n\n# **K-mers de Bruijn graph**\n![Example with 4 english words](../../images/ex1-2.png)\n\n---\n\n# **K-mers de Bruijn graph**\n![Example with 4 english words](../../images/ex1-3.png)\n\n---\n\n# **K-mers de Bruijn graph**\n![Example with 4 english words](../../images/ex1-4.png)\n\n---\n\n# **The problem of repeats**\n![Example with a word containing repeats: Mississippi](../../images/ex2-1.png)\n\n---\n\n# **The problem of repeats**\n![Example with a word containing repeats: Mississippi](../../images/ex2-2.png)\n\n---\n\n# **The problem of repeats**\n![Example with a word containing repeats: Mississippi](../../images/ex2-3.png)\n\n---\n\n# **The problem of repeats**\n![Example with a word containing repeats: Mississippi](../../images/ex2-4.png)\n\n---\n\n# **Different k**\n![Effect of the size of k](../../images/ex2a-1.png)\n---\n# **Different k**\n![Effect of the size of k](../../images/ex2a-2.png)\n---\n# **Different k**\n![Effect of the size of k](../../images/ex2a-3.png)\n---\n# **Different k**\n![Effect of the size of k](../../images/ex2a-4.png)\n\n---\n# **Choose k wisely**\n\n* Lower k\n  * More connections\n  * Less chance of resolving small repeats\n  * Higher k-mer coverage\n\n* Higher k\n  * Less connections\n  * More chance of resolving small repeats\n  * Lower k-mer coverage\n\n***Optimum value for k will balance these effects.***\n\n---\n\n# **Read errors**\n.image-75[![Example of english words with errors](../../images/ex3-head.png)]\n![Example of english words with errors](../../images/blank.png)\n---\n\n# **Read errors**\n.image-75[![Example of english words with errors](../../images/ex3-head.png)]\n![Example of english words with errors](../../images/ex3-2.png)\n---\n# **Read errors**\n.image-75[![Example of english words with errors](../../images/ex3-head.png)]\n![Example of english words with errors](../../images/ex3-3.png)\n---\n# **Read errors**\n.image-75[![Example of english words with errors](../../images/ex3-head.png)]\n![Example of english words with errors](../../images/ex3-4.png)\n\n---\n\n# Coverage (or sequencing depth)\n\nThe number of unique reads that contain a given nucleotide in the reconstructed sequence.\n\n![Aligned reads showing the notion of coverage](../../images/coverage.png)\n\nSource: [Wikimedia](https://commons.wikimedia.org/wiki/File:Read,_read_length_and_read_depth_to_achieve_a_read_depth)\n\n**Estimated coverage**\n\n**(number of reads x read length)** / **estimated size of the genome**\n\n1,000,000 reads x 150bp / 10Mb = **15X**\n\n---\n# **More coverage**\n\n* Errors won't be duplicated in every read\n* Most reads will be error free\n* We can count the frequency of each k-mer\n* Annotate the graph with the frequencies\n* Use the frequency data to clean the de Bruijn graph\n\n\n***More coverage depth will help overcome errors!***\n---\n# **Read errors revisited**\n![Graph annotated with coverage](../../images/ex3a.png)\n\n---\n\n# **de Bruijn graph assembly process**\n\n1. Select a value for k\n2. \"Hash\" the reads (make the kmers)\n3. Count the kmers\n4. Make the de Bruijn graph\n5. Perform graph simplification steps\n6. Read off contigs from simplified graph\n\n---\n# **Make contigs**\n\n* Find an unbalanced node in the graph\n* Follow the chain of nodes and \"read off\" the bases to produce the contigs\n* Where there is an ambiguous divergence/convergence, stop the current contig and start a new one.\n* Re-trace the reads through the contigs to help with repeat resolution\n\n---\n\n# Assembly in real life\n\nIn this topic we've learned about two ways of representing the relationship between reads derived from a genome we are trying to assemble:\n\n1. **Overlap graphs** - nodes are reads, edges are overlaps between reads.\n2. **De Bruijn graphs** - nodes are overlaps, edges are reads.\n\n---\n\n# Overlap graph\n\n![An example overlap graph](../../images/4.7.png)\n\n---\n\n# de Bruijn Graph - same data\n\n![An example de Bruijn graph](../../images/4.13f.png)\n\n---\n\nWhatever the representation will be it will be messy:\n\n![An example of a real-life, noisy graph](../../images/t12_mess.png)\n\nA fragment of a very large De Bruijn graph (Image from [BL](https://github.com/BenLangmead/ads1-slides/blob/master/0580_asm__practice.pdf)).\n\n---\n\n\nThere are multiple reasons for such messiness:\n\n**Sequence errors**\n\nSequencing machines do not give perfect data. This results in spurious deviations on the graph. Some sequencing technologies such as Oxford Nanopore have very high error rate of ~15%.\n\n>![Zoom on graph region containing sequencing errors](../../images/t12_errors.png)\n>\n>Graph components resulting from sequencing errors (Image from [BL](https://github.com/BenLangmead/ads1-slides/blob/master/0580_asm__practice.pdf)).\n\n---\n\n**Ploidy**\n\nAs we discussed earlier humans are diploid and there are multiple differences between maternal and paternal genomes. This creates \"bubbles\" on assembly graphs:\n\n>![Impact of diploid genome sequencing on graphs](../../images/t12_bubble.png)\n>\n>Bubbles due to a heterozygous site  (Image from [BL](https://github.com/BenLangmead/ads1-slides/blob/master/0580_asm__practice.pdf)).\n\n---\n\n**Repeats**\n\nAs we've seen the third law of assembly is unbeatable. As a result some regions of the genome simply cannot be resolved and are reported in segments called *contigs*:\n\n>![Impact of repeats on graphs](../../images/t12_contigs.png)\n>\n>The following \"genomic\" segment will be reported in three pieces corresponding to regions flanking the repeat and repeat itself (Image from [BL](https://github.com/BenLangmead/ads1-slides/blob/master/0580_asm__practice.pdf)).\n\n---\n\n# What to do with my reads?\n\n* Short reads => DBG assemblers (e.g. Spades, ABySS, DISCOVAR, Velvet, ...)\n* Long reads => OLC assemblers (e.g Canu, Falcon, Hgap4, ...)\n* Short + Long reads => hybrid assemblers (e.g. Unicycler, ...)\n\nHybrid assembly: long reads to resolve repeats, short reads to correct errors\n\nOther data and tools for polishing (scaffolding, gap filling, ...)\n\n---\n\n# Other data: Optical maps\n\n![Optical mapping workflow](../../images/Optical_mapping.jpg)\n(Source: [Wikimedia](https://en.wikipedia.org/wiki/Optical_mapping#/media/File:Optical_mapping.jpg))\n\nUse for scaffolding by comparing the restriction map with the predicted restriction sites in the contig sequences\n\n---\n\n# Other data:  Hi-C\n\n![Hi-C sequencing workflow](../../images/hic.jpg)\n(Source: Dovetail genomics)\n\nSequence chunks of genome colocalized\n\n---\n\n# Other data: Linked-Reads\n\n![Linked-Reads workflow](../../images/linked_reads.png)\n(Source: 10X)\n\nReads grouped by physical regions on the genome thanks to barcodes\n\n10X Genomics (discontinued in 2020)\n"],"video_library":{"tutorial":null,"slides":null,"demo":null,"both":null,"session":null},"hands_on":false,"slides":true,"mod_date":"2020-12-28 16:29:36 +0000","pub_date":"2021-01-12 13:46:54 +0000","version":2,"api":"https://training.galaxyproject.org/training-material/api/topics/assembly/tutorials/algorithms-introduction/tutorial.json","tools":[],"supported_servers":{"exact":[],"inexact":[{"name":"UseGalaxy.eu","url":"https://usegalaxy.eu","id":"eu","human":"Galaxy Europe","usegalaxy":true},{"name":"UseGalaxy.org","url":"https://usegalaxy.org","id":"us","human":"Galaxy Main","usegalaxy":true},{"name":"UseGalaxy.org.au","url":"https://usegalaxy.org.au","id":"au","human":"Galaxy Australia","usegalaxy":true},{"name":"UseGalaxy.fr","url":"https://usegalaxy.fr","id":"fr","human":"Galaxy France","usegalaxy":true}]},"topic_name_human":"Assembly","admin_install":{"install_tool_dependencies":true,"install_repository_dependencies":true,"install_resolver_dependencies":true,"tools":[]},"admin_install_yaml":"---\ninstall_tool_dependencies: true\ninstall_repository_dependencies: true\ninstall_resolver_dependencies: true\ntools: []\n","tours":false,"video":false,"translations":{"tutorial":[],"slides":[],"video":false},"license":"CC-BY-4.0","type":"tutorial","redirect_from":["/short/assembly/algorithms-introduction/slides","/short/S00029"]}
{"layout":"tutorial_slides","title":"Unicycler Assembly","zenodo_link":"https://doi.org/10.5281/zenodo.940733","level":"Introductory","tags":["prokaryote"],"edam_ontology":["topic_0196","topic_0622","topic_3301"],"questions":["I have short reads and long reads. How do I assemble a genome?"],"objectives":["Perform Quality Control on your reads","Perform a Small genome Assembly with Unicycler","Evaluate the Quality of the Assembly with Quast","Annotate the assembly with Prokka"],"follow_up_training":[{"type":"internal","topic_name":"assembly","tutorials":["ecoli_comparison"]}],"time_estimation":"4h","key_points":["We learned about the strategies used by assemblers for hybrid assemblies","We performed an hybrid assembly of a bacterial genome and its annotation","Unicycler is a pipeline bases on Spades and Pilon dedicated to hybrid assembly of Small genomes","Combination of short and long reads helped us produce an almost perfect assembly"],"contributors":["nekrut","delphine-l","slugger70"],"js_requirements":{"mathjax":null,"mermaid":false},"short_id":"S00035","url":"/topics/assembly/tutorials/unicycler-assembly/slides.html","topic_name":"assembly","tutorial_name":"unicycler-assembly","dir":"topics/assembly/tutorials/unicycler-assembly","symlink":null,"id":"assembly/unicycler-assembly","ref_tutorials":["<h1 id=\"the-goal-e-coli-c-1-assembly\">The goal: <em>E. coli</em> C-1 assembly</h1>\n\n<p>In this tutorial we assemble and annotate the genome of <em>E. coli</em> strain <a href=\"http://cgsc2.biology.yale.edu/Strain.php?ID=8232\">C-1</a>. This strain is routinely used in experimental evolution studies involving bacteriophages. For instance, now classic works by Holly Wichman and Jim Bull (<span class=\"citation\"><a href=\"#Bull1997\">Bull 1997</a></span>, <span class=\"citation\"><a href=\"#Bull1998\">Bull 1998</a></span>, <span class=\"citation\"><a href=\"#Wichman1999\">Wichman 1999</a></span>) have been performed using this strain and bacteriophage phiX174.</p>\n\n<p>To sequence the genome we have obtained the strain from the <a href=\"http://cgsc2.biology.yale.edu/\">Yale E. coli Stock Center</a>. The stock center sent us a filter paper disk infused with cells. The disk was placed in the center of an LB-agar plate. A single colony was picked and resuspended in a liquid LB medium, grown overnight, and genomic DNA was isolated. The DNA was then sequenced using two methods. To obtain high coverage, high accuracy data we used Illumina miSEQ to generated 250-bp paired end reads. To generate high length reads we used the Oxford Nanopore MinION machine.</p>\n\n<p>Our goal is to reconstruct and annotate the full genome of <em>E. coli</em> C-1. As you will see in this tutorial a combination of many short, high accuracy reads with long, error-prone reads helps us produce an almost perfect assembly.</p>\n\n<blockquote class=\"agenda\">\n  <h3 id=\"outline-step-by-step\">Outline step-by-step</h3>\n\n  <p>In this tutorial, we will deal with:</p>\n\n<ol id=\"markdown-toc\">\n  <li><a href=\"#the-goal-e-coli-c-1-assembly\" id=\"markdown-toc-the-goal-e-coli-c-1-assembly\">The goal: <em>E. coli</em> C-1 assembly</a></li>\n  <li><a href=\"#background-on-data-and-tools\" id=\"markdown-toc-background-on-data-and-tools\">Background on data and tools</a>    <ol>\n      <li><a href=\"#the-data\" id=\"markdown-toc-the-data\">The data</a></li>\n      <li><a href=\"#the-tools\" id=\"markdown-toc-the-tools\">The tools</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#lets-try-it\" id=\"markdown-toc-lets-try-it\">Let’s try it</a>    <ol>\n      <li><a href=\"#load-data-and-assess-quality\" id=\"markdown-toc-load-data-and-assess-quality\">Load data and assess quality</a></li>\n      <li><a href=\"#assembly-with-unicycler\" id=\"markdown-toc-assembly-with-unicycler\">Assembly with Unicycler</a></li>\n      <li><a href=\"#assess-assembly-quality-with-quast\" id=\"markdown-toc-assess-assembly-quality-with-quast\">Assess Assembly quality with Quast</a></li>\n      <li><a href=\"#annotation-with-prokka\" id=\"markdown-toc-annotation-with-prokka\">Annotation with Prokka</a></li>\n      <li><a href=\"#visualize-the-results-in-igv\" id=\"markdown-toc-visualize-the-results-in-igv\">Visualize the results in IGV</a></li>\n    </ol>\n  </li>\n</ol>\n\n</blockquote>\n\n<h1 id=\"background-on-data-and-tools\">Background on data and tools</h1>\n\n<h2 id=\"the-data\">The data</h2>\n\n<p>In this tutorial we will assemble a genome using two types of input data: (1) Illumina 250 bp paired-end reads and (2) Oxford Nanopore reads.</p>\n\n<h3 id=\"illumina-data\">Illumina data</h3>\n\n<p>We generated 9,345,897 250 bp read pairs (library preparation performed on genomic DNA fragmented to mean size of 600 bp). However, to make sure that you can complete this tutorial in a finite amount of time we have downsampled (reduced in size) to 1,000,000 paired end reads - just enough to produce an accurate assembly.</p>\n\n<h3 id=\"oxford-nanopore-data\">Oxford Nanopore Data</h3>\n\n<p>There are 12,738 <a href=\"http://www.nature.com/nmeth/journal/v12/n4/fig_tab/nmeth.3290_SF13.html\">2d-reads</a>. Maximum read length is 27,518 bp. The distribution of reads lengths looks like this:</p>\n\n<figure id=\"figure-1\" style=\"max-width: 90%;\"><img src=\"../../images/ont_length.png\" alt=\"Nanopore read length distribution. \" width=\"640\" height=\"480\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/ont_length.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 1</strong>:</span> Distribution of nanopore read lengths.</figcaption></figure>\n\n<p>You can see that there many reads under the second peak with median of approximately 7.5 kb.</p>\n\n<blockquote class=\"warning\">\n  <warning-title>Oxford Nanopore Data Format</warning-title>\n  <p>Oxford Nanopore machines output data in <a href=\"http://bioinformatics.cvr.ac.uk/blog/exploring-the-fast5-format/\">fast5</a> format that contains additional information besides sequence data. In this tutorial we assume that this data is <em>already</em> converted into <a href=\"https://en.wikipedia.org/wiki/FASTQ_format\">fastq</a>. An additional tutorial dedicated to handling fast5 datasets will be developed shortly.</p>\n</blockquote>\n\n<h2 id=\"the-tools\">The tools</h2>\n\n<p>In this analysis we will perform two tasks: (1) assembly and (2) annotation. Below we will briefly outline the main ideas behind these two procedures and will describe the tools we will be using.</p>\n\n<h3 id=\"assembly\">Assembly</h3>\n\n<blockquote class=\"comment\">\n  <comment-title>Knowing your assembly</comment-title>\n\n  <p>Here we assume that you know a thing or two about assembly process. If you don’t: look at the slides accompanying this tutorial as well as other tutorials is this section.</p>\n</blockquote>\n\n<p><a href=\"https://github.com/rrwick/Unicycler/raw/master/misc/logo.png\" rel=\"noopener noreferrer\"><img src=\"https://github.com/rrwick/Unicycler/raw/master/misc/logo.png\" alt=\"Logo unicycler. \" loading=\"lazy\" /></a></p>\n\n<p>For assembly we will be using <a href=\"https://github.com/rrwick/Unicycler\">Unicycler</a> (also see publication <span class=\"citation\"><a href=\"#Wick2017\">Wick <i>et al.</i> 2017</a></span>). Unicycler is designed specifically for <em>hybrid assembly</em> (that is, using both short- and long-read sequencing data) of small (e.g., bacterial, viral, organellar) genomes. In our hands it has produced complete high quality assemblies. Unicycler employs a multi-step process that utilizes a number of software tools:</p>\n\n<figure id=\"figure-2\" style=\"max-width: 90%;\"><img src=\"../../images/unicycler.png\" alt=\"Unicycler process. \" width=\"3700\" height=\"4531\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/unicycler.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 2</strong>:</span> Simplified view of the Unicycler assembly process (From <span class=\"citation\"><a href=\"#Wick2017\">Wick <i>et al.</i> 2017</a></span>) In short, Unicycler uses SPAdes (see below) to produce an assembly graph, which is then bridged (simplified) using long reads to produce the longest possible set of contigs. These are then polished by aligning the original short reads against contigs and feeding these alignments to Pilon - an assembly improvement tool. <span class=\"citation\"><a href=\"#Wick2017\">Wick <i>et al.</i> 2017</a></span></figcaption></figure>\n\n<p>As you can see Unicycler relies heavily on SPAdes (<span class=\"citation\"><a href=\"#Bankevich2012\">Bankevich <i>et al.</i> 2012</a></span>) and <a href=\"https://github.com/broadinstitute/pilon/wiki\">Pilon</a>. We will briefly describe these two tools.</p>\n\n<h4 id=\"spades\">Spades</h4>\n\n<h5 id=\"multisized-debruijn-graph\">Multisized deBruijn graph</h5>\n\n<p>Assemblers usually construct graphs for <em>k</em>-mers of a fixed size. We have noted that when <em>k</em> is small it is difficult to resolve the repeats. If <em>k</em> is too large a corresponding graph may be fragmented (especially if read coverage is low). SPAdes uses several values for <em>k</em> (that are either manually set or inferred automatically) to create a <em>multisized</em> graph that minimized tangledness and fragmentation by combining various <em>k</em>-mers (<span class=\"citation\"><a href=\"#Bankevich2012\">Bankevich <i>et al.</i> 2012</a></span>)):</p>\n\n<figure id=\"figure-3\" style=\"max-width: 90%;\"><img src=\"../../images/multiGraph.jpg\" alt=\"Multigraph approach implemented in SPAdes. \" width=\"2400\" height=\"1697\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/multiGraph.jpg\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 3</strong>:</span> Multisized de Bruijn graph. A circular Genome CATCAGATAGGA is covered by a set of Reads consisting of nine 4-mers, {ACAT, CATC, ATCA, TCAG, CAGA, AGAT, GATA, TAGG, GGAC}. Three out of 12 possible 4-mers from Genome are missing from Reads (namely {ATAG,AGGA,GACA}), but all 3-mers from the Genome are present in the Reads. (A) The outside circle shows a separate black edge for each 3-mer from Reads. Dotted red lines indicate vertices that will be glued. The inner circle shows the result of applying some of the glues. (B) The graph DB(Reads, 3) resulting from all the glues is tangled. The three h-paths of length 2 in this graph (shown in blue) correspond to h-reads ATAG, AGGA, and GACA. Thus Reads<sub>3,4</sub> contains all 4-mers from Genome. (C) The outside circle shows a separate edge for each of the nine 4-mer reads. The next inner circle shows the graph DB(Reads, 4), and the innermost circle represents the Genome. The graph DB(Reads, 4) is fragmented into 3 connected components. (D) The multisized de Bruijn graph DB (Reads, 3, 4). Figure and text from <span class=\"citation\"><a href=\"#Bankevich2012\">Bankevich <i>et al.</i> 2012</a></span>.</figcaption></figure>\n\n<h5 id=\"read-pair-utilization\">Read pair utilization</h5>\n\n<p>While the use of paired reads and mate pairs is key to genome assembly, and not new, SPAdes utilizes so called paired DeBruin graphs to take the advantage of the paired end data. One of the key issues with paired DeBruin graphs is that the resulting genome assemblies do not tolerate variability in insert sizes: The initial formulation of paired DeBruijn graphs assumed constant distance between pairs of reads. In practice this distance is always variable. SPAdes performs <em>k</em>-bimer (these are <em>k</em>-mers derived from <em>paired</em> reads) adjustment to identify exact or nearly-exact distances for each <em>k</em>-bimer pair.</p>\n\n<h5 id=\"error-correction\">Error correction</h5>\n\n<p>Sequencing data contains a substantial number of sequencing errors that manifest themselves as deviations (bulges and non-connected components) within the assembly graph. One way to improve the graph before assembly it is to minimize the number of sequencing errors by performing error correction. SPAdes uses BayesHammer (<span class=\"citation\"><a href=\"#Nikolenko2013\">Nikolenko <i>et al.</i> 2013</a></span>) to correct the reads. Here is a brief summary of what it does:</p>\n\n<ol>\n  <li>SPAdes (or rather BayesHammer) counts <em>k</em>-mers in reads and computes <em>k</em>-mer statistics that take into account base quality values.</li>\n  <li>A <a href=\"https://en.wikipedia.org/wiki/Hamming_graph\">Hamming graph</a> is constructed in which <em>k</em>-mers are nodes. In this graph edges connect nodes (<em>k</em>-mers) if they differ from each other by a number of nucleotides up to a certain threshold (the <a href=\"https://en.wikipedia.org/wiki/Hamming_distance\">Hamming distance</a>). The graph is central to the error correction algorithm.</li>\n  <li>Then Bayesian subclustering is done on the graph from the previous step. For each <em>k</em>-mer we now know the center of its subcluster.</li>\n  <li><strong>Solid</strong> <em>k</em>-mers are derived from cluster centers and are assumed to be <em>error free</em>.</li>\n  <li>Solid <em>k</em>-mers are mapped back to the reads.</li>\n  <li>Reads are corrected using solid <em>k</em>-mers:</li>\n</ol>\n\n<figure id=\"figure-4\" style=\"max-width: 90%;\"><img src=\"../../images/readCorrection.jpg\" alt=\"Read correction with BayesHammer. \" width=\"1200\" height=\"725\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/readCorrection.jpg\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 4</strong>:</span> Read correction. Black <em>k</em>-mers are solid. Grey <em>k</em>-mers are non-solid. Red <em>k</em>-mers are the centers of the corresponding clusters (two grey <em>k</em>-mers striked through on the right are non-solid singletons). As a result, one nucleotide is changed based on majority rule. (From <span class=\"citation\"><a href=\"#Nikolenko2013\">Nikolenko <i>et al.</i> 2013</a></span>)</figcaption></figure>\n\n<p>In the case of the full dataset, SPAdes error correction changed 14,013,757 bases in 3,382,337 reads - a substantial fraction of the full ~18 million read dataset.</p>\n\n<h4 id=\"pilon\">Pilon</h4>\n\n<p>Pilon improves draft assemblies by using the information from the original reads aligned to the draft assembly. The following image from a publication by <span class=\"citation\"><a href=\"#Walker2014\">Walker <i>et al.</i> 2014</a></span> highlights the steps of this process:</p>\n\n<figure id=\"figure-5\" style=\"max-width: 90%;\"><img src=\"../../images/pilon.png\" alt=\"Pilon workflow. \" width=\"1762\" height=\"1028\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/pilon.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 5</strong>:</span> The left column depicts the conceptual steps of the Pilon process, and the center and right columns describe what Pilon does at each step while in assembly improvement and variant detection modes, respectively. During the first step (top row), Pilon scans the read alignments for evidence where the sequencing data disagree with the input genome and makes corrections to small errors and detects small variants. During the second step (second row), Pilon looks for coverage and alignment discrepancies to identify potential mis-assemblies and larger variants. Finally (bottom row), Pilon uses reads and mate pairs which are anchored to the flanks of discrepant regions and gaps in the input genome to reassemble the area, attempting to fill in the true sequence including large insertions. The resulting output is an improved assembly and/or a VCF file of variants. (From <span class=\"citation\"><a href=\"#Walker2014\">Walker <i>et al.</i> 2014</a></span>)</figcaption></figure>\n\n<h3 id=\"annotation\">Annotation</h3>\n\n<p>For annotation we are using <a href=\"https://vicbioinformatics.com/software.prokka.shtml\">Prokka</a> (also see <span class=\"citation\"><a href=\"#Seemann2014\">Seemann 2014</a></span>). It scans the assembly generated with Unicycler with a set of feature prediction tools and compiles a list of genome annotation. It predicts the following features (Table from <span class=\"citation\"><a href=\"#Seemann2014\">Seemann 2014</a></span>):</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Feature</th>\n      <th>Tool used by Prokka</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Protein-coding sequences (CDS)</td>\n      <td><a href=\"https://github.com/hyattpd/Prodigal\">Prodigal</a></td>\n    </tr>\n    <tr>\n      <td>Ribosomal RNA genes</td>\n      <td><a href=\"https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1888812\">RNAmmer</a></td>\n    </tr>\n    <tr>\n      <td>Transfer RNA genes</td>\n      <td><a href=\"https://www.ncbi.nlm.nih.gov/pubmed/14704338\">Aragorn</a></td>\n    </tr>\n    <tr>\n      <td>Signal leader peptides</td>\n      <td><a href=\"https://www.ncbi.nlm.nih.gov/pubmed/21959131\">SignalP</a></td>\n    </tr>\n    <tr>\n      <td>Non-coding RNA genes</td>\n      <td><a href=\"http://eddylab.org/infernal/\">Infernal</a></td>\n    </tr>\n  </tbody>\n</table>\n\n<p>Prokka predicts protein-coding regions using a two step process. It first identifies coordinates of putative genes using <a href=\"https://github.com/hyattpd/Prodigal\">Prodigal</a> and then compares the gene sequence against databases of known sequences at protein level using <a href=\"https://www.ncbi.nlm.nih.gov/books/NBK279690/\">Blast+</a> and <a href=\"http://hmmer.org/\">HMMer</a>.</p>\n\n<h1 id=\"lets-try-it\">Let’s try it</h1>\n\n<h2 id=\"load-data-and-assess-quality\">Load data and assess quality</h2>\n\n<p>In this example we will use a downsampled version of <em>E. coli</em> C-1 Illumina and ONT sequencing data. These include 3 files: forward and reverse reads for Illumina, and Long read file produced by ONT. All data are in <a href=\"https://en.wikipedia.org/wiki/FASTQ_format\">fastq</a> format.</p>\n\n<blockquote class=\"hands_on\">\n  <hands-on-title>Obtaining our data</hands-on-title>\n\n  <ol>\n    <li>\n      <p>Make sure you have an empty analysis history. Give it a name.</p>\n\n      <!--SNIPPET-->\n      <blockquote class=\"tip\">   <div class=\"box-title tip-title\" id=\"tip-creating-a-new-history\"><button class=\"gtn-boxify-button tip\" type=\"button\" aria-controls=\"tip-creating-a-new-history\" aria-expanded=\"true\"><i class=\"far fa-lightbulb\" aria-hidden=\"true\"></i> <span>Tip: Creating a new history</span><span class=\"fold-unfold fa fa-minus-square\"></span></button></div>   <p>Click the <i class=\"fas fa-plus\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">new-history</span> icon at the top of the history panel:</p>   <p><img src=\"/training-material/shared/images/history_create_new.svg\" alt=\"UI for creating new history\" /></p>   <!-- the original drawing can be found here https://docs.google.com/drawings/d/1cCBrLAo4kDGic5QyB70rRiWJAKTenTU8STsKDaLcVU8/edit?usp=sharing --> </blockquote>\n      <p><!--END_SNIPPET--></p>\n    </li>\n    <li>\n      <p>Import the following file from <a href=\"https://zenodo.org/record/940733\">Zenodo</a></p>\n\n      <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>https://zenodo.org/record/940733/files/illumina_f.fq\nhttps://zenodo.org/record/940733/files/illumina_r.fq\nhttps://zenodo.org/record/940733/files/minion_2d.fq\n</code></pre></div>      </div>\n\n      <!--SNIPPET-->\n      <blockquote class=\"tip\">   <div class=\"box-title tip-title\" id=\"tip-importing-via-links\"><button class=\"gtn-boxify-button tip\" type=\"button\" aria-controls=\"tip-importing-via-links\" aria-expanded=\"true\"><i class=\"far fa-lightbulb\" aria-hidden=\"true\"></i> <span>Tip: Importing via links</span><span class=\"fold-unfold fa fa-minus-square\"></span></button></div>   <ul>   <li>Copy the link location</li>   <li>     <p>Click <i class=\"fas fa-upload\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">galaxy-upload</span> <strong>Upload Data</strong> at the top of the tool panel</p>   </li>   <li>Select <i class=\"fa fa-edit\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">galaxy-wf-edit</span> <strong>Paste/Fetch Data</strong></li>   <li>     <p>Paste the link(s) into the text field</p>   </li>   <li>     <p>Press <strong>Start</strong></p>   </li>   <li><strong>Close</strong> the window</li> </ul> </blockquote>\n      <p><!--END_SNIPPET--></p>\n\n      <!--SNIPPET-->\n      <blockquote class=\"tip\">   <div class=\"box-title tip-title\" id=\"tip-importing-data-from-a-data-library\"><button class=\"gtn-boxify-button tip\" type=\"button\" aria-controls=\"tip-importing-data-from-a-data-library\" aria-expanded=\"true\"><i class=\"far fa-lightbulb\" aria-hidden=\"true\"></i> <span>Tip: Importing data from a data library</span><span class=\"fold-unfold fa fa-minus-square\"></span></button></div>   <p>As an alternative to uploading the data from a URL or your computer, the files may also have been made available from a <em>shared data library</em>:</p>   <ol>   <li>Go into <strong>Shared data</strong> (top panel) then <strong>Data libraries</strong></li>   <li>Navigate to  the correct folder as indicated by your instructor.     <ul>       <li>On most Galaxies tutorial data will be provided in a folder named <strong>GTN - Material –&gt; Topic Name -&gt; Tutorial Name</strong>.</li>     </ul>   </li>   <li>Select the desired files</li>   <li>Click on <strong>Add to History</strong> <i class=\"fas fa-caret-down\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">galaxy-dropdown</span> near the top and select <strong>as Datasets</strong> from the dropdown menu</li>   <li>     <p>In the pop-up window, choose</p>     <ul>       <li><em>“Select history”</em>: the history you want to import the data to (or create a new one)</li>     </ul>   </li>   <li>Click on <strong>Import</strong></li> </ol> </blockquote>\n      <p><!--END_SNIPPET--></p>\n    </li>\n  </ol>\n\n</blockquote>\n\n<p>If all goes well you will see datasets uploading and changing states from gray to green as shown below. The figure below also shows how datasets can be tagged.</p>\n\n<figure id=\"figure-6\" style=\"max-width: 90%;\"><img src=\"../../images/starting_data.png\" alt=\"Datasets in History. \" width=\"1586\" height=\"717\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/starting_data.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 6</strong>:</span> Sequencing data loaded into Galaxy history. The full progression from gray (scheduling) to green (all OK) state is shown. To make it easier to identify datasets as we progress through the analysis we use so-called <em>Hashtags</em>. To tag a dataset: click on dataset to expand it (as shown in panel four); click the tag icon (<i class=\"fa fa-tags\" aria-hidden=\"true\"></i>) and a text field will appear. Add a tag (in this case <b>F</b>) pre-pended with hash (#). Hit enter. Do this for all three datasets and it will appear as in panel five.</figcaption></figure>\n\n<h3 id=\"assess-read-quality\">Assess Read Quality</h3>\n\n<p>To assess quality we will use two tools: FastQC (<span class=\"citation\"><a href=\"#FastQC\">Andrews</a></span>) to generate quality statistics and multiQC (<span class=\"citation\"><a href=\"#Ewels2016\">Ewels <i>et al.</i> 2016</a></span>) to summarize these statistics.</p>\n\n<blockquote class=\"hands_on\">\n  <hands-on-title>Quality Control</hands-on-title>\n\n  <ol>\n    <li>\n      <p><strong>FastQC</strong> <i class=\"fas fa-wrench\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">tool</span>:</p>\n\n      <ul>\n        <li><i class=\"far fa-copy\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">param-files</span> <em>“Short read data from your current history”</em>: Select all three FastQ datasets simultaneously</li>\n      </ul>\n    </li>\n    <li>\n      <p><strong>MultiQC</strong> <i class=\"fas fa-wrench\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">tool</span>: to generate a summary of the FastQC reports with</p>\n      <ul>\n        <li><em>“Which tool was used generate logs?”</em>: <code class=\"language-plaintext highlighter-rouge\">FastQC</code></li>\n        <li><em>“Type of FastQC output”</em>: <code class=\"language-plaintext highlighter-rouge\">Raw data</code></li>\n        <li><i class=\"far fa-copy\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">param-files</span> <em>“FastQC Output”</em>: <code class=\"language-plaintext highlighter-rouge\">RawData</code> outputs of FastQC</li>\n      </ul>\n    </li>\n  </ol>\n\n</blockquote>\n\n<p>A quick look at quality score distribution will show a confusing picture:</p>\n\n<figure id=\"figure-7\" style=\"max-width: 90%;\"><img src=\"../../images/multiqc1.png\" alt=\"QC reported zoomed out. \" width=\"682\" height=\"520\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/multiqc1.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 7</strong>:</span> Because Illumina reads (green) are <b>much</b> shorter that ONT reads (red) the plot looks strange. ONT reads generally have low quality scores and so they are not really meaningful in the context of this technology. However, in the case of Illumina data they mean a lot...</figcaption></figure>\n\n<p>So let’s zoom in into Illumina data:</p>\n\n<figure id=\"figure-8\" style=\"max-width: 90%;\"><img src=\"../../images/multiqc2.png\" alt=\"QC reported zoomed in. \" width=\"674\" height=\"512\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/multiqc2.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 8</strong>:</span> Zooming in shows quality distribution for Illumina reads. This is excellent data with mean base qualities above 30 across all reads.</figcaption></figure>\n\n<h2 id=\"assembly-with-unicycler\">Assembly with Unicycler</h2>\n\n<p>Now it is time to perform assembly.</p>\n\n<blockquote class=\"hands_on\">\n  <hands-on-title>Unicycler Assembly</hands-on-title>\n\n  <ol>\n    <li><strong>Unicycler</strong> <i class=\"fas fa-wrench\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">tool</span> with the following parameters :\n      <ul>\n        <li>“Paired or Single end data?” to <code class=\"language-plaintext highlighter-rouge\">Paired</code></li>\n        <li>“First Set of reads” to the forward reads file <code class=\"language-plaintext highlighter-rouge\">f</code></li>\n        <li>“Second Set of reads” to the reverse reads file <code class=\"language-plaintext highlighter-rouge\">r</code></li>\n        <li>“Long reads” to the MinION file</li>\n        <li>Use default parameters</li>\n      </ul>\n    </li>\n  </ol>\n\n</blockquote>\n\n<blockquote class=\"warning\">\n  <h3 id=\"--assembly-takes-time\"><i class=\"fa fa-cutlery\" aria-hidden=\"true\"></i> <i class=\"fa fa-coffee\" aria-hidden=\"true\"></i> Assembly takes time!</h3>\n\n  <p>There is no such thing as Assembly in real time. It takes time so it is a good time to have lunch or at least coffee. This Unicycler run will take anywhere between 90 minutes and two hours.</p>\n</blockquote>\n\n<h2 id=\"assess-assembly-quality-with-quast\">Assess Assembly quality with Quast</h2>\n\n<p>Quast (<span class=\"citation\"><a href=\"#Gurevich2013\">Gurevich <i>et al.</i> 2013</a></span>) is a tool providing quality metrics for assemblies, and can also be used to compare multiple assemblies. The tool can also take an optional reference file as input, and will provide complementary metrics.</p>\n\n<blockquote class=\"hands_on\">\n  <hands-on-title>Assembly Quality</hands-on-title>\n\n  <ol>\n    <li><strong>Quast</strong> <i class=\"fas fa-wrench\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">tool</span>: with the following parameters\n      <ul>\n        <li><em>“Contigs/scaffolds output file”</em>: Select the fasta file resulting from the Unicycler assembly.</li>\n      </ul>\n    </li>\n  </ol>\n\n</blockquote>\n\n<p>The Quast tool outputs assembly metrics as an html file with metrics and graphs. The image below looks exceptionally boring. This is a <strong>good</strong> thing:</p>\n\n<figure id=\"figure-9\" style=\"max-width: 90%;\"><img src=\"../../images/quast_output.png\" alt=\"Quast Interface. \" width=\"948\" height=\"1177\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/quast_output.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 9</strong>:</span> Quast Output: Quast provides different statistics such as the number of contigs or scaffolds, the N50 and N75, and the total length of the assembly. You can also access 3 plots, the cumulative length of the contigs, the Nx, or the GC content.</figcaption></figure>\n\n<p>One can see that there are two (!) contigs. The largest contig is 4,576,290 bp (for comparison <em>E. coli</em> K12 MG1655 strain genome length is <a href=\"https://www.ncbi.nlm.nih.gov/nuccore/NZ_APIN00000000.1\">4,656,144 bp</a>) and the smallest is 4,581,676 (total length) - 4,576,290 (length of the largest) = 5,386 bp. When we analyzed this dataset for the first time we were initially puzzled by this second contig. But we quickly realized that this is simply the genome of bacteriophage <a href=\"https://www.ncbi.nlm.nih.gov/nuccore/NC_001422.1\">phiX174</a> which is routinely used as a spike-in in Illumina sequencing. Thus we have two genomes: the one of <em>E.coli</em> C-1 and phiX174! We can now use Prokka to annotate our two genomes.</p>\n\n<h2 id=\"annotation-with-prokka\">Annotation with Prokka</h2>\n\n<blockquote class=\"hands_on\">\n  <hands-on-title>Annotation</hands-on-title>\n\n  <ol>\n    <li><strong>Prokka</strong> <i class=\"fas fa-wrench\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">tool</span>:\n      <ul>\n        <li><em>“Contigs to annotate”</em>: Select the assembly ouput of <code class=\"language-plaintext highlighter-rouge\">Unicycler</code></li>\n        <li><em>“Genus name”</em>: <code class=\"language-plaintext highlighter-rouge\">Escherichia</code></li>\n        <li><em>“Species name”</em>: <code class=\"language-plaintext highlighter-rouge\">coli</code></li>\n        <li><em>“Strain name”</em>: <code class=\"language-plaintext highlighter-rouge\">C-1</code></li>\n        <li><em>“Use genus-specific BLAST database”</em>: <code class=\"language-plaintext highlighter-rouge\">yes</code></li>\n      </ul>\n    </li>\n  </ol>\n\n</blockquote>\n\n<p>Prokka outputs 10 datasets (including two log files). These are in various formats:</p>\n\n<ul>\n  <li><strong>txt</strong> : Provides Statistics on the annotation : number of CDS predicted, number of rRNA etc.</li>\n  <li><strong>tbl</strong> : Provides a tabulated list of annotated features.</li>\n  <li><strong>fsa</strong> : Nucleotide fasta file of the input contig sequence.</li>\n  <li><strong>sqn</strong> : <a href=\"https://www.ncbi.nlm.nih.gov/Structure/asn1.html\">ASN.1</a> format file for submission to GenBank.</li>\n  <li><strong>ffn</strong> : Nucleotide FASTA file of all the prediction transcripts.</li>\n  <li><strong>faa</strong> : Protein FASTA file of the translated CDS sequences.</li>\n  <li><strong>fna</strong> : Nucleotide fasta file of the input contig sequence.</li>\n  <li><strong>gbk</strong> : <a href=\"https://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html\">GenBank</a> file.</li>\n  <li><strong>gff</strong> : <a href=\"http://gmod.org/wiki/GFF3\">gff3</a> file.</li>\n</ul>\n\n<h2 id=\"visualize-the-results-in-igv\">Visualize the results in IGV</h2>\n\n<p>Let’s look at the entire assembly and its annotation in the genome browser. We can do this using Integrated Genome Browser (<a href=\"http://software.broadinstitute.org/software/igv/\">IGV</a>).</p>\n\n<p>Visualization requires a local installation of IGV. If you have IGV installed - just start it. If you don’t - read on.</p>\n\n<h3 id=\"starting-igv\">Starting IGV</h3>\n\n<p>Go to IGV <a href=\"http://software.broadinstitute.org/software/igv/download\">download page</a> and select one of the options. The one I would try first would be <strong>Java Web Start</strong>. Simply click the <strong>Launch</strong> button for 10 GB distribution.</p>\n\n<blockquote class=\"hands_on\">\n  <hands-on-title>Visualization in IGV</hands-on-title>\n\n  <ol>\n    <li>\n      <p>Start IGV. It will look something like this:</p>\n\n      <figure id=\"figure-10\" style=\"max-width: 90%;\"><img src=\"../../images/igv1.png\" alt=\"IGV just started. \" width=\"901\" height=\"556\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/igv1.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 10</strong>:</span> IGV started by using Java Web Start. Note that it is currently showing Human Genome (hg38) build. This is obviously <b>not</b> what we want.</figcaption></figure>\n    </li>\n    <li>\n      <p>Locate the output of Unicycler and expand it :</p>\n\n      <figure id=\"figure-11\" style=\"max-width: 90%;\"><img src=\"../../images/unicycler_igv.png\" alt=\"Unicycler result Visualization. \" width=\"419\" height=\"607\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/unicycler_igv.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 11</strong>:</span> Expanding Unicycler assembly reveals IGV link.</figcaption></figure>\n    </li>\n    <li>\n      <p>Click on the <em>local</em> link highlighted with orange outline. The browser will change:</p>\n\n      <figure id=\"figure-12\" style=\"max-width: 90%;\"><img src=\"../../images/igv2.png\" alt=\"IGV with Unicycler assembly. \" width=\"901\" height=\"557\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/igv2.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 12</strong>:</span> Now you can see the major contig shown in the browser window.</figcaption></figure>\n    </li>\n    <li>\n      <p>Let’s add Prokka annotations to the browser image. For this simply expand Prokka’s GFF3 dataset and click on the <em>local</em> link:</p>\n\n      <figure id=\"figure-13\" style=\"max-width: 90%;\"><img src=\"../../images/prokka_item.png\" alt=\"Expanded GFF3 dataset representing Prokka annotations. \" width=\"356\" height=\"549\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/prokka_item.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 13</strong>:</span> Expanded GFF dataset generated with Prokka. Click on the <em>local</em> link (highlighted with orange outline) to display this dataset within IGV.</figcaption></figure>\n    </li>\n  </ol>\n\n</blockquote>\n\n<p>You will now see the annotations within the browser window:</p>\n\n<figure id=\"figure-14\" style=\"max-width: 90%;\"><img src=\"../../images/igv3.png\" alt=\"Prokka result Visualization. \" width=\"902\" height=\"557\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/igv3.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 14</strong>:</span> Viewing annotated assembly withing IGV.</figcaption></figure>\n"],"ref_slides":["# Small Genome Assembly With Unicycler\n\n---\n.enlarge120[\n\n# **Introduction to Genome Assembly**\n\n]\n\n\n\nTo start on Genome assembly you can read the previous assembly tutorials:\n* [Introduction to Genome Assembly](/training-material/topics/assembly/tutorials/general-introduction/slides.html)\n* [De Bruijn Graph Assembly](/training-material/topics/assembly/tutorials/debruijn-graph-assembly/slides.html#46)\n\n---\n\n.enlarge120[\n\n# **Assembly basics : Challenges of genome (and transcriptome) assembly**\n\n]\n\n[![Graphic shown three different assemblies, all tangled knots of sequences that will be very difficult to resolve.](../../images/illumina_graph_comparison.png)](https://github.com/rrwick/Unicycler)\n\nGenome assembly is a difficult task. In trying to explain it we will be relying on two highly regarded sources:\n\n- [Ben Langmead's Teaching Materials](http://www.langmead-lab.org/teaching-materials/)\n- [Pevzner and Compeau Bioinformatics Book](https://www.goodreads.com/book/show/22033056-bioinformatics-algorithms).\n\n\n---\n\n.enlarge120[\n\n# **Genomes and reads: Strings and *k*-mers**\n\n]\n\n\n## *k*-mer composition\n\nGenomes are strings of text. When we sequence genomes we use sequencing machines that generate reads. For now let's assume that all reads have the same length *k* and every *k*-mer is sequenced only once. We will relax these assumptions later in this lecture. Thus sequencing a genome generates a large list of *k*-mers.\n\nSuppose we are dealing with a *very* short genome `TATGGGGTGC`. Its *k*-mer composition (note the subscript) **Composition_k(Text)** is the collection of all *k*-mer substrings (including repeated ones). When *k* = 3 we get (basically we split sequence into windows of length 3 sliding window by 1 base every time):\n\n<samp>\nComposition_3(TATGGGGTGC)= ATG,GGG,GGG,GGT,GTG,TAT,TGC,TGG\n<samp>\n\n\n---\n\n\n<samp>\nComposition_3(TATGGGGTGC)= ATG,GGG,GGG,GGT,GTG,TAT,TGC,TGG\n<samp>\n\nNote that we have listed *k*-mers in lexicographic order (i.e., how they would appear in a dictionary) rather than in the order of their appearance in <code>TATGGGGTGC</code>. We have done this because the correct ordering of the reads is unknown when they are generated (i.e., a sequencing machine does not generate reads in any particular order).\n\n\n---\n\n## Assembly by overlap\n\nIn the example above we know what the \"genome\" sequence is. In real life we don't know that and our goal is to determine genome sequence given a scrambled collection of *k*-mers. Let's consider the following collection of 3-mers representing a hypothetical genome:\n\n<code> AAT ATG GTT TAA TGT </code>\n\nLet's \"tile\" k-mers if they overlap in k-1 nucleotides:\n\n```\nTAA\n AAT\n  ATG\n   TGT\n    GTT\n-------\nTAATGTT\n```\n\n---\n\nNow let's apply it to slightly longer \"genome\" with the following 3-mer composition sorted in a lexicographic order:\n\n<code>\nAAT ATG ATG ATG CAT CCA GAT GCC GGA GGG GTT TAA TGC TGG TGT\n</code>\n\n`TAA` looks like a great beginning and we are continuing:\n```\n1 TAA\n2  AAT\n3   ATG\n4    TGT\n5     GTT\n  -------\n  TAATGTT\n```\n\nThere is nothing in the original 3-mer composition, which starts with `TT`.\n\n---\n\nLet's track back and instead of `TGT` in step 4 insert `TGC`:\n\n```\n 1 TAA\n 2  AAT\n 3   ATG\n 4    TGC\n 5     GCC\n 6      CCA\n 7       CAT\n 8        ATG\n 9         TGG\n10          GGA\n11           GAT\n12            ATG\n13             TGT\n14              GTT\n   ----------------\n   TAATGCCATGGATGTT\n```\n\nWe only used 14 3-mers from the total of 15, so our genome is shorter (we have extra parts!). This difficulty is related to the fact that there are three repeated `ATG` motifs in this genome and as a result each `ATG` can be extended by either `TGG`, `TGC`, or `TGT`.\n\n---\n\n## The concept of coverage\n\n*Coverage* is the number of reads covering a particular position in the genome. For example, in the following case:\n\n```\nTAA\n AAT\n  ATG     <- \"reads\" (15 bases total)\n   TGT\n    GTT\n-------\nTAATGTT   <- \"genome\" (7 bases)\n-------\n0123456\n```\nThe *Coverage* at positions 1 and 6 is *1*, at positions 1 and 5 is *2*, and at position 2, 3, and 4 is *3*. <br>The *Average Coverage* will be 15/7 ~ 2x\n\n\n---\n\nBelow is another, slightly more realistic example where average coverage is 177/35 ~ 7x:\n\n```\n                  CTAGGCCCTCAATTTTT\n                CTCTAGGCCCTCAATTTTT\n              GGCTCTAGGCCCTCATTTTTT\n           CTCGGCTCTAGCCCCTCATTTT\n        TATCTCGACTCTAGGCCCTCA         <- 177 bases\n        TATCTCGACTCTAGGCC\n    TCTATATCTCGGCTCTAGG\nGGCGTCTATATCTCG\nGGCGTCGATATCT\nGGCGTCTATATCT\n-----------------------------------\nGGCGTCTATATCTCGGCTCTAGGCCCTCATTTTTT   <- 35 bases\n-----------------------------------\n|         |         |         |   |\n0         10        20        30  34\n```\n\n---\n\n# The First and the Second laws of assembly\n\nThe goal of assembly process is to reconstruct an unknown genome sequence given a collection of scrambled sequencing reads:\n\n```\nCTAGGCCCTCAATTTTT\nCTCTAGGCCCTCAATTTTT\nGGCTCTAGGCCCTCATTTTTT\nCTCGGCTCTAGCCCCTCATTTT\nTATCTCGACTCTAGGCCCTCA                 <- Reads (Given)\nTATCTCGACTCTAGGCC\nTCTATATCTCGGCTCTAGG\nGGCGTCTATATCTCG\nGGCGTCGATATCT\nGGCGTCTATATCT\n-----------------------------------\n???????????????????????????????????   <- Genome (Unknown)\n```\n>    **The goal of assembly process**. Given sequencing reads reconstruct underlying genome sequence.\n\n We've seen that this can (in principle) be accomplished by finding overlaps. We also discussed the concept of the coverage.  We can now formulate the two first assembly laws.\n\n---\n\n## The First Assembly Law: Overlaps imply co-location\n\nLet's define terms **Prefix** and **Suffix** using string <code>TAA</code> as an example:\n\n * <code>Prefix(TAA) = TA</code>\n * <code>Suffix(TAA) = AA</code>\n\n---\n\nThe First law states that if a *suffix* of one read is similar to a *prefix* of another read...\n\n```\nTCTATATCTCGGCTCTAGG    <- read 1\n    ||||||| |||||||\n    TATCTCGACTCTAGGCC  <- read 2\n```\n\n...then they may overlap (may be derived from the same location) within the genome.\n\n```\n      TCTATATCTCGGCTCTAGG                  <- read 1\n -------------------------------------\n AGCGTTCTATATCTCGGCTCTAGGCCGTGCAGGACGT     <- genome\n -------------------------------------\n          TATCTCGACTCTAGGCC                <- read 2\n```\n\n---\n\nNote that in the above example suffix of the first read is *not* exactly identical to the prefix of the second read: they differ by a G-to-A substitution. Such differences are quite common in real life and may be caused by:\n\n* **sequencing errors** - experimental or computational artifacts of DNA sequencing procedures.\n* **allelic differences** - organisms such as human are diploid (and others, such as wheat are hexaploid) which maternal and paternal genomes being different at a number of genomic sites.\n* **polymorphic sites** - DNA that is being sequenced is usually isolated from a large number of cells (e.g., white blood cells) or individuals (bacterial and viral cultures). Natural variation present in these cell (or viral particle) populations will manifest itself as these differences.\n\n---\n\n## The Second Assembly Law: The higher the coverage, the better\n\nThe Second law states that higher coverage leads to more frequent and longer overlaps:\n\n```\n                   CTAGGCCCTCAATTTTT\n         TATCTCGACTCTAGGCCCTCA         <- Low coverage\n GGCGTCTATATCT\n -----------------------------------\n GGCGTCTATATCTCGGCTCTAGGCCCTCATTTTTT   <- Genome\n -----------------------------------\n                   CTAGGCCCTCAATTTTT\n                 CTCTAGGCCCTCAATTTTT\n               GGCTCTAGGCCCTCATTTTTT\n            CTCGGCTCTAGCCCCTCATTTT\n         TATCTCGACTCTAGGCCCTCA         <- Higher coverage\n         TATCTCGACTCTAGGCC\n     TCTATATCTCGGCTCTAGG\n GGCGTCTATATCTCG\n GGCGTCGATATCT\n GGCGTCTATATCT\n```\n\n---\n\n# Solving assembly problem with graphs\n\nWe can solve assembly challenge using overlaps between sequencing reads. However, to solve this problem effectively we need to first represent all overlaps in a way that would facilitate further analysis. *Directed graphs* help achieving this.\n\n---\n\n## Directed graphs\n\nFinding overlaps is identical to building a *directed graph* where directed *edges* connect *nodes* representing overlapping reads:\n![Cartoons of two sequences aligned with nearly perfect matches. On the right are a list of nodes representing sequences. The two from the alignment are linked with an arrow and the text reads Suffix of source is similar to prefix of sink.](../../images/dag.png)\n\n>**Directed graph** representing overlapping reads. (Image from [Ben Langmead](http://www.cs.jhu.edu/~langmea/resources/lecture_notes/assembly_scs.pdf)).\n\n---\n\nFor example, the string reconstruction we have seen earlier (with the difference of inserting `GGG` in line 10):\n\n```\n 1 TAA\n 2  AAT\n 3   ATG\n 4    TGC\n 5     GCC\n 6      CCA\n 7       CAT\n 8        ATG\n 9         TGG\n10          GGG\n11           GGA\n12            GAT\n13             ATG\n14              TGT\n15               GTT\n   -----------------\n   TAATGCCATGGGATGTT\n```\n\ncan be represented as a following directed graph (or genome path):\n\n![Graph where each of the above 3-mers is a single node in a graph and they are linked together from left to right most 3-mer.](../../images/4.6.png)\n\n**Genome path**. Trimers composing the <code>TAATGCCATGGGATGTT</code> sequence represented as the \"genome\" path. (Fig. 4.6 from [CP](http://bioinformaticsalgorithms.com/)). In this path a suffix of a 3-mer is equal to prefix of the next 3-mer.\n\n---\n\n\n\n**However**, we do not know the actual genome! All we have in real life is a collection of reads. Let's first build an overlap graph by connecting two 3-mers if suffix of one is equal to the prefix of the other:\n\n\n>![Th above graph is expanded to include a lot more connections between any nodes that share 2 base overlap.](../../images/4.7.png)\n>\n>**Overlap graph**. All possible overlap connections for our 3-mer collection. (Fig. 4.7 from [CP](http://bioinformaticsalgorithms.com/))\n\nSo to determine the sequence of the underlying genome we are looking a path in this graph that visits every node (3-mer) once. Such path is called [Hamiltonian path](https://en.wikipedia.org/wiki/Hamiltonian_path) and it may not be unique.\n\n---\n\nFor example for our 3-mer collection there are two possible Hamiltonian paths:\n\n![The above graph is re-used but a single path is highlighted](../../images/4.9a.png)\n![The same graph with a different path highlighted.](../../images/4.9b.png)\n\n**Two Hamiltonian paths for the 15 3-mers**. Edges spelling \"genomes\" <code>TAATGCCATGGGATGTT</code> and <code>TAATGGGATGCCATGTT</code> are highlighted in black. (Fig. 4.9. from [[CP](http://bioinformaticsalgorithms.com/)](http://bioinformaticsalgorithms.com/)).\n\n---\n\nThe reason for this \"duality\" is the fact that we have a *repeat*: 3-mer <code>ATG</code> is present three times in our data (<font color=\"green\">green</font>, <font color=\"red\">red</font>, and <font color=\"blue\">blue</font>). As we will see later repeats cause a lot of trouble in genome assembly.\n\n---\n\n## Finding overlaps\n\nIn the example above we had a collection of 3-mers and were always looking for overlaps of length two. In real life things may not be so \"regular\". Suppose we have two reads:\n\n```\nRead X CTCTAGGCC\nRead Y TAGGCCCTC\n```\nWhat is the overlap between these two reads? For now we will define overlap of <code>length - l</code> suffix of Read X matches <code>length - l</code> prefix of Read Y, where <code>l</code> is given. To find these overlap we look in Read Y for instances <code>length - l</code> suffix of Read X.\n\n---\n\nWe will start with some minimal match of length $k$. Once a match is found it will be extended to the left to verify that the entire prefix of Read Y matches:\n\n>![Two sequences are shown X and Y. The X sequence ends with the string GCC. In Y they start looking from the end until they find a GCC. In this case we confirm a length-6 prefix of Y matches a suffix of X.](../../images/find_overlap.png)\n>\n>**Finding overlaps** between Read X and Read Y (Image from [Ben Langmead](http://www.cs.jhu.edu/~langmea/resources/lecture_notes/assembly_scs.pdf)).\n\n---\n\nAs a result we represent two reads are connected nodes:\n>\n>![Node labelled with one sequence points to another. The sequences are the ones from above with the number 6 on the arrow between them.](../../images/og1.png)\n>\n>Number above the edge shows the length of the overlap.\n\nWhile with just two reads the problem may seen quite straightforward. Let now consider a set of reads representing a very short genome <code>GTACGTACGAT</code>:\n\n```\nGTACGT\nTACGTA\nCGTACG\nACGTAC\nGTACGA\nTACGAT\n```\n\n---\n\nBuilding an overlap graph with overlap of <code>length >= 4</code> will give us the following:\n\n>![The overlap graph now has longer sequences and numbers annotating the length of the overlap](../../images/og2.png)\n>\n>You can see that there is a path through this graph that would spell out the original genome sequence <code>GTACGTACGAT</code> :\n>\n>![The optimal, highest scoring path is represented through this graph](../../images/og3.png)\n>\n>Here we are lucky enough to have all nodes having a single outgoing edge with the highest number (the length of overlap).\n\n---\n\n## The Shortest Common Superstring Problem\n\nThe problem of reconstructing genome using the overlap graph that we have just illustrated can be initially formulated as the *Shortest Common Superstring (SCS)* problem. It states: *given a collection of strings S, find SCS(S), which is the shortest string that contains all strings from the set S as substrings*.\n\nFor simplicity let's suppose that we have the following set of strings <code>S</code>:\n\n<samp>\nBAA AAB BBA ABA ABB BBB AAA BAB\n</samp>\n\nOne way of getting a string that would contain all of these as substrings will simply be concatenating them:\n\n<samp>\nConcat(S): BAAAABBBAABAABBBBBAAABAB (length = 24)\n</samp>\n\n\nThis, however, is not the *shortest* superstring that contains all strings from $S$. Instead the SCS is (just trust us here):\n\n<samp>\nSCS(S):: AAABBBABAA (length = 10)\n</samp>\n\n\n\n---\n\nIt looks like finding SCS for a set of sequencing reads may just be what we need to produce a genome assembly. But how can this work in practice? One potential idea is to order the strings in some way and \"reduce\" them into a superstring (following examples are from Ben Langmead):\n\n>![A sequence of As and Bs in groups of 3s is labelled order 1. Below the sequence is written AAA, the current superstring.](../../images/scs1.png)\n\n>Let's look at the first two strings. They can be \"reduced\" to `AAAB`:\n>\n>![Now AAAB is written below the sequence because of the overlap in the first two groups.](../../images/scs2.png)\n>\n>The next two add an `A`:\n>\n>![Now AAABA is written, due to overlap in the second and third groups](../../images/scs3.png)\n>\n>Third and fourth add `BB`:\n>\n>![The extension process continues with another overlapping component extending it further.](../../images/scs4.png)\n\n---\n\n>Continuing this we will eventually get `AAABABBAABABBABB`:\n>\n>![Order 1 produces a longish superstring](../../images/scs5.png)\n>\n>But `AAABABBAABABBABB` is the shortest only for this particular ordering. So let's reorder and try again:\n>\n>![Order 2, a new ordering of the same sequences, produces a shorter superstring.](../../images/scs6.png)\n>\n>Now we did better, but maybe we can do even better.\n\nUltimately we need to try all possible ordering and pick the shortest among all. Using this approach is we have <code>S</code> strings we will need to do <code>S!</code> tries. This can quickly get impossible. For our set of\neight strings <code>8! = 40320</code>. If we get, say, a 1,000,000 reads from an Illumina machine then the factorial of a million is not going to be an attractive analysis option.\n\n---\n\n## Shortest common superstring: Greedy approach\n\nAs we've seen it will be impossible to assemble the genome using SCS logic. There is a simplification called *Greedy* approach to SCS problem. Let's take the following set of \"reads\":\n\n<samp>\nAAA AAB ABB BBA BBB\n</samp>\n\nand first build an overlap graph:\n\n>![Graph showing 5 nodes with various scores between them.](../../images/greedy1.png)\n>\n>**An overlap graph** for set <code>S: AAA AAB ABB BBA BBB</code>.\n\n---\n\nNext, we start collapsing the nodes to maximize the overlap (and hence to decrease the length of the SCS we are trying to construct):\n\n>In the graph below there are multiple ties: nodes with outgoing edges of identical weights (e.g., edges pointing from `ABB` to both `BBA` and `BBB` have weight of two. Remember, that the weight is the length of overlap between two nodes' labels). In this situation we will break ties by randomly picking an edge to traverse. Let's pick <font color=\"red\">`AAA` &#8594; `AAB`</font>:\n\n>![The above graph however the node AAA -> 2 -> AAB is highlighted in red.](../../images/greedy2.png)\n\n---\n\n.pull-left[\n>We then merge `AAA` and `AAB` into an SCS containing both, which will be `AAAB`:\n>\n>![The above graph however with 4 nodes, as AAA and AAB are merged](../../images/greedy3.png)\n]\n--\n.pull-right[\n>Now let's pick edge <font color=\"red\">`ABB` &#8594; `BBB`</font>:\n\n>![Another edge scoring 2 is highlighted, ABB to BBB (2)](../../images/greedy4.png)\n]\n---\n\n.pull-left[\n>Collapse the nodes:\n>\n>![They're collapsed, now with 3 nodes in the graph](../../images/greedy5.png)\n]\n--\n.pull-right[\n>Pick <font color=\"red\">`ABBB` &#8594; `BBA`</font>:\n>\n>![Same as before, another highlighted](../../images/greedy6.png)\n]\n---\n.pull-left[\n>Collapse the nodes:\n>\n>![Same as before, down to 2 nodes with arrows going both directions between them. One scores 2, one scores 1.](../../images/greedy7.png)\n]\n--\n.pull-right[\n>Pick <font color=\"red\">`AAAB` &#8594; `ABBBA`</font>:\n>\n>![The AAAB to ABBBA is highlighted, scoring 2.](../../images/greedy8.png)\n]\n---\n\n>Collapse again and now we are left with a superstring of length 7:\n>\n>![A single node is left producing AAABBBA](../../images/greedy9.png)\n\nThe above procedure can be computed *very* quickly. But there is a catch: it does not guarantee that it will give us truly the shortest superstring. It really depends on how we choose edges.\n\n---\n\nBelow is another example of using the same dataset in which we traverse graph in a slightly different way: <br>\n--\n\n.pull-left[\n>We start the same way as before by choosing <font color=\"red\">`AAA` &#8594; `AAB`</font>:\n>\n>![THe graph resets to 5 nodes](../../images/greedy2.png)\n]\n--\n.pull-right[\n>Merge `AAA` and `AAB`:\n>\n>![The same initial step](../../images/greedy3.png)\n]\n\n---\n.pull-left[\n>But now we pick a different edge <font color=\"red\">`ABB` &#8594; `BBA`</font>:\n>\n>![Now a different edge scoring 2 is picked, ABB to BBA](../../images/greedy4_alt.png)\n]\n--\n.pull-right[\n>Collapsing these nodes dramatically changes the graph:\n>\n>![these are collapsed producing a three node graph. AAAB and ABBA have a score of 2, BBB is only connected to AAAB with a score of 1.](../../images/greedy5_alt.png)\n]\n\n---\n.pull-left[\n>Now we pick <font color=\"red\">`AAAB` &#8594; `ABBA`</font> as this is the edge with the highest weight:\n>\n>![The highest scoring edge is picked](../../images/greedy6_alt.png)\n]\n--\n.pull-right[\n>Collapsing it produces two nodes that are not connected to each other:\n>\n>![AAABBA and BBB are left, unconnected.](../../images/greedy7_alt.png)\n]\n---\n\nAnd the SCS of these two will be a concatenation `AAABBABBB` of length 9. Thus a greedy approach may produce different answers. However, it is a sufficient approximation as the superstring yielded this way will not be more than ~2.5 times longer than the true SCS ([Gusfield](https://www.goodreads.com/book/show/145058.Algorithms_on_Strings_Trees_and_Sequences) 16.17.1).\n\n---\n\n# The Third Law of Assembly: Repeats are Evil!\n\nLet's again apply Greedy SCS to a different \"genome\". Suppose we want to reconstruct the phrase:\n\n<samp>\na_long_long_long_time\n</samp>\n\nfrom all 6-mers that overlap by at least 3 characters. The list of 6-mers is:\n\n```\nng_lon      _long_      a_long      long_l      ong_ti      ong_lo      long_t\ng_long      g_time      ng_tim\n```\n\n---\n\nAn overlap graph will look like this:\n\n>![A large, messy graph with various portions fo the above sentence.](../../images/long.png)\n>\n<small>**An overlap graph** for with overlap length <code> >= 3<code>.</small>\n\n---\n\nIf we proceed with Greedy SCS we will follow the following trajectory through the graph:\n\n>![A greedy path is highlighted, all scoring 5.](../../images/long_opt.png)\n\n---\n\nTo make things even clearer let's isolate the path:\n\n![Irrelevant edges are removed.](../../images/long_opt_focus.png)\n\n---\n\nThe total overlap here (the sum of edge weights) is 4+5+5+5+5+5+5+5+5=44 but it gives us `a_long_long_time` as the shortest superstring:\n\n\n```\na_long\n  long_l\n   ong_lo\n    ng_lon\n     g_long\n      _long_\n       long_t\n        ong_ti\n         ng_tim\n          g_time\n----------------\na_long_long_time\n```\n\n---\n\nWe are missing one instance of 'long' in this string. The following graph shows the path that would return the *correct* string:\n\n >![A less optimal path is shown that recovers the duplicated long](../../images/long_corr.png)\n\n---\n\nA path yielding the correct string with three repeats. The total overlap here is 5+3+3+5+4+4+5+5+5=39, which is *worse* than the previous path if our goal is to find the shortest superstring:\n\n```\na_long\n _long_\n    ng_lon\n       long_l\n        ong_lo\n          g_long\n            long_t\n             ong_ti\n              ng_tim\n               g_time\n---------------------\na_long_long_long_time\n```\n\n---\n\n\n## Are we really looking for the shortest superstring?\n\nAs we've seen above the shortest common superstring (SCS) is:\n\n1. **Difficult to obtain** as Greedy SCS algorithm does not guarantee finding it. So the answer we get may be longer than the real genome we are trying to assemble.\n\n2. **May be shorter than we want** because if the genome contains repeats that are longer than the reads we are using, Greedy SCS will collapse them and make assembly shorter that the genome we are trying to get.\n\nLet's talk about an alternative way to represent the relationship between *k*-mers that may give us a more efficient algorithm.\n\n---\n\n# de Bruijn graphs\n\n[Nicolaas de Bruijn](https://en.wikipedia.org/wiki/Nicolaas_Govert_de_Bruijn) had a purely theoretical interest of constructing _k_-universal strings for an arbitrary value of _k_. A _k_-universal string contains every possible _k_-mer only once:\n\n>[![Screenshot of a box from a textbook with illegible text and a similar graph to the ABBA ones shown above.](../../images/deBruijn_txt.png)](http://www.nature.com/nbt/journal/v29/n11/abs/nbt.2023.html)\n>\n>**de Bruijn graph**. From [Compeau:2011](http://www.nature.com/nbt/journal/v29/n11/abs/nbt.2023.html)\n\n---\n\nThis problem is equivalent to a string reconstruction problem we have been talking about above: finding a _k_-universal string is equivalent to finding a Hamiltonian path in an overlap graph constructed from all _k_-mers. Yet finding a Hamiltonian path in a really large graph (representing a real genome) is not a tractable problem as we have seen. Instead de Bruijn decided to represent _k_-mer composition in a graph using a slightly different logic. Again, suppose we have a \"genome\" <ode>TAATGCCATGGGATGTT</code> split in a collection of 3-mers:\n\n<samp>\nTAA AAT ATG TGC GCC CCA CAT ATG TGG GGG GGA GAT ATG TGT GTT\n</samp>\n\n---\n\nWe will assign 3-mers to _edges_ instead of _nodes_:\n\n\n![A long string of 2-mer nodes linked together with 3-mers on edges.](../../images/4.12.png)\n\n**_k_-mers as edges**. Edges represented by 3-mers connect nodes representing the overlaps. (Fig. 4.12 from [CP](http://bioinformaticsalgorithms.com/))\n\nThis graph can be simplified by gluing identical nodes together:\n\n![The same graph](../../images/4.13a.png)\n\n![Re-organised to collapse identical nodes, first the AT node is collapsed from three into one.](../../images/4.13b.png)\n\n---\n\n\nHere the complexity of the graph is reduced by first gluing redundant <font color=\"red\">`AT`</font> nodes\n\n![Now the 3 TG nodes are highlighted](../../images/4.13c.png)\n\n![and collapsed into a single one, sharing the original's connections.](../../images/4.13d.png)\n\n---\n\nNext, <font color=\"blue\">`TG`</font> nodes are merged\n\n![2 GG nodes are highlighted](../../images/4.13e.png)\n\n![and merged, including a self-link.](../../images/4.13f.png)\n\n---\n\nAnd, finally the two <font color=\"green\">`GG`</font> nodes are resolved. (Fig. 4.13 from [CP](http://bioinformaticsalgorithms.com/))\n\nBecause we now represent _k_-mers as edges (rather than nodes), our problem has morphed into finding a path that visits every _edge_ once, or an [Eulerian Path](https://en.wikipedia.org/wiki/Eulerian_path):\n\n![The final graph, same as previous image but now edges are numbered as well.](../../images/4.15.png)\n\n**Eulerian paths for the 15 3-mers**. Numbering of edges provides a way to reconstruct the original \"genome\". (Fig. 4.15 from [CP](http://bioinformaticsalgorithms.com/))\n\n---\n\n## Euler's Theorem\n\nSome definitions:\n\n * **Balanced node** - a node where the number of incoming edges is equal to the number of outgoing edges\n * **Balanced graph** - a graph where all nodes are balanced\n * **Strongly connected graph** - any node can be reached from any other node\n\n\n**Euler's Theorem**:\n\n>Every balanced, strongly connected directed graph is Eulerian.\n\n---\n\nLet's apply Euler's Theorem to a classical problem: The bridges of Königsberg problem. Here the question is: *Can you walk through all of Königsberg traversing every bridge exactly one time?* In other words: *Is there a Eulerian path through the city of Königsberg?*\n\n\n>![Old map of Königsberg with dots on land portions and links between them. This is reduced into the same coloured nodes and bridges representing edges.](../../images/koninsberg.png)\n>\n>**Königsberg and Euler's Theorem**. (a) A map of old Königsberg, in which each area of the city is labeled with a different color point. (b) The Königsberg Bridge graph, formed by representing each of four land areas as a node and each of the city's seven bridges as an edge. (From [Campeau:2011](http://www.nature.com/nbt/journal/v29/n11/abs/nbt.2023.html#close))\n\nBy looking at this graph we can see that it is *unbalanced*. If one arrives to, say, the <font color=\"orange\">orange</font> node from the <font color=\"blue\">blue</font> node there are two ways to get out. Thus there is no way to see all of the city and traverse every bridge once!\n\n---\n\n## Repeats are still a challenge\n\nLet's look at the de Bruijn graph from above again. But this time let's drop edge numbering and pretend that the genome is now really known to us (as is usually the case in real life):\n\n>![Similar graph as above but now edges are only labelled by sequences, no more numbers.](../../images/dg1.png)\n>\n>**Eulerian paths for the 15 3-mers**.\n\n---\n\nIn the original sequence `TAATGCCATGGGATGTT` *k*-mer <font color=\"red\">`AT`</font> is present 3 times and *k*-mer <font color=\"blue\">`TG`</font> is found twice. Thus *multiple* Eulerian walks are now possible like this:\n\n>![Following a direct path from the one node without incoming connections, to TG node, choosing one of the three outgoing connections we go 'up'](../../images/dg2.png)\n>\n>**Possible path #1**. Here after we reach <font color=\"blue\">`TG`</font> node we turn **up**.\n\n---\n\nThe above path spells out:\n\n```\nTAA\n AAT\n  ATG\n   TGC\n    GCC\n     CCA\n      CAT\n       ATG\n        TGG\n         GGG\n          GGA\n           GAT\n            ATG\n             TGT\n              GTT\n-----------------\nTAATGCCATGGGATGTT\n```\n\n---\n\nYet there is an alternative:\n\n>![The same as above but this time going down to follow a different path](../../images/dg3.png)\n>\n>**Possible path #2**. Here after we reach <font color=\"blue\">`TG`</font> node we turn **dow**.\n\n\n---\n\nWhich spells:\n\n```\nTAA\n AAT\n  ATG\n   TGG\n    GGA\n     GAT\n      ATG\n       TGC\n        GCC\n         CCA\n          CAT\n           ATG\n            TGT\n             GTT\n----------------\nTAATGGATGCCATGTT\n```\n\nNote how different these are:\n\n```\nTAATGCCATGGGATGTT\n\nTAATGGATGCCATGTTT\n```\n\nand only one of them is correct. Repeats are evil!\n\n---\n\n## *k*-mer size affects repeat resolution\n\nIn the above example we have used *k*-mer size of 3. But what if we try 4 or 5? Below are De Bruijn graphs for different values of *k*:\n\n#### *k* = 3\n\n>![The same graph as above, now in a different orientation. There are many connections](../../images/k2.png)\n\n---\n\n>This is our original graph\n\n#### *k* = 4\n\n>![There are now significantly fewer connections.](../../images/k3.png)\n>\n>Here complexity is decreasing, but we still have the problem with having `ATG` twice.\n\n---\n\n\n\n\n.pull-left[\n#### *k* = 5\nIn this case there is only one path. This because our *k* is larger that the repeat size, so we can resolve it accurately.\n\nThis is why technologies producing long sequencing reads stimulate so much enthusiasm - they will allow to resolve and produce accurate assembly of large genomes.\n]\n.pull-right[\n![Graph with only a single route through the sequence.](../../images/k4.png)\n]\n\n---\n\n# Assembly in real life\n\nIn this topic we've learned about two ways of representing the relationship between reads derived from a genome we are trying to assemble:\n\n1. **Overlap graphs** - nodes are reads, edges are overlaps between reads.\n2. **De Bruijn graphs** - nodes are overlaps, edges are reads.\n\n>![Overlap: graph from before, nodes are 3-mers, unlabelled connections.](../../images/4.7.png)\n\n---\n\n**A**.\n\n![De Bruijn: The 2-mer graph with 3-mer connections again.](../../images/4.13f.png)\n\n---\n\n**B.**\nAn overlap (A) and De Bruijn (B) graphs for the same string.\n\nWhatever the representation will be it will be messy:\n\n![A hypothetical real life graph with a huge number of nodes snaking all over the screen, and many many isolaed single and pairs of nodes unconnected to anything.](../../images/t12_mess.png)\n\nA fragment of a very large De Bruijn graph (Image from [BL](https://github.com/BenLangmead/ads1-slides/blob/master/0580_asm__practice.pdf)).\n\n---\n\n\nThere are multiple reasons for such messiness:\n\n**Sequence errors**\n\nSequencing machines do not give perfect data. This results in spurious deviations on the graph. Some sequencing technologies such as Oxford Nanopore have very high error rate of ~15%.\n\n>![An inset from the above. A red box highlights pairs of 2 and 3 node groups.](../../images/t12_errors.png)\n>\n>Graph components resulting from sequencing errors (Image from [BL](https://github.com/BenLangmead/ads1-slides/blob/master/0580_asm__practice.pdf)).\n\n---\n\n**Ploidy**\n\nAs we discussed earlier humans are diploid and there are multiple differences between maternal and paternal genomes. This creates \"bubbles\" on assembly graphs:\n\n>![A bubble in the graph. there are a series of nodes which have 5-8 connections pointing from one to the next. Halfway through there is a single base deviation and the 5-mer nodes highlight this single base change. The change results in a split into two strands which shortly reconnect. One strand is labelled Maternal, the other Paternal.](../../images/t12_bubble.png)\n>\n>Bubbles due to a heterozygous site  (Image from [BL](https://github.com/BenLangmead/ads1-slides/blob/master/0580_asm__practice.pdf)).\n\n---\n\n**Repeats**\n\nAs we've seen the third law of assembly is unbeatable. As a result some regions of the genome simply cannot be resolved and are reported in segments called *contigs*:\n\n>![A sentence is represented \"to everything turn\", \"turn\" (a repeat) and \"turn there is a season\". The repeat makes the graph hard to solve into a single path.](../../images/t12_contigs.png)\n>\n>The following \"genomic\" segment will be reported in three pieces corresponding to regions flanking the repeat and repeat itself (Image from [BL](https://github.com/BenLangmead/ads1-slides/blob/master/0580_asm__practice.pdf)).\n\n---\n\n\n.enlarge120[\n\n# **How to perform Assembly with Galaxy?**\n\n]\n\n---\n\nSee the tutorial accompanied by these slides!\n"],"hands_on":true,"slides":true,"mod_date":"2024-03-11 16:03:04 +0000","pub_date":"2017-10-11 15:24:22 +0000","version":61,"workflows":[{"workflow":"unicycler.ga","tests":true,"url":"https://training.galaxyproject.org/training-material/topics/assembly/tutorials/unicycler-assembly/workflows/unicycler.ga","path":"topics/assembly/tutorials/unicycler-assembly/workflows/unicycler.ga","wfid":"assembly-unicycler-assembly","wfname":"unicycler","trs_endpoint":"https://training.galaxyproject.org/training-material/api/ga4gh/trs/v2/tools/assembly-unicycler-assembly/versions/unicycler","license":null,"creators":[],"name":"Unicycler training","title":"Unicycler training","test_results":null,"modified":"2024-06-24 07:46:38 +0000","mermaid":"flowchart TD\n  0[\"ℹ️ Input Dataset\\nForward reads\"];\n  style 0 stroke:#2c3143,stroke-width:4px;\n  1[\"ℹ️ Input Dataset\\nReverse Reads\"];\n  style 1 stroke:#2c3143,stroke-width:4px;\n  2[\"ℹ️ Input Dataset\\nLong Reads\"];\n  style 2 stroke:#2c3143,stroke-width:4px;\n  3[\"FastQC\"];\n  0 -->|output| 3;\n  4[\"FastQC\"];\n  1 -->|output| 4;\n  5[\"Create assemblies with Unicycler\"];\n  2 -->|output| 5;\n  0 -->|output| 5;\n  1 -->|output| 5;\n  6[\"MultiQC\"];\n  3 -->|text_file| 6;\n  4 -->|text_file| 6;\n  7[\"Quast\"];\n  5 -->|assembly| 7;\n  8[\"Prokka\"];\n  5 -->|assembly| 8;\n  0d6b33c9-b105-4997-9045-b86e52f00156[\"Output\\ntbl\"];\n  8 --> 0d6b33c9-b105-4997-9045-b86e52f00156;\n  style 0d6b33c9-b105-4997-9045-b86e52f00156 stroke:#2c3143,stroke-width:4px;\n  8e08b54d-87e1-4269-9b96-8ebf1a9bb4ab[\"Output\\ngbk\"];\n  8 --> 8e08b54d-87e1-4269-9b96-8ebf1a9bb4ab;\n  style 8e08b54d-87e1-4269-9b96-8ebf1a9bb4ab stroke:#2c3143,stroke-width:4px;\n  65e4ddf9-f5bc-4078-8b4e-37b332e12ece[\"Output\\nffn\"];\n  8 --> 65e4ddf9-f5bc-4078-8b4e-37b332e12ece;\n  style 65e4ddf9-f5bc-4078-8b4e-37b332e12ece stroke:#2c3143,stroke-width:4px;"}],"api":"https://training.galaxyproject.org/training-material/api/topics/assembly/tutorials/unicycler-assembly/tutorial.json","tools":["toolshed.g2.bx.psu.edu/repos/crs4/prokka/prokka/1.14.5","toolshed.g2.bx.psu.edu/repos/devteam/fastqc/fastqc/0.72+galaxy1","toolshed.g2.bx.psu.edu/repos/iuc/multiqc/multiqc/1.7","toolshed.g2.bx.psu.edu/repos/iuc/quast/quast/5.0.2+galaxy0","toolshed.g2.bx.psu.edu/repos/iuc/unicycler/unicycler/0.4.8.0"],"supported_servers":{"exact":[{"url":"https://usegalaxy.eu","name":"UseGalaxy.eu","usegalaxy":true},{"url":"https://usegalaxy.org","name":"UseGalaxy.org (Main)","usegalaxy":true},{"url":"https://usegalaxy.org.au","name":"UseGalaxy.org.au","usegalaxy":true}],"inexact":[{"url":"https://galaxytrakr.org/","name":"GalaxyTrakr","usegalaxy":false},{"url":"https://galaxy.hyphy.org/","name":"HyPhy HIV NGS Tools","usegalaxy":false},{"url":"https://mississippi.sorbonne-universite.fr","name":"MISSISSIPPI","usegalaxy":false},{"url":"https://usegalaxy.cz/","name":"UseGalaxy.cz","usegalaxy":false},{"url":"https://usegalaxy.fr/","name":"UseGalaxy.fr","usegalaxy":false},{"url":"https://usegalaxy.no/","name":"UseGalaxy.no","usegalaxy":false}]},"topic_name_human":"Assembly","admin_install":{"install_tool_dependencies":true,"install_repository_dependencies":true,"install_resolver_dependencies":true,"tools":[{"name":"prokka","owner":"crs4","revisions":"bf68eb663bc3","tool_panel_section_label":"Annotation","tool_shed_url":"https://toolshed.g2.bx.psu.edu/"},{"name":"fastqc","owner":"devteam","revisions":"e7b2202befea","tool_panel_section_label":"FASTA/FASTQ","tool_shed_url":"https://toolshed.g2.bx.psu.edu/"},{"name":"multiqc","owner":"iuc","revisions":"b2f1f75d49c4","tool_panel_section_label":"Quality Control","tool_shed_url":"https://toolshed.g2.bx.psu.edu/"},{"name":"quast","owner":"iuc","revisions":"59db8ea8c845","tool_panel_section_label":"Assembly","tool_shed_url":"https://toolshed.g2.bx.psu.edu/"},{"name":"unicycler","owner":"iuc","revisions":"9e3e80cc4ad4","tool_panel_section_label":"Assembly","tool_shed_url":"https://toolshed.g2.bx.psu.edu/"}]},"admin_install_yaml":"---\ninstall_tool_dependencies: true\ninstall_repository_dependencies: true\ninstall_resolver_dependencies: true\ntools:\n- name: prokka\n  owner: crs4\n  revisions: bf68eb663bc3\n  tool_panel_section_label: Annotation\n  tool_shed_url: https://toolshed.g2.bx.psu.edu/\n- name: fastqc\n  owner: devteam\n  revisions: e7b2202befea\n  tool_panel_section_label: FASTA/FASTQ\n  tool_shed_url: https://toolshed.g2.bx.psu.edu/\n- name: multiqc\n  owner: iuc\n  revisions: b2f1f75d49c4\n  tool_panel_section_label: Quality Control\n  tool_shed_url: https://toolshed.g2.bx.psu.edu/\n- name: quast\n  owner: iuc\n  revisions: 59db8ea8c845\n  tool_panel_section_label: Assembly\n  tool_shed_url: https://toolshed.g2.bx.psu.edu/\n- name: unicycler\n  owner: iuc\n  revisions: 9e3e80cc4ad4\n  tool_panel_section_label: Assembly\n  tool_shed_url: https://toolshed.g2.bx.psu.edu/\n","tours":false,"video":false,"slides_recordings":false,"translations":{"tutorial":[],"slides":[],"video":false},"license":"CC-BY-4.0","type":"tutorial","logo":"GTN","class":"enlarge120","redirect_from":["/short/assembly/unicycler-assembly/slides","/short/S00035"]}
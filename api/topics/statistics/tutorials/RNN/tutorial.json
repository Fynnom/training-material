{"layout":"tutorial_hands_on","title":"Deep Learning (Part 2) - Recurrent neural networks (RNN)","zenodo_link":"https://zenodo.org/record/4477881","questions":["What is a recurrent neural network (RNN)?","What are some applications of RNN?"],"objectives":["Understand the difference between feedforward neural networks (FNN) and RNN","Learn various RNN types and architectures","Learn how to create a neural network using Galaxy's deep learning tools","Solve a sentiment analysis problem on IMDB movie review dataset using RNN in Galaxy"],"requirements":[{"type":"internal","topic_name":"statistics","tutorials":["intro_deep_learning","FNN"]}],"follow_up_training":[{"type":"internal","topic_name":"statistics","tutorials":["CNN"]}],"time_estimation":"2H","contributors":[{"name":"Kaivan Kamali","email":"kxk302@gmail.com","joined":"2021-02","id":"kxk302","url":"https://training.galaxyproject.org/training-material/api/contributors/kxk302.json","page":"https://training.galaxyproject.org/training-material/hall-of-fame/kxk302/"}],"recordings":[{"captioners":["kxk302"],"date":"2021-02-15","galaxy_version":"21.01","length":"50M","youtube_id":"1dwzEhjOAmw","speakers":["kxk302"]}],"js_requirements":{"mathjax":22102,"mermaid":false},"short_id":"T00259","url":"/topics/statistics/tutorials/RNN/tutorial.html","topic_name":"statistics","tutorial_name":"RNN","dir":"topics/statistics/tutorials/RNN","symlink":null,"id":"statistics/RNN","ref_tutorials":["<p>Artificial neural networks are a machine learning discipline roughly inspired by how neurons in a\nhuman brain work. In the past decade, there has been a huge resurgence of neural networks thanks\nto the vast availability of data and enormous increases in computing capacity (successfully\ntraining complex neural networks in some domains requires lots of data and compute capacity). There\nare various types of neural networks (feedforward, recurrent, etc). In this tutorial, we discuss\nrecurrent neural networks (RNN), which model sequential data, and have been successfully applied to language\ngeneration, machine translation, speech recognition, image description, and text summarization\n(<span class=\"citation\"><a href=\"#wen-etal-2015-semantically\">Wen <i>et al.</i> 2015</a></span>, <span class=\"citation\"><a href=\"#cho-etal-2014-learning\">Cho <i>et al.</i> 2014</a></span>, <span class=\"citation\"><a href=\"#LimEtAl\">Lim <i>et al.</i> 2016</a></span>,\n<span class=\"citation\"><a href=\"#karpathyEtAl\">Karpathy and Fei-Fei 2017</a></span>, <span class=\"citation\"><a href=\"#li-etal-2017-deep\">Li <i>et al.</i> 2017</a></span>). We start by explaining how RNN differ from\nfeedforward networks (FNN), describe various RNN architectures, and solve a sentiment analysis problem\nusing RNN in Galaxy.</p>\n\n<blockquote class=\"agenda\">\n  <agenda-title></agenda-title>\n\n  <p>In this tutorial, we will cover:</p>\n\n<ol id=\"markdown-toc\">\n  <li><a href=\"#feedforward-neural-networks-fnn\" id=\"markdown-toc-feedforward-neural-networks-fnn\">Feedforward neural networks (FNN)</a>    <ol>\n      <li><a href=\"#single-layer-fnn\" id=\"markdown-toc-single-layer-fnn\">Single layer FNN</a></li>\n      <li><a href=\"#multi-layer-fnn\" id=\"markdown-toc-multi-layer-fnn\">Multi-layer FNN</a></li>\n      <li><a href=\"#learning-algorithm\" id=\"markdown-toc-learning-algorithm\">Learning algorithm</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#recurrent-neural-networks\" id=\"markdown-toc-recurrent-neural-networks\">Recurrent neural networks</a>    <ol>\n      <li><a href=\"#possible-rnn-inputsoutputs\" id=\"markdown-toc-possible-rnn-inputsoutputs\">Possible RNN inputs/outputs</a></li>\n      <li><a href=\"#rnn-architectures\" id=\"markdown-toc-rnn-architectures\">RNN architectures</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#text-representation-schemes\" id=\"markdown-toc-text-representation-schemes\">Text representation schemes</a>    <ol>\n      <li><a href=\"#text-preprocessing\" id=\"markdown-toc-text-preprocessing\">Text preprocessing</a></li>\n      <li><a href=\"#bag-of-words-and-tf-idf\" id=\"markdown-toc-bag-of-words-and-tf-idf\">Bag of words and TF-IDF</a></li>\n      <li><a href=\"#one-hot-encoding-ohe\" id=\"markdown-toc-one-hot-encoding-ohe\">One hot encoding (OHE)</a></li>\n      <li><a href=\"#word2vec\" id=\"markdown-toc-word2vec\">Word2Vec</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#get-data\" id=\"markdown-toc-get-data\">Get Data</a></li>\n  <li><a href=\"#sentiment-classification-of-imdb-movie-reviews-with-rnn\" id=\"markdown-toc-sentiment-classification-of-imdb-movie-reviews-with-rnn\">Sentiment Classification of IMDB movie reviews with RNN</a>    <ol>\n      <li><a href=\"#create-a-deep-learning-model-architecture\" id=\"markdown-toc-create-a-deep-learning-model-architecture\">Create a deep learning model architecture</a></li>\n      <li><a href=\"#create-a-deep-learning-model\" id=\"markdown-toc-create-a-deep-learning-model\">Create a deep learning model</a></li>\n      <li><a href=\"#deep-learning-training-and-evaluation\" id=\"markdown-toc-deep-learning-training-and-evaluation\">Deep learning training and evaluation</a></li>\n      <li><a href=\"#model-prediction\" id=\"markdown-toc-model-prediction\">Model Prediction</a></li>\n      <li><a href=\"#machine-learning-visualization-extension\" id=\"markdown-toc-machine-learning-visualization-extension\">Machine Learning Visualization Extension</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#conclusion\" id=\"markdown-toc-conclusion\">Conclusion</a></li>\n</ol>\n\n</blockquote>\n\n<h1 id=\"feedforward-neural-networks-fnn\">Feedforward neural networks (FNN)</h1>\n\n<p>In feedforward neural networks (FNN) a single training example is presented to the network,\nafter which the network generates an output. For example, a lung X-ray image is passed\nto a FNN, and the network predicts tumor or no tumor.</p>\n\n<h2 id=\"single-layer-fnn\">Single layer FNN</h2>\n\n<figure id=\"figure-1\" style=\"max-width: 90%;\"><img src=\"../../images/FFNN_no_hidden.png\" alt=\"Neurons forming the input and output layers of a single layer feedforward neural network. \" width=\"233\" height=\"463\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/FFNN_no_hidden.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 1</strong>:</span> Single layer feedforward neural network</figcaption></figure>\n\n<p>Figure 1 shows a single layer FNN, where the input is 3 dimensional. Each input field is multiplied by a\nweight. Afterwards, the results are summed up, along with a bias, and passed to an activation function.</p>\n\n<figure id=\"figure-2\" style=\"max-width: 90%;\"><img src=\"../../images/activation.gif\" alt=\"An activation function (such as Sigmoid, Tanh, etc.) applied to the input of the only neuron in the output layer of a feedforward neural network. \" width=\"147\" height=\"53\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/activation.gif\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 2</strong>:</span> Activation of the output neuron o1. Activation function f could be Sigmoid, Tanh, ReLU, etc.</figcaption></figure>\n\n<p>The activation function can have many forms (sigmoid, tanh, ReLU, linear, step function, sign function, etc.).\nOutput layer neurons usually have <em>sigmoid</em> or <em>tanh</em> functions. For more information on the listed activation\nfunctions, please refer to <span class=\"citation\"><a href=\"#nwankpaEtAl\">Nwankpa <i>et al.</i> 2018</a></span>.</p>\n\n<figure id=\"figure-3\" style=\"max-width: 90%;\"><img src=\"../../images/sigmoid.gif\" alt=\"Mathmatical formula for Sigmoid activation function. \" width=\"231\" height=\"39\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/sigmoid.gif\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 3</strong>:</span> Sigmoid activation function</figcaption></figure>\n\n<h2 id=\"multi-layer-fnn\">Multi-layer FNN</h2>\n\n<p>Minsky and Papert showed that a single layer FNN cannot solve problems in which the data is not linearly separable,\nsuch as the XOR problem (<span class=\"citation\"><a href=\"#Newell780\">Newell 1969</a></span>). Adding one (or more) hidden layers to FNN enables it to solve problems\nin which data is non-linearly separable. Per Universal Approximation Theorem, a FNN with one hidden layer can represent\nany function (<span class=\"citation\"><a href=\"#Cybenko1989\">Cybenko 1989</a></span>), although in practice training such a model is very difficult (if not impossible),\nhence, we usually add multiple hidden layers to solve complex problems.</p>\n\n<figure id=\"figure-4\" style=\"max-width: 90%;\"><img src=\"../../images/FFNN.png\" alt=\"Neurons forming the input, output, and hidden layers of a multi-layer feedforward neural network. \" width=\"361\" height=\"461\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/FFNN.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 4</strong>:</span> Feedforward neural network with a hidden layer. Biases to hidden/output layer neurons are omitted for clarity</figcaption></figure>\n\n<h2 id=\"learning-algorithm\">Learning algorithm</h2>\n\n<p>In supervised learning, we are given a set of input-output pairs, called the <em>training set</em>. Given the training set, the learning algorithm\n(iteratively) adjusts the model parameters, so that the model can accurately map inputs to outputs. We usually have another set of input-output\npairs, called the <em>test set</em>, which is not used by the learning algorithm. When the learning algorithm completes, we assess the learned model by\nproviding the test set inputs to the model and comparing the model outputs to test set outputs. We need to define a <strong>loss function</strong> to objectively\nmeasure how much the model output is off of the expected output. For classification problems we use the <strong>cross entropy</strong> loss function.</p>\n\n<figure id=\"figure-5\" style=\"max-width: 90%;\"><img src=\"../../images/CrossEntropy.gif\" alt=\"Mathematical formula for calculating the cross entropy loss function, which quantifies the difference between the predicted and desired output of a neural network. \" width=\"241\" height=\"51\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/CrossEntropy.gif\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 5</strong>:</span> Cross entropy loss function</figcaption></figure>\n\n<p>The loss function is calculated for each input-output pair in the training set. The average of the calculated loss functions for all training\nset input-output pairs is called the <strong>Cost function</strong>. The goal of the learning algorithm is to minimize the cost function. The cost function\nis a function of network weights and biases of all neurons in all layers. The <strong>backpropagation</strong> learning algorithm <span class=\"citation\"><a href=\"#Rumelhart1986\">Rumelhart <i>et al.</i> 1986</a></span>\niteratively computes the gradient of cost function relative to each weight and bias, then updates the weights and biases in the opposite\ndirection of the gradient, to find the local minimum.</p>\n\n<figure id=\"figure-6\" style=\"max-width: 90%;\"><img src=\"../../images/CostFunction.gif\" alt=\"Mathematical formula for calcuating the cross entropy cost function, which is just the average of cross entropy loss functions for training samples. \" width=\"270\" height=\"54\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/CostFunction.gif\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 6</strong>:</span> Cross entropy cost function</figcaption></figure>\n\n<h1 id=\"recurrent-neural-networks\">Recurrent neural networks</h1>\n\n<p>Unlike FNN, in RNN the output of the network at time <em>t</em> is used as network input\nat time <em>t+1</em>. In RNN, a training example is a sequence, which is presented to the\nnetwork one at a time. For example, a sequence of English words is passed to a\nRNN, one at a time, and the network generates a sequence of Persian words, one\nat a time. RNN handle sequential data, whether its temporal or ordinal.</p>\n\n<h2 id=\"possible-rnn-inputsoutputs\">Possible RNN inputs/outputs</h2>\n\n<p>There are 4 possible input/output combinations for RNN and each have a specific application. <em>One-to-one</em> is basically a FNN. <em>One-to-many</em> is\nwhere we have one input and a variable number of outputs. One example application is image captioning, where a single image is provided\nas input and a variable number of words (which caption the image) is returned as output (see Figure 7).</p>\n\n<figure id=\"figure-7\" style=\"max-width: 90%;\"><img src=\"../../images/RNN_1_to_n.png\" alt=\"Neurons forming a one-to-many recurrent neural network. \" width=\"596\" height=\"644\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/RNN_1_to_n.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 7</strong>:</span> One-to-many RNN</figcaption></figure>\n\n<p><em>Many-to-one</em> RNN combination has a variable number of inputs and a single output. One example application is document sentiment\nclassification, where a variable number of words in a document are presented as input, and a single output predicts whether the document\nhas a positive or negative sentiment regarding a topic (see Figure 8).</p>\n\n<figure id=\"figure-8\" style=\"max-width: 90%;\"><img src=\"../../images/RNN_n_to_1.png\" alt=\"Neurons forming a many-to-one recurrent neural network. \" width=\"560\" height=\"475\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/RNN_n_to_1.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 8</strong>:</span> Many-to-one RNN</figcaption></figure>\n\n<p>Finally there is many-to-many RNN, which have two types: one in which the number of inputs and outputs match, e.g., in labeling the video frames the number\nof frames matches the number of labels, and the other in which the number of inputs and outputs do not match, e.g., in language translation\nwe pass in <em>n</em> words in English and get <em>m</em> words in Italian (see Figure 9).</p>\n\n<figure id=\"figure-9\" style=\"max-width: 90%;\"><img src=\"../../images/RNN_n_to_m.png\" alt=\"Neurons forming a many-to-many recurrent neural network. \" width=\"560\" height=\"475\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/RNN_n_to_m.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 9</strong>:</span> Many-to-many RNN</figcaption></figure>\n\n<h2 id=\"rnn-architectures\">RNN architectures</h2>\n\n<p>Mainly, there are three types of RNN: 1) Vanilla RNN, 2) LSTM (<span class=\"citation\"><a href=\"#hochreiter1997long\">Hochreiter and Schmidhuber 1997</a></span>), and 3) GRU (<span class=\"citation\"><a href=\"#cho-etal-2014-learning\">Cho <i>et al.</i> 2014</a></span>).\nA Vanilla RNN, simply combines the state information from the previous timestamp with the input from the current timestamp to generate the\nstate information and output for current timestamp. A problem with Vanilla RNN is that training deep RNN networks is impossible due to the\n<strong>vanishing gradient</strong> problem. Basically, weights/biases are updated according to the gradient of the loss functions relative to\nthe weights/biases. The gradients are calculated recursively from the output layer towards the input layer (hence, the name <em>backpropagation</em>).\nThe gradient of the input layer is the product of the gradient of the subsequent layers. If those gradients are small, the gradient of the input\nlayer (which is the product of multiple small values) will very small, resulting in very small updates to weights/biases of the initial layers\nof the RNN, effectively halting the learning process.</p>\n\n<p>LSTM and GRU are two RNN architectures that address vanishing gradient problem. Full description of LSTM/GRU is beyond the scope of this\ntutorial (please refer to <span class=\"citation\"><a href=\"#hochreiter1997long\">Hochreiter and Schmidhuber 1997</a></span> and <span class=\"citation\"><a href=\"#cho-etal-2014-learning\">Cho <i>et al.</i> 2014</a></span>), but in a nutshell both LSTM and GRU use <strong>gates</strong> such that the weights/biases updates in previous\nlayers are calculated via a series of additions (not multiplications). Hence, these architectures can learn even when the RNN has hundreds or\nthousands of layers.</p>\n\n<h1 id=\"text-representation-schemes\">Text representation schemes</h1>\n\n<p>In this tutorial we perform sentiment analysis on IMDB (https://www.imdb.com/) movie reviews dataset (<span class=\"citation\"><a href=\"#maas-EtAl\">Maas <i>et al.</i> 2011</a></span>). We train our RNN on\nthe training dataset, which is made up of 25,000 movie reviews, some positive and some negative. We then test our RNN on the test set, which is\nalso made up of 25,000 movie reviews, again some positive and some negative. The training and test sets have no overlap. Since we are dealing with\ntext data, it’s a good idea to review various mechanisms for representing text data. Before that, we are going to briefly discuss how to preprocess\ntext documents.</p>\n\n<h2 id=\"text-preprocessing\">Text preprocessing</h2>\n\n<p>The first step is to tokenize a document, i.e., break it down into words. Next, we remove the punctuation marks, URLs, and stop words – words like\n‘a’, ‘of’, ‘the’, etc. that happen frequently in all documents and do not have much value in discriminating between documents. Next, we normalize\nthe text, e.g., replace ‘brb’ with ‘Be right back’, etc. Then, We then run the spell checker to fix typos and also make all words lowercase. Next, we perform stemming or lemmatization. Namely, if we have words like ‘organizer’, ‘organize’, ‘organized’, and ‘organization’ we want to reduce all of them to a single word. Stemming cuts the end of these words to come up with a single root (e.g., ‘organiz’). The root may not be an actual word.\nMeanwhile, lemmatization is smarter in that it reduces the word variants to a root that is actually a word (e.g., ‘organize’). All of these steps help reduce\nthe number of features in feature vector of a document and should make the training of our model faster/easier.</p>\n\n<p>For this introductory tutorial, we do minimal text preprocessing. We ignore the top 50 words in IMDB reviews (mostly stop words) and include\nthe next 10,000 words in our dataset. Reviews are limited to 500 words. They are trimmed if they are longer and padded if they are shorter.</p>\n\n<h2 id=\"bag-of-words-and-tf-idf\">Bag of words and TF-IDF</h2>\n\n<p>If you don’t care about the order of the words in a document, you can use bag of words (BoW) or term frequency inverse document frequency (TF-IDF).\nIn these models we have a 2 dimensional array. The rows represent the documents (in our example, the movie reviews) and the columns\nrepresent the words in our vocabulary (all the unique words in all the documents). If a word is not present in a document, we have a zero\nat the corresponding row and column as the entry. If a word is present in the document, we have a one as the entry – Alternatively, we could use\nthe word count or frequency.</p>\n\n<figure id=\"figure-10\" style=\"max-width: 90%;\"><img src=\"../../images/BoW.png\" alt=\"Table showing a bag-of-words representation of sample documents. \" width=\"1349\" height=\"78\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/BoW.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 10</strong>:</span> Bag of words (BoW) representation</figcaption></figure>\n\n<p>Suppose we have the following 2 documents: 1) Magic passed the basketball to Kareem, and 2) Lebron stole the basketball from Curry. The BoW\nrepresentation of these documents is given in Figure 10.</p>\n\n<p>BoW’s advantage is its simplicity, yet it does not take into account the rarity of a word across documents, which unlike common words are\nimportant for document classification.</p>\n\n<p>In TF-IDF, similar to BoW we have an entry for each document-word pair. In TD-IDF, the entry is the product of 1) term frequency, the\nfrequency of a word in a document, and 2) inverse document frequency, the inverse of the number of documents that have the word divided\nby the total number of documents (we usually use logarithm of the IDF).</p>\n\n<p>TF-IDF takes into account the rarity of a word across documents, and like BoW, it also does not capture word order or word meaning in documents. BoW\nand TF-IDF are suitable representations for when word order is not important. They are used in document classification problems, like spam detection.</p>\n\n<h2 id=\"one-hot-encoding-ohe\">One hot encoding (OHE)</h2>\n\n<p>OHE is a technique to convert categorical variables such as words into a vector. Suppose our vocabulary has 3 words: orange, apple, banana.\nEach word for this vocabulary is represented by a vector of size 3. Orange is represented by a vector whose first element is 1 and other\nelements are 0; apple is represented by a vector whose second element is 1 and other elements are 0; and banana is represented by a\nvector whose third element is 1 and other elements are 0. As you can see only one element in the vector is 1 and the rest are 0’s. The same\nconcept applies if the size of the vocabulary is N.</p>\n\n<figure id=\"figure-11\" style=\"max-width: 90%;\"><img src=\"../../images/OHE.gif\" alt=\"Mathematical vectors representing one-hot-encoding representation of words orange, apple, and banana. \" width=\"359\" height=\"66\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/OHE.gif\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 11</strong>:</span> One hot encoding (OHE) representation</figcaption></figure>\n\n<p>The problem with OHE is that for very large vocabulary sizes (say, 100,000 words) it requires tremendous amount of storage. Also, it has no\nconcept of word similarity.</p>\n\n<h2 id=\"word2vec\">Word2Vec</h2>\n\n<p>In Word2Vec, each word is represented as an <em>n</em> dimensional vector (<em>n</em> being much smaller than vocabulary size), such that the words that have\nsimilar meanings are closer to each other in the vector space, and words that don’t have a similar meaning are farther apart. Words are\nconsidered to have a similar meaning if they co-occur often in documents. There are 2 Word2Vec architectures, one that predicts the probability\nof a word given the surrounding words (continuous BoW), and one that given a word predicts the probability of the surrounding words (continuous\nskip-gram).</p>\n\n<p>In this tutorial, we find an <em>n</em> dimensional representation of the IMDB movie review words, not based on word meanings, but based on how they\nimprove the sentiment classification task. The <em>n</em> dimensional representation is learned by the learning algorithm, simply by reducing the\ncost function via backpropagation.</p>\n\n<h1 id=\"get-data\">Get Data</h1>\n\n<blockquote class=\"hands_on\">\n  <hands-on-title>Data upload</hands-on-title>\n\n  <ol>\n    <li>\n      <p>Create a new history for this tutorial</p>\n\n      <!--SNIPPET-->\n      <blockquote class=\"tip\">   <div class=\"box-title tip-title\" id=\"tip-creating-a-new-history\"><button class=\"gtn-boxify-button tip\" type=\"button\" aria-controls=\"tip-creating-a-new-history\" aria-expanded=\"true\"><i class=\"far fa-lightbulb\" aria-hidden=\"true\"></i> <span>Tip: Creating a new history</span><span class=\"fold-unfold fa fa-minus-square\"></span></button></div>   <p>Click the <i class=\"fas fa-plus\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">new-history</span> icon at the top of the history panel:</p>   <p><img src=\"/training-material/shared/images/history_create_new.svg\" alt=\"UI for creating new history\" /></p>   <!-- the original drawing can be found here https://docs.google.com/drawings/d/1cCBrLAo4kDGic5QyB70rRiWJAKTenTU8STsKDaLcVU8/edit?usp=sharing --> </blockquote>\n      <p><!--END_SNIPPET--></p>\n    </li>\n    <li>\n      <p>Import the files from <a href=\"https://zenodo.org/record/4477881\">Zenodo</a> and choose the type of data as <code class=\"language-plaintext highlighter-rouge\">tabular</code></p>\n\n      <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>https://zenodo.org/record/4477881/files/X_test.tsv\nhttps://zenodo.org/record/4477881/files/X_train.tsv\nhttps://zenodo.org/record/4477881/files/y_test.tsv\nhttps://zenodo.org/record/4477881/files/y_train.tsv\n</code></pre></div>      </div>\n\n      <!--SNIPPET-->\n      <blockquote class=\"tip\">   <div class=\"box-title tip-title\" id=\"tip-importing-via-links\"><button class=\"gtn-boxify-button tip\" type=\"button\" aria-controls=\"tip-importing-via-links\" aria-expanded=\"true\"><i class=\"far fa-lightbulb\" aria-hidden=\"true\"></i> <span>Tip: Importing via links</span><span class=\"fold-unfold fa fa-minus-square\"></span></button></div>   <ul>   <li>Copy the link location</li>   <li>     <p>Click <i class=\"fas fa-upload\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">galaxy-upload</span> <strong>Upload Data</strong> at the top of the tool panel</p>   </li>   <li>Select <i class=\"fa fa-edit\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">galaxy-wf-edit</span> <strong>Paste/Fetch Data</strong></li>   <li>     <p>Paste the link(s) into the text field</p>   </li>   <li>     <p>Press <strong>Start</strong></p>   </li>   <li><strong>Close</strong> the window</li> </ul> </blockquote>\n      <p><!--END_SNIPPET--></p>\n    </li>\n    <li>\n      <p>Rename the datasets as <code class=\"language-plaintext highlighter-rouge\">X_test</code>, <code class=\"language-plaintext highlighter-rouge\">X_train</code>, <code class=\"language-plaintext highlighter-rouge\">y_test</code>, and <code class=\"language-plaintext highlighter-rouge\">y_train</code> respectively.</p>\n\n      <!--SNIPPET-->\n      <blockquote class=\"tip\">   <div class=\"box-title tip-title\" id=\"tip-renaming-a-dataset\"><button class=\"gtn-boxify-button tip\" type=\"button\" aria-controls=\"tip-renaming-a-dataset\" aria-expanded=\"true\"><i class=\"far fa-lightbulb\" aria-hidden=\"true\"></i> <span>Tip: Renaming a dataset</span><span class=\"fold-unfold fa fa-minus-square\"></span></button></div>   <ul>   <li>Click on the <i class=\"fas fa-pencil-alt\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">galaxy-pencil</span> <strong>pencil icon</strong> for the dataset to edit its attributes</li>   <li>In the central panel, change the <strong>Name</strong> field</li>   <li>Click the <strong>Save</strong> button</li> </ul> </blockquote>\n      <p><!--END_SNIPPET--></p>\n    </li>\n    <li>\n      <p>Check that the datatype of all the four datasets is <code class=\"language-plaintext highlighter-rouge\">tabular</code>. If not, change the dataset’s datatype to tabular.</p>\n\n      <!--SNIPPET-->\n      <blockquote class=\"tip\">   <div class=\"box-title tip-title\" id=\"tip-changing-the-datatype\"><button class=\"gtn-boxify-button tip\" type=\"button\" aria-controls=\"tip-changing-the-datatype\" aria-expanded=\"true\"><i class=\"far fa-lightbulb\" aria-hidden=\"true\"></i> <span>Tip: Changing the datatype</span><span class=\"fold-unfold fa fa-minus-square\"></span></button></div>   <ul>   <li>Click on the <i class=\"fas fa-pencil-alt\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">galaxy-pencil</span> <strong>pencil icon</strong> for the dataset to edit its attributes</li>   <li>In the central panel, click <i class=\"fas fa-database\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">galaxy-chart-select-data</span> <strong>Datatypes</strong> tab on the top</li>   <li>In the <i class=\"fas fa-database\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">galaxy-chart-select-data</span> <strong>Assign Datatype</strong>, select <code class=\"language-plaintext highlighter-rouge\">tabular</code> from “<em>New type</em>” dropdown     <ul>       <li>Tip: you can start typing the datatype into the field to filter the dropdown menu</li>     </ul>   </li>   <li>Click the <strong>Save</strong> button</li> </ul> </blockquote>\n      <p><!--END_SNIPPET--></p>\n    </li>\n  </ol>\n\n</blockquote>\n\n<h1 id=\"sentiment-classification-of-imdb-movie-reviews-with-rnn\">Sentiment Classification of IMDB movie reviews with RNN</h1>\n\n<p>In the section, we define a RNN and train it using IMDB movie reviews training dataset. The goal is to learn a model such that given the\nwords in a review we can predict whether the review was positive or negative. We then evaluate the trained RNN on the test dataset\nand plot the confusion matrix.</p>\n\n<h2 id=\"create-a-deep-learning-model-architecture\">Create a deep learning model architecture</h2>\n\n<blockquote class=\"hands_on\">\n  <hands-on-title>Model config</hands-on-title>\n\n  <ul>\n    <li><span class=\"tool\" data-tool=\"toolshed.g2.bx.psu.edu/repos/bgruening/keras_model_config/keras_model_config/1.0.10.0\" title=\"Create a deep learning model architecture tool\" aria-role=\"button\"><i class=\"fas fa-wrench\" aria-hidden=\"true\"></i> <strong>Create a deep learning model architecture</strong> (<i class=\"fas fa-cubes\" aria-hidden=\"true\"></i> Galaxy version 1.0.10.0)</span>\n      <ul>\n        <li><em>“Select keras model type”</em>: <code class=\"language-plaintext highlighter-rouge\">sequential</code></li>\n        <li><em>“input_shape”</em>: <code class=\"language-plaintext highlighter-rouge\">(500,)</code></li>\n        <li>In <em>“LAYER”</em>:\n          <ul>\n            <li><i class=\"far fa-plus-square\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">param-repeat</span> <em>“1: LAYER”</em>:\n              <ul>\n                <li><em>“Choose the type of layer”</em>: <code class=\"language-plaintext highlighter-rouge\">Embedding -- Embedding</code>\n                  <ul>\n                    <li><em>“input_dim”</em>”: <code class=\"language-plaintext highlighter-rouge\">10000</code></li>\n                    <li><em>“output_dim”</em>”: <code class=\"language-plaintext highlighter-rouge\">32</code></li>\n                  </ul>\n                </li>\n              </ul>\n            </li>\n            <li><i class=\"far fa-plus-square\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">param-repeat</span> <em>“2: LAYER”</em>:\n              <ul>\n                <li><em>“Choose the type of layer”</em>: <code class=\"language-plaintext highlighter-rouge\">Recurrent -- LSTM</code>\n                  <ul>\n                    <li><em>“units”</em>”: <code class=\"language-plaintext highlighter-rouge\">100</code></li>\n                  </ul>\n                </li>\n              </ul>\n            </li>\n            <li><i class=\"far fa-plus-square\" aria-hidden=\"true\"></i><span class=\"visually-hidden\">param-repeat</span> <em>“3: LAYER”</em>:\n              <ul>\n                <li><em>“Choose the type of layer”</em>: <code class=\"language-plaintext highlighter-rouge\">Core -- Dense</code>\n                  <ul>\n                    <li><em>“units”</em>: <code class=\"language-plaintext highlighter-rouge\">1</code></li>\n                    <li><em>“Activation function”</em>: <code class=\"language-plaintext highlighter-rouge\">sigmoid</code></li>\n                  </ul>\n                </li>\n              </ul>\n            </li>\n          </ul>\n        </li>\n        <li>Click <em>“Run Tool”</em></li>\n      </ul>\n    </li>\n  </ul>\n</blockquote>\n\n<p>Input is a movie review of size 500 (longer reviews were trimmed and shorter ones padded). Our neural network has 3 layers. The first layer is\nan embedding layer, that transforms each review words into a 32 dimensional vector (<em>output_dim</em>). We have 10,000 unique words in our IMDB dataset\n(<em>input_dim</em>). The second layer is an <em>LSTM</em> layer, which is a type of RNN and it learns dependencies between time steps. We set the output size of the LSTM layer to <em>100</em>. The third layer is a\n<em>Dense</em> layer, which is a fully connected layer (all 100 output neurons in LSTM layer are connected to a single neuron in this layer). It has a\n<em>sigmoid</em> activation function, that generates an output between 0 and 1. Any output greater than 0.5 is considered a predicted positive review,\nand anything less than 0.5 a negative one. The model config can be downloaded as a JSON file for future reuse.</p>\n\n<h2 id=\"create-a-deep-learning-model\">Create a deep learning model</h2>\n\n<blockquote class=\"hands_on\">\n  <hands-on-title>Model builder (Optimizer, loss function, and fit parameters)</hands-on-title>\n\n  <ul>\n    <li><span class=\"tool\" data-tool=\"toolshed.g2.bx.psu.edu/repos/bgruening/keras_model_builder/keras_model_builder/1.0.10.0\" title=\"Create deep learning model tool\" aria-role=\"button\"><i class=\"fas fa-wrench\" aria-hidden=\"true\"></i> <strong>Create deep learning model</strong> (<i class=\"fas fa-cubes\" aria-hidden=\"true\"></i> Galaxy version 1.0.10.0)</span>\n      <ul>\n        <li><em>“Choose a building mode”</em>: <code class=\"language-plaintext highlighter-rouge\">Build a training model</code></li>\n        <li><em>“Select the dataset containing model configuration”</em>: Select the <em>Keras Model Config</em> from the previous step.</li>\n        <li><em>“Do classification or regression?”</em>: <code class=\"language-plaintext highlighter-rouge\">KerasGClassifier</code></li>\n        <li>In <em>“Compile Parameters”</em>:\n          <ul>\n            <li><em>“Select a loss function”</em>: <code class=\"language-plaintext highlighter-rouge\">binary_crossentropy</code></li>\n            <li><em>“Select an optimizer”</em>: <code class=\"language-plaintext highlighter-rouge\">Adam - Adam optimizer </code></li>\n            <li><em>“Select metrics”</em>: <code class=\"language-plaintext highlighter-rouge\">acc/accuracy</code></li>\n          </ul>\n        </li>\n        <li>In <em>“Fit Parameters”</em>:\n          <ul>\n            <li><em>“epochs”</em>: <code class=\"language-plaintext highlighter-rouge\">2</code></li>\n            <li><em>“batch_size”</em>: <code class=\"language-plaintext highlighter-rouge\">128</code></li>\n          </ul>\n        </li>\n        <li>Click <em>“Run Tool”</em></li>\n      </ul>\n    </li>\n  </ul>\n</blockquote>\n\n<p>A loss function measures how different the predicted output is versus the expected output. For binary classification problems, we use\n<em>binary cross entropy</em> as loss function. Epochs is the number of times the whole training data is used to train the model. Setting <em>epochs</em> to 2\nmeans each training example in our dataset is used twice to train our model. If we update network weights/biases after all the training data is\nfeed to the network, the training will be very slow (as we have 25,000 training examples in our dataset). To speed up the training, we present\nonly a subset of the training examples to the network, after which we update the weights/biases. <em>batch_size</em> decides the size of this subset.\nThe model builder can be downloaded as a zip file.</p>\n\n<h2 id=\"deep-learning-training-and-evaluation\">Deep learning training and evaluation</h2>\n\n<blockquote class=\"hands_on\">\n  <hands-on-title>Training the model</hands-on-title>\n\n  <ul>\n    <li><span class=\"tool\" data-tool=\"toolshed.g2.bx.psu.edu/repos/bgruening/keras_train_and_eval/keras_train_and_eval/1.0.10.0\" title=\"Deep learning training and evaluation tool\" aria-role=\"button\"><i class=\"fas fa-wrench\" aria-hidden=\"true\"></i> <strong>Deep learning training and evaluation</strong> (<i class=\"fas fa-cubes\" aria-hidden=\"true\"></i> Galaxy version 1.0.10.0)</span>\n      <ul>\n        <li><em>“Select a scheme”</em>: <code class=\"language-plaintext highlighter-rouge\">Train and Validate</code></li>\n        <li><em>“Choose the dataset containing pipeline/estimator object”</em>: Select the <em>Keras Model Builder</em> from the previous step.</li>\n        <li><em>“Select input type:”</em>: <code class=\"language-plaintext highlighter-rouge\">tabular data</code>\n          <ul>\n            <li><em>“Training samples dataset”</em>: Select <code class=\"language-plaintext highlighter-rouge\">X_train</code> dataset</li>\n            <li><em>“Choose how to select data by column:”</em>: <code class=\"language-plaintext highlighter-rouge\">All columns</code></li>\n            <li><em>“Dataset containing class labels or target values”</em>: Select <code class=\"language-plaintext highlighter-rouge\">y_train</code> dataset</li>\n            <li><em>“Choose how to select data by column:”</em>: <code class=\"language-plaintext highlighter-rouge\">All columns</code></li>\n          </ul>\n        </li>\n        <li>Click <em>“Run Tool”</em></li>\n      </ul>\n    </li>\n  </ul>\n\n</blockquote>\n\n<p>The training step generates 2 datasets. 1) accuracy of the trained model, 2) the trained model, in <em>h5mlm</em> format. These files are needed for prediction in the next step.</p>\n\n<h2 id=\"model-prediction\">Model Prediction</h2>\n\n<blockquote class=\"hands_on\">\n  <hands-on-title>Testing the model</hands-on-title>\n\n  <ul>\n    <li><span class=\"tool\" data-tool=\"toolshed.g2.bx.psu.edu/repos/bgruening/model_prediction/model_prediction/1.0.10.0\" title=\"Model Prediction tool\" aria-role=\"button\"><i class=\"fas fa-wrench\" aria-hidden=\"true\"></i> <strong>Model Prediction</strong> (<i class=\"fas fa-cubes\" aria-hidden=\"true\"></i> Galaxy version 1.0.10.0)</span>\n      <ul>\n        <li><em>“Choose the dataset containing pipeline/estimator object”</em> : Select the trained model from the previous step.</li>\n        <li><em>“Select invocation method”</em>: <code class=\"language-plaintext highlighter-rouge\">predict</code></li>\n        <li><em>“Select input data type for prediction”</em>: <code class=\"language-plaintext highlighter-rouge\">tabular data</code></li>\n        <li><em>“Training samples dataset”</em>: Select <code class=\"language-plaintext highlighter-rouge\">X_test</code> dataset</li>\n        <li><em>“Choose how to select data by column:”</em>: <code class=\"language-plaintext highlighter-rouge\">All columns</code></li>\n        <li>Click <em>“Run Tool”</em></li>\n      </ul>\n    </li>\n  </ul>\n\n</blockquote>\n\n<p>The prediction step generates 1 dataset. It’s a file that has predictions (1 or 0 for positive or negative movie reviews) for every review in\nthe test dataset.</p>\n\n<h2 id=\"machine-learning-visualization-extension\">Machine Learning Visualization Extension</h2>\n\n<blockquote class=\"hands_on\">\n  <hands-on-title>Creating the confusion matrix</hands-on-title>\n\n  <ul>\n    <li><span class=\"tool\" data-tool=\"toolshed.g2.bx.psu.edu/repos/bgruening/ml_visualization_ex/ml_visualization_ex/1.0.10.0\" title=\"Machine Learning Visualization Extension tool\" aria-role=\"button\"><i class=\"fas fa-wrench\" aria-hidden=\"true\"></i> <strong>Machine Learning Visualization Extension</strong> (<i class=\"fas fa-cubes\" aria-hidden=\"true\"></i> Galaxy version 1.0.10.0)</span>\n      <ul>\n        <li><em>“Select a plotting type”</em>: <code class=\"language-plaintext highlighter-rouge\">Confusion matrix for classes</code></li>\n        <li><em>“Select dataset containing the true labels”</em>”: <code class=\"language-plaintext highlighter-rouge\">y_test</code></li>\n        <li><em>“Choose how to select data by column:”</em>: <code class=\"language-plaintext highlighter-rouge\">All columns</code></li>\n        <li><em>“Select dataset containing the predicted labels”</em>”: Select <code class=\"language-plaintext highlighter-rouge\">Model Prediction</code> from the previous step</li>\n        <li><em>“Does the dataset contain header:”</em>: <code class=\"language-plaintext highlighter-rouge\">Yes</code></li>\n        <li>Click <em>“Run Tool”</em></li>\n      </ul>\n    </li>\n  </ul>\n\n</blockquote>\n\n<p><strong>Confusion Matrix</strong> is a table that describes the performance of a classification model. It lists the number of positive and negative examples\nthat were correctly classified by the model, true positives (TP) and true negatives (TN), respectively. It also lists the number of examples that\nwere classified as positive that were actually negative (false positive, FP, or type I error), and the number of examples that were classified\nas negative that were actually positive (false negative, FN, or type 2 error). Given the confusion matrix, we can calculate <strong>precision</strong> and\n<strong>recall</strong> <span class=\"citation\"><a href=\"#TatbulEtAl\">Tatbul <i>et al.</i> 2018</a></span>. Precision is the fraction of predicted positives that are true positives (precision = TP / (TP + FP)). Recall\nis the fraction of true positives that are predicted (recall = TP / (TP + FN)). One way to describe the confusion matrix with just one value is\nto use the <strong>F score</strong>, which is the harmonic mean of precision and recall.</p>\n\n\\[Precision = \\frac{\\text{True positives}}{\\text{True positives + False positives}}\\]\n\n\\[Recall = \\frac{\\text{True positives}}{\\text{True positives + False negatives}}\\]\n\n\\[F score = \\frac{2 * \\text{Precision * Recall}}{\\text{Precision + Recall}}\\]\n\n<figure id=\"figure-12\" style=\"max-width: 90%;\"><img src=\"../../images/ConfusionMatrix.png\" alt=\"Confusion matrix for our sentiment analysis problem. \" width=\"890\" height=\"902\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/ConfusionMatrix.png\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 12</strong>:</span> Sentiment analysis confusion matrix</figcaption></figure>\n\n<p>Figure 12 is the resultant confusion matrix for our sentiment analysis problem (note that your numbers in the matrix may differ, and that is expected). The top row in the figure represents the <em>true</em> 0 (or negative sentiment)\nclass labels (we have 10,397 + 2,103 = 12,500 reviews with negative sentiment). The bottom row represents the <em>true</em> 1 (or positive sentiment) class labels\n(Again, we have 1,281 + 11,219 = 12,500 reviews with positive sentiment). The left column represents the <em>predicted</em> negative sentiment class labels (Our RNN\npredicted 10,397 + 1,281 = 11,678 reviews as having a negative sentiment). The right column represents the <em>predicted</em> positive class labels (Our RNN\npredicted 11,219 + 2,103 = 13,322 reviews as having a positive sentiment).Looking at the bottom right cell, we see that our RNN has correctly predicted 11,219\nreviews as having a positive sentiment (true positives). Looking at the top right cell, we see that our RNN has incorrectly predicted 2,103 reviews as having\na positive (false positives). Similarly, looking at the top left cell, we see that our RNN has correctly predicted 10,397 reviews as having negative sentiment\n(true negative). Finally, looking at the bottom left cell, we see that our RNN has incorrectly predicted 1,281 reviews as negative (false negative). Given\nthese numbers we can calculate Precision, Recall, and the F score as follows:</p>\n\n\\[Precision = \\frac{\\text{True positives}}{\\text{True positives + False positives}} = \\frac{11,219}{11,219 + 2,102} = 0.84\\]\n\n\\[Recall = \\frac{\\text{True positives}}{\\text{True positives + False negatives}} = \\frac{11,219}{11,219 + 1,281} = 0.89\\]\n\n\\[F score = \\frac{2 * \\text{Precision * Recall}}{\\text{Precision + Recall}} = \\frac{2 * 0.84 * 0.89}{0.84 + 0.89} = 0.86\\]\n\n<h1 id=\"conclusion\">Conclusion</h1>\n\n<p>In this tutorial, we briefly reviewed feedforward neural networks, explained how recurrent neural networks are different, and discussed various\nRNN input/outputs and architectures. We also discussed various text representation and preprocessing schemes and used Galaxy to solve a sentiment\nclassification problem using RNN on IMDB movie reviews dataset.</p>\n"],"ref_slides":["# What is a recurrent neural network (RNN)?\n\n???\n\nWhat is a recurrent neural network (RNN)?\n\n---\n\n# Recurrent Neural Network (RNN)\n\n- RNN models sequential data (temporal/ordinal)\n- In RNN, training example is a sequence, which is presented to RNN one at a time \n\t- E.g., sequence of English words is passed to RNN, one at a time \n\t- And, RNN generates a sequence of Persian words, one at a time\n- In RNN, output of network at time *t* is used as input at time *t+1*\n- RNN applied to image description, machine translation, sentiment analysis, etc. \n\n---\n\n# One-to-many RNN\n\n![Neurons forming a one-to-many recurrent neural network](/training-material/topics/statistics/images/RNN_1_to_n.png) <!-- https://pixy.org/3013900/ CC0 license-->\n\n---\n\n# Many-to-one RNN\n\n![Neurons forming a many-to-one recurrent neural network](/training-material/topics/statistics/images/RNN_n_to_1.png) <!-- https://pixy.org/3013900/ CC0 license-->\n\n---\n\n# Many-to-many RNN\n\n![Neurons forming a many-to-many recurrent neural network](/training-material/topics/statistics/images/RNN_n_to_m.png) <!-- https://pixy.org/3013900/ CC0 license-->\n\n---\n\n# RNN architectures\n\n- Vanilla RNN\n\t- Suffers from *vanishing gradient* problem\n- LSTM and GRU\n\t- Uses *gates* to avoid vanishing gradient problem\n\n---\n\n# Sentiment analysis\n\n- We perform sentiment analysis on IMDB movie reviews dataset\n- Train RNN on training dataset (25000 positive/negative movie reviews)\n- Test RNN on test set (25000 positive/negative movie reviews)\n- Training and test sets have no overlap\n- Since dealing with text data, good to review mechanisms for representing text data\n\n---\n\n# Text preprocessing\n\n- Tokenize a document, i.e., break it down into words\n- Remove punctuations, URLs, and stop words (‘a’, ‘of’, ‘the’, etc.)\n- Normalize the text, e.g., replace ‘brb’ with ‘Be right back’, etc\n- Run the spell checker to fix typos\n- Make all words lowercase\n\n---\n\n# Text preprocessing\n\n- Perform stemming/lemmatization\n\t- If we have words like ‘organizer’, ‘organize’, and ‘organized’\n\t\t- Want to reduce all of them to a single word\n\t- Stemming cuts end of these words for a single root\n\t\t- E.g., ‘organiz’.  May not be an actual word\n\t- Lemmatization reduces to a root that is actually a word\n\t\t- E.g., ‘organize’\n\n---\n\n# Bag of words (BoW)\n\n- If you don’t care about the order of the words in a document\n- 2D array. Rows represent documents. Columns represent words in vocabulary\n\t- All unique words in all documents\n- If a word not present in a document, we have a zero at row and column entry\n- If a word is present in a document, we have a one at row and colum entry\n\t- Or, we could use the word count or frequency\n\n---\n\n# Bag of words (BoW)\n\n- Document 1: Magic passed the basketball to Kareem\n- Document 2: Lebron stole the basketball from Curry\n\n![Table showing a bag-of-words representation of sample documents](/training-material/topics/statistics/images/BoW.png) <!-- https://pixy.org/3013900/ CC0 license-->\n\n- BoW is simple, but does not consider rarity of words across documents\n\t- Important for document classification\n\n---\n\n# Term frequency inverse document frequency (TF-IDF)\n\n- If you don’t care about the order of the words in a document\n- Similar to BoW, we have an entry for each document-word pair\n- Entry is product of\n\t- Term frequency, frequency of a word in a document, and\n\t- Inverse document frequency, total number of documents divided by number of documents that have word\n\t\t- Usually use logarithm of the IDF\n- TF-IDF takes into account rarity of a word across documents\n\n---\n\n# One-hot encoding (OHE)\n\n- Technique to convert categorical variables such as words into a vector\n- Suppose our vocabulary has 3 words: orange, apple, banana\n- Each word is represented by a vector of size 3\n\n![Mathematical vectors representing one-hot-encoding representation of words orange, apple, and banana](/training-material/topics/statistics/images/OHE.gif) <!-- https://pixy.org/3013900/ CC0 license-->\n\n- OHE problems\n\t- For very large vocabulary sizes requires tremendous amount of storage\n\t- Also, no concept of word similarity\n\n---\n\n# Word2Vec\n\n- Each word represented as an *n* dimensional vector\n\t- *n* much smaller than vocabulary size\n- Words that have similar meanings are close in vector space\n- Words considered similar if they co-occur often in documents\n- Two Word2Vec architectures\n\t- Continuous BoW\n\t\t- predicts probability of a word given the surrounding words\n\t- Continuous skip-gram\n\t\t- given a word predicts probability of the surrounding words\n\n---\n\n# Sentiment analysis\n\n- Sentiment classification of IMDB movie reviews with RNN\n- Train RNN using IMDB movie reviews\n- Goal is to learn a model such that given a review we predict whether review is positive/negative\n- We evaluate the trained RNN on test dataset and plot confusion matrix\n\n---\n\n# For references, please see tutorial's References section\n\n---\n"],"hands_on":true,"slides":true,"mod_date":"2024-05-29 15:37:52 +0000","pub_date":"2021-02-23 08:46:07 +0000","version":48,"workflows":[{"workflow":"Intro_To_RNN_v1_0_10_0.ga","tests":true,"url":"https://training.galaxyproject.org/training-material/topics/statistics/tutorials/RNN/workflows/Intro_To_RNN_v1_0_10_0.ga","path":"topics/statistics/tutorials/RNN/workflows/Intro_To_RNN_v1_0_10_0.ga","wfid":"statistics-RNN","wfname":"intro_to_rnn_v1_0_10_0","trs_endpoint":"https://training.galaxyproject.org/training-material/api/ga4gh/trs/v2/tools/statistics-RNN/versions/intro_to_rnn_v1_0_10_0","license":"CC-BY-4.0","creators":[{"class":"Person","identifier":"0000-0001-6585-3619","name":"Kaivan Kamali"}],"name":"Intro_To_RNN_v1_0_10_0","title":"Intro_To_RNN_v1_0_10_0","test_results":null,"modified":"2024-06-14 12:21:32 +0000","mermaid":"flowchart TD\n  0[\"ℹ️ Input Dataset\\nX_test\"];\n  style 0 stroke:#2c3143,stroke-width:4px;\n  1[\"ℹ️ Input Dataset\\nX_train\"];\n  style 1 stroke:#2c3143,stroke-width:4px;\n  2[\"ℹ️ Input Dataset\\ny_test\"];\n  style 2 stroke:#2c3143,stroke-width:4px;\n  3[\"ℹ️ Input Dataset\\ny_train\"];\n  style 3 stroke:#2c3143,stroke-width:4px;\n  4[\"Create a deep learning model architecture\"];\n  5[\"Create deep learning model\"];\n  4 -->|outfile| 5;\n  6[\"Deep learning training and evaluation\"];\n  5 -->|outfile| 6;\n  1 -->|output| 6;\n  3 -->|output| 6;\n  7[\"Model Prediction\"];\n  6 -->|outfile_object| 7;\n  0 -->|output| 7;\n  8[\"Machine Learning Visualization Extension\"];\n  7 -->|outfile_predict| 8;\n  2 -->|output| 8;"}],"api":"https://training.galaxyproject.org/training-material/api/topics/statistics/tutorials/RNN/tutorial.json","tools":["toolshed.g2.bx.psu.edu/repos/bgruening/keras_model_builder/keras_model_builder/1.0.10.0","toolshed.g2.bx.psu.edu/repos/bgruening/keras_model_config/keras_model_config/1.0.10.0","toolshed.g2.bx.psu.edu/repos/bgruening/keras_train_and_eval/keras_train_and_eval/1.0.10.0","toolshed.g2.bx.psu.edu/repos/bgruening/ml_visualization_ex/ml_visualization_ex/1.0.10.0","toolshed.g2.bx.psu.edu/repos/bgruening/model_prediction/model_prediction/1.0.10.0"],"supported_servers":{"exact":[{"url":"https://usegalaxy.cz/","name":"UseGalaxy.cz","usegalaxy":false},{"url":"https://usegalaxy.eu","name":"UseGalaxy.eu","usegalaxy":true},{"url":"https://usegalaxy.org","name":"UseGalaxy.org (Main)","usegalaxy":true},{"url":"https://usegalaxy.org.au","name":"UseGalaxy.org.au","usegalaxy":true}],"inexact":[{"url":"https://usegalaxy.be/","name":"UseGalaxy.be","usegalaxy":false},{"url":"https://usegalaxy.no/","name":"UseGalaxy.no","usegalaxy":false}]},"topic_name_human":"Statistics and machine learning","admin_install":{"install_tool_dependencies":true,"install_repository_dependencies":true,"install_resolver_dependencies":true,"tools":[{"name":"keras_model_builder","owner":"bgruening","revisions":"66d7efc06000","tool_panel_section_label":"Machine Learning","tool_shed_url":"https://toolshed.g2.bx.psu.edu/"},{"name":"keras_model_config","owner":"bgruening","revisions":"f22a9297440f","tool_panel_section_label":"Machine Learning","tool_shed_url":"https://toolshed.g2.bx.psu.edu/"},{"name":"keras_train_and_eval","owner":"bgruening","revisions":"818f9b69d8a0","tool_panel_section_label":"Machine Learning","tool_shed_url":"https://toolshed.g2.bx.psu.edu/"},{"name":"ml_visualization_ex","owner":"bgruening","revisions":"1588f9076e32","tool_panel_section_label":"Machine Learning","tool_shed_url":"https://toolshed.g2.bx.psu.edu/"},{"name":"model_prediction","owner":"bgruening","revisions":"9991c4ddde14","tool_panel_section_label":"Machine Learning","tool_shed_url":"https://toolshed.g2.bx.psu.edu/"}]},"admin_install_yaml":"---\ninstall_tool_dependencies: true\ninstall_repository_dependencies: true\ninstall_resolver_dependencies: true\ntools:\n- name: keras_model_builder\n  owner: bgruening\n  revisions: 66d7efc06000\n  tool_panel_section_label: Machine Learning\n  tool_shed_url: https://toolshed.g2.bx.psu.edu/\n- name: keras_model_config\n  owner: bgruening\n  revisions: f22a9297440f\n  tool_panel_section_label: Machine Learning\n  tool_shed_url: https://toolshed.g2.bx.psu.edu/\n- name: keras_train_and_eval\n  owner: bgruening\n  revisions: 818f9b69d8a0\n  tool_panel_section_label: Machine Learning\n  tool_shed_url: https://toolshed.g2.bx.psu.edu/\n- name: ml_visualization_ex\n  owner: bgruening\n  revisions: 1588f9076e32\n  tool_panel_section_label: Machine Learning\n  tool_shed_url: https://toolshed.g2.bx.psu.edu/\n- name: model_prediction\n  owner: bgruening\n  revisions: 9991c4ddde14\n  tool_panel_section_label: Machine Learning\n  tool_shed_url: https://toolshed.g2.bx.psu.edu/\n","tours":false,"video":false,"slides_recordings":false,"translations":{"tutorial":[],"slides":[],"video":false},"license":"CC-BY-4.0","type":"tutorial"}
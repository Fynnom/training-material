{"layout":"tutorial_slides","logo":"GTN","title":"Prerequisites for building software/conda packages","subtopic":"dependencies","questions":["What does 'installing a software' means on a Linux architecture?","Why my compilations always fail?","How to solve common compiling and installation issues?"],"objectives":["Learn how to compile and install tools using standard procedures.","Learn needed tricks to write conda build.sh files."],"time_estimation":"1h","key_points":["There is a common procedure to compile and install many tools: `./configure && make && make install`","Some exotic tools require adjustements to compile or install properly","Pay attention to INSTALL and README files, and to documentation"],"contributors":["abretaud","cmonjeau"],"js_requirements":{"mathjax":null,"mermaid":false},"short_id":"S00046","url":"/topics/dev/tutorials/conda_sys/slides.html","topic_name":"dev","tutorial_name":"conda_sys","dir":"topics/dev/tutorials/conda_sys","symlink":null,"id":"dev/conda_sys","ref_tutorials":[],"ref_slides":["class: left, enlarge120\n\n### Environment variables\n\n```sh\n$ MY_NAME=\"Bobby\"\n$ echo $MY_NAME\nBobby\n```\n\n```sh\n$ MY_DATE=$(date)\n$ echo $MY_DATE\nWed Feb 14 12:12:21 CET 2018\n```\n\nUse export to make sure the variable is accessible to any script/program you run from the current shell.\n\n```sh\n$ export MY_DATE=$(date)\n$ echo $MY_DATE\nWed Feb 14 12:12:21 CET 2018\n$ bash some_script.sh # some_script.sh will have access to $MY_DATE\n```\n\nMany environment variables predefined in a shell: PATH, HOSTNAME, HOME, LANG, USER, ...\n\n---\n\nclass: left, enlarge120\n\n### Show me the PATH\n\n```sh\n$ the_binary --help\n```\n\nHow does the system knows where to find the binary?\n\nPATH is an environment variable defining possible locations of binaries.\n\n```sh\n$ echo $PATH\n/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin\n```\n\nPaths separated by `:`, ordered list (highest priority first).\n\nAs all environment variable, you can redefine it:\n\n```sh\n$ export PATH=\"/opt/xxx/bin/:$PATH\"\n$ echo $PATH\n/opt/xxx/bin/:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin\n```\n\n---\n\nclass: left, enlarge120\n\n### Show me the PATH\n\nThe command `which` lets you know which binary will be used by your shell.\n\n```sh\n$ which the_binary\n/opt/xxx/bin/the_binary\n```\n\nIt throws an error if the binary is not \"in the PATH\".\n\n```sh\n$ export PATH=\"/usr/bin/\"\n$ echo $PATH\n/usr/bin\n```\n```sh\n$ which the_binary\n/usr/bin/which: no the_binary in (/usr/bin)\n```\n\n---\n\nclass: left, enlarge120\n\n### Thinking outside the PATH\n\nWhat if you want to run a binary only located in the current working directory?\n\n```sh\n$ ls\nmy_binary\n$ my_binary --help\nbash: my_binary: command not found...\n```\n\nYou need to add `./` to explicitly tell the shell to run the file from working directory:\n\n```sh\n$ ./my_binary --help\nIt works!\n```\n\n`./` is just the relative path to `my_binary`, it could be a more complicated one, or an absolute path:\n\n```sh\n$ ../somewhere/my_binary --help\nIt works!\n$ /home/someone/womewhere/my_binary --help\nIt works!\n```\n\n---\n\nclass: left, enlarge120\n\n### Installing a single binary\n\nJust a single executable file (binary, script).\n\nYou only need to copy it to a `bin` directory and make sure permissions are set:\n\n```sh\n$ cp the_binary /usr/local/bin\n$ chmod a+x /usr/local/bin/the_binary\n```\n\nOther possible `bin` directories:\n\n```sh\n/bin            = reserved for system\n/usr/bin        = installed by package manager (apt, yum, ...)\n/usr/local/bin  = manually installed binaries\n/opt/xxx/bin    = manually installed binaries (xxx=path)\n/yyy/bin        = a bin directory wherever you like (yyy=path)\n```\n\n\n.center[.footnote[If you install a precompiled binary, make sure that it was compiled for the same architecture as your system (e.g. x86_64)]]\n\n---\n\nclass: left, enlarge120\n\n### Compiling a single binary\n\nIn the following slides we consider a program written in `C`.\n\nUsually, compilation is done with `make`.\n\n```sh\n$ ls\nMakefile    my_program.c\n```\n```sh\n$ make\n```\n```sh\n$ ls\nMakefile    my_program.c    my_binary\n```\n\n`make` will read the instructions defined in the file `Makefile` and run the compiler automatically to produce the binary.\n\nYou can then copy the binary to a bin dir.\n\nSome exotic tools come with other scripts or methods for compiling, read the README or INSTALL files.\n\n---\n\nclass: left, enlarge120\n\n### Compiling a library\n\nLibraries are reusable chunks of code. They are not executable as is. They are compiled similarly as binaries.\n\n```sh\n$ ls\nMakefile    my_lib.c    my_lib.h\n```\n```sh\n$ make\n```\n```sh\n$ ls\nMakefile    my_lib.c    my_lib.h    libmy.so.1.2.8\n```\n\n`.h` files are code files defining which functions are provided by the library.\n\n`.so` are compiled binary code. Their file name structure is important: `libXXXX.so.version`.\n\n---\n\nclass: left, enlarge120\n\n### Installing a library\n\n```sh\n$ cp libmy.so.1.2.8 /usr/local/lib/\n```\n\nSome symbolic links need to be created:\n\n```sh\n$ ln -s /usr/local/lib/libmy.so.1.2.8 /usr/local/lib/libmy.so\n$ ln -s /usr/local/lib/libmy.so.1.2.8 /usr/local/lib/libmy.so.1\n```\n\nYou also need to install `headers` in a `include` dir:\n\n```sh\n$ cp my_lib.h /usr/local/include/\n```\n\nOther possible `lib` (or `lib64`) directories (same principle for `include`):\n\n```sh\n/lib(64)            = reserved for system\n/usr/lib(64)        = installed by package manager (apt, yum, ...)\n/usr/local/lib(64)  = manually installed\n/opt/xxx/lib(64)    = manually installed (xxx=path)\n/yyy/lib(64)        = a lib directory wherever you like (yyy=path)\n```\n\n---\n\nclass: left, enlarge120\n\n### make install\n\nCopying/symlinking manually each file is painful.\n\nRunning `make install` usually install everything automatically for you.\n\n```sh\n$ make\n$ make install\n```\n\nBy default, installs to `/usr/local`. We will see how to change this later.\n\n---\n\nclass: left, enlarge120\n\n### Compiling a binary that uses an external library\n\nFor example, if your program relies on `zlib` to read or create gzipped files.\n\n`make` needs to know where are the `.h` and `.so` files to compile your program properly.\n\nUsually, a script named 'configure' is distributed with the program sources.\n\n```sh\n$ ls\nconfigure   Makefile    my_program.c\n```\n\nThis script explores the filesystem to find the needed `.h` and `.so` files. You can then run `make` and `make install` as usual.\n\n```sh\n$ ./configure\n$ make\n$ make install\n```\n\nSometimes, `configure` is replaced by another software like cmake.\n\n---\n\nclass: left, enlarge120\n\n### Playing with ./configure\n\nYou can pass many options to the `configure` script.\n\nA very common one is `--prefix` which allows to change the installation directory.\n\n```sh\n$ ./configure --prefix=/home/somewhere\n$ make\n$ make install\n```\n\nThe binary will be installed in `/home/somewhere/bin/`\n\nIf you are compiling a library, files will be installed in `/home/somewhere/include/` and `/home/somewhere/lib(64)/`\n\n---\n\nclass: left, enlarge120\n\n### Playing with ./configure\n\nYou can pass many options to the `configure` script.\n\nYou can often disable or enable some software features this way.\n\n```sh\n$ ./configure --disable-gpu --enable-greedy-algorithm\n$ make\n$ make install\n```\n\n---\n\nclass: left, enlarge120\n\n### Playing with ./configure\n\nBy default, `configure` only searches for `.h` and `.so` files in standard directories (`/usr/`, `/usr/local`).\n\nIf your program depends on a library installed in an exotic location, you need to specify it.\n\nThere might be a specific `configure` option.\n\n```sh\n$ ./configure --zlib-dir=/home/somewhere/zlib/\n```\n\nOr, you can define some standard environment variables:\n\n```sh\n$ export CFLAGS=\"-I/home/somewhere/zlib/include $CFLAGS\"\n$ export LDFLAGS=\"-L/home/somewhere/zlib/lib $LDFLAGS\"\n```\n\nIn some cases, you might need to define additional variables:\n\n```sh\n$ export CPATH=\"/home/somewhere/zlib/include:$CPATH\"\n$ export LIBRARY_PATH=\"/home/somewhere/zlib/lib:$LIBRARY_PATH\"\n```\n\n---\n\nclass: left, enlarge120\n\n### Playing with ./configure\n\nThe `CFLAGS` environment variable can also be used for other purposes like enabling some compiler optimisation, predefining some C macro or compiling with debugging symbols.\n\n```sh\n$ export CFLAGS=\"-I/home/somewhere/zlib/include -O2 -DDEBUG -g\"\n```\n\nWhen you are compiling C++ code, you need to use `CXXFLAGS` instead of `CFLAGS`.\n\n---\n\nclass: left, enlarge120\n\n### Shebang\n\nThe first line of script is called the [shebang](https://en.wikipedia.org/wiki/Shebang_%28Unix%29).\n\n```sh\n#!/bin/bash\n```\n\nIt determines how your script will be run when called in a shell.\n\n```sh\n$ my_script.sh\n$ # is interpreted as\n$ /bin/bash /usr/bin/my_script.sh\n```\n\n---\n\nclass: left, enlarge120\n\n### Shebang\n\nYou need to write an absolute path in the shebang. But never do this:\n\n```sh\n#!/usr/bin/python\n```\n\nBecause you are not sure /usr/bin/python will always be at this location. Preferred solution:\n\n```sh\n#!/usr/bin/env python\n```\n\nThis will ensure to use the `python` found using the PATH environment variable.\n\n`/bin/bash` or `/usr/bin/env` are considered to always be present.\n\n---\n\nclass: left, enlarge120\n\n### Python/Perl/R packages\n\nInstalling Python modules consists in placing the source files in the correct path inside the Python installation.\n\nFor example BioPython code will be installed in `/usr/lib/python3.6/site-packages/Bio/`\n\nSome Python modules consists both of Python code and C code that need to be compiled.\n\nPython modules are usually installed with specific setup mechanisms that take care of it all for you.\n\n```sh\n$ pip install my_module\n```\n\n```sh\n$ cd my_module_src/\n$ python setup.py install\n```\n\nPerl or R modules are installed in similar ways.\n\n---\n\nclass: left, enlarge120\n\n### Common error: Undefined symbol\n\nSymptom: you get an `Undefined symbol` while running an installed program.\n\nCause: the program uses a library which is not available in the expected location.\n\nTo list all the libraries needed by the program and identify the one causing the problem:\n\n```sh\n$ ldd `which nano`\n\tlinux-vdso.so.1 (0x00007ffdfb48c000)\n\tlibmagic.so.1 => not found\n\tlibncursesw.so.6 => /lib64/libncursesw.so.6 (0x00007f16cbb54000)\n```\n\nMake sure the library is correctly installed. If it is installed in an exotic location, use the `LD_LIBRARY_PATH` environment.\n\n```sh\n$ export LD_LIBRARY_PATH=\"/home/somewhere/magic/:$LD_LIBRARY_PATH\"\n$ ldd `which nano`\n\tlinux-vdso.so.1 (0x00007ffdfb48c000)\n\tlibmagic.so.1 => /home/somewhere/magic/lib/libmagic.so.1\n\tlibncursesw.so.6 => /lib64/libncursesw.so.6 (0x00007f16cbb54000)\n```\n"],"video_library":{"tutorial":null,"slides":null,"demo":null,"both":null,"session":null},"hands_on":false,"slides":true,"mod_date":"2021-05-27 12:26:52 +0000","pub_date":"2018-02-15 12:06:42 +0000","version":14,"api":"https://training.galaxyproject.org/training-material/api/topics/dev/tutorials/conda_sys/tutorial.json","tools":[],"supported_servers":[],"topic_name_human":"Development in Galaxy","admin_install":{"install_tool_dependencies":true,"install_repository_dependencies":true,"install_resolver_dependencies":true,"tools":[]},"admin_install_yaml":"---\ninstall_tool_dependencies: true\ninstall_repository_dependencies: true\ninstall_resolver_dependencies: true\ntools: []\n","tours":false,"video":false,"translations":{"tutorial":[],"slides":[],"video":false},"license":"CC-BY-4.0","type":"tutorial","redirect_from":["/short/dev/conda_sys/slides","/short/S00046"]}
{"layout":"tutorial_hands_on","title":"Advanced CLI in Galaxy","level":"Intermediate","zenodo_link":"","requirements":[{"type":"internal","topic_name":"data-science","tutorials":["cli-basics"]}],"follow_up_training":[{"type":"internal","topic_name":"data-science","tutorials":["cli-bashcrawl"]}],"questions":["How can I combine existing commands to do new things?","How can I perform the same actions on many different files?","How can I find files?","How can I find things in files?"],"objectives":["Redirect a command's output to a file.","Process a file instead of keyboard input using redirection.","Construct command pipelines with two or more stages.","Explain what usually happens if a program or pipeline isn't given any input to process.","Explain Unix's 'small pieces, loosely joined' philosophy.","Write a loop that applies one or more commands separately to each file in a set of files.","Trace the values taken on by a loop variable during execution of the loop.","Explain the difference between a variable's name and its value.","Explain why spaces and some punctuation characters shouldn't be used in file names.","Demonstrate how to see what commands have recently been executed.","Re-run recently executed commands without retyping them.","Use `grep` to select lines from text files that match simple patterns.","Use `find` to find files and directories whose names match simple patterns.","Use the output of one command as the command-line argument(s) to another command.","Explain what is meant by 'text' and 'binary' files, and why many common tools don't handle the latter well."],"time_estimation":"2H","key_points":["`wc` counts lines, words, and characters in its inputs.","`cat` displays the contents of its inputs.","`sort` sorts its inputs.","`head` displays the first 10 lines of its input.","`tail` displays the last 10 lines of its input.","`command > [file]` redirects a command's output to a file (overwriting any existing content).","`command >> [file]` appends a command's output to a file.","`[first] | [second]` is a pipeline: the output of the first command is used as the input to the second.","The best way to use the shell is to use pipes to combine simple single-purpose programs (filters).","A `for` loop repeats commands once for every thing in a list.","Every `for` loop needs a variable to refer to the thing it is currently operating on.","Use `$name` to expand a variable (i.e., get its value). `${name}` can also be used.","Do not use spaces, quotes, or wildcard characters such as '*' or '?' in filenames, as it complicates variable expansion.","Give files consistent names that are easy to match with wildcard patterns to make it easy to select them for looping.","Use the up-arrow key to scroll up through previous commands to edit and repeat them.","Use <kbd>Ctrl</kbd>+<kbd>R</kbd> to search through the previously entered commands.","Use `history` to display recent commands, and `![number]` to repeat a command by number.","`find` finds files with specific properties that match patterns.","`grep` selects lines in files that match patterns.","`--help` is an option supported by many bash commands, and programs that can be run from within Bash, to display more information on how to use these commands or programs.","`man [command]` displays the manual page for a given command.","`$([command])` inserts a command's output in place."],"notebook":{"language":"bash"},"subtopic":"bash","contributors":[{"name":"The Carpentries","joined":"2021-09","id":"carpentries","url":"https://training.galaxyproject.org/training-material/api/organisations/carpentries.json","page":"https://training.galaxyproject.org/training-material/hall-of-fame/carpentries/"},{"name":"Helena Rasche","orcid":"0000-0001-9760-8992","maintainer_contact":"gitter","matrix":"hexylena:matrix.org","joined":"2017-09","elixir_node":"nl","affiliations":["gallantries","by-covid","erasmusmc","elixir-europe","elixir-converge"],"former_affiliations":["deNBI","avans-atgm","uni-freiburg"],"contact_for_training":false,"location":{"country":"NL","lat":51.91,"lon":4.46},"id":"hexylena","url":"https://training.galaxyproject.org/training-material/api/contributors/hexylena.json","page":"https://training.galaxyproject.org/training-material/hall-of-fame/hexylena/"},{"name":"Bazante Sanders","joined":"2020-12","affiliations":["avans-atgm"],"id":"bazante1","url":"https://training.galaxyproject.org/training-material/api/contributors/bazante1.json","page":"https://training.galaxyproject.org/training-material/hall-of-fame/bazante1/"},{"name":"Gallantries: Bridging Training Communities in Life Science, Environment and Health","short_name":"Gallantries","start_date":"2020-09-01","end_date":"2023-09-30","joined":"2020-09","avatar":"https://gallantries.github.io/assets/images/gallantries-logo.png","github":false,"funder":true,"url":"https://training.galaxyproject.org/training-material/api/funders/gallantries.json","funder_name":"Erasmus+ Programme","funding_id":"2020-1-NL01-KA203-064717","funding_system":"erasmusplus","funding_statement":"This project (<a href=\"https://erasmus-plus.ec.europa.eu/projects/search/details/2020-1-NL01-KA203-064717\"><code class=\"language-plaintext highlighter-rouge\">2020-1-NL01-KA203-064717</code></a>) is funded with the support of the Erasmus+ programme of the European Union. Their funding has supported a large number of tutorials within the GTN across a wide array of topics.\n<img src=\"https://gallantries.github.io/assets/images/logosbeneficaireserasmusright_en.jpg\" alt=\"eu flag with the text: with the support of the erasmus programme of the european union\" />\n<img src=\"https://www.erasmusplus.nl/assets/images/logo.png\" alt=\"erasmus plus logo\" />","members":["abretaud","bebatut","colineroyaux","fpsom","hexylena","shiltemann","yvanlebras"],"id":"gallantries","page":"https://training.galaxyproject.org/training-material/hall-of-fame/gallantries/"},{"name":"Avans Hogeschool","joined":"2020-11","url":"https://training.galaxyproject.org/training-material/api/organisations/avans-atgm.json","avatar":"/training-material/shared/images/logo-avans.png","members":["bazante1"],"former_members":["dirowa","hexylena"],"id":"avans-atgm","page":"https://training.galaxyproject.org/training-material/hall-of-fame/avans-atgm/"}],"tags":["bash","jupyter-notebook"],"js_requirements":{"mathjax":null,"mermaid":false},"short_id":"T00074","url":"/topics/data-science/tutorials/cli-advanced/tutorial.html","topic_name":"data-science","tutorial_name":"cli-advanced","dir":"topics/data-science/tutorials/cli-advanced","symlink":null,"id":"data-science/cli-advanced","ref_tutorials":["<p>This tutorial will walk you through the basics of how to use the Unix command line.</p>\n\n<blockquote class=\"comment\">\n  <comment-title></comment-title>\n\n  <p>This tutorial is <strong>significantly</strong> based on <a href=\"https://carpentries.org\">the Carpentries</a> <a href=\"https://swcarpentry.github.io/shell-novice/\">“The Unix Shell”</a> lesson, which is licensed CC-BY 4.0. Adaptations have been made to make this work better in a GTN/Galaxy environment.</p>\n\n</blockquote>\n\n<blockquote class=\"agenda\">\n  <agenda-title></agenda-title>\n\n  <p>In this tutorial, we will cover:</p>\n\n<ol id=\"markdown-toc\">\n  <li><a href=\"#pipes-and-filtering\" id=\"markdown-toc-pipes-and-filtering\">Pipes and Filtering</a>    <ol>\n      <li><a href=\"#capturing-output-from-commands\" id=\"markdown-toc-capturing-output-from-commands\">Capturing output from commands</a></li>\n      <li><a href=\"#filtering-output\" id=\"markdown-toc-filtering-output\">Filtering output</a></li>\n      <li><a href=\"#solution\" id=\"markdown-toc-solution\">Solution</a></li>\n      <li><a href=\"#passing-output-to-another-command\" id=\"markdown-toc-passing-output-to-another-command\">Passing output to another command</a></li>\n      <li><a href=\"#combining-multiple-commands\" id=\"markdown-toc-combining-multiple-commands\">Combining multiple commands</a></li>\n      <li><a href=\"#tools-designed-to-work-together\" id=\"markdown-toc-tools-designed-to-work-together\">Tools designed to work together</a></li>\n      <li><a href=\"#nelles-pipeline-checking-files\" id=\"markdown-toc-nelles-pipeline-checking-files\">Nelle’s Pipeline: Checking Files</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#loops\" id=\"markdown-toc-loops\">Loops</a></li>\n  <li><a href=\"#dont-do-this\" id=\"markdown-toc-dont-do-this\">Don’t do this.</a>    <ol>\n      <li><a href=\"#nelles-pipeline-processing-files\" id=\"markdown-toc-nelles-pipeline-processing-files\">Nelle’s Pipeline: Processing Files</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#finding-things\" id=\"markdown-toc-finding-things\">Finding Things</a></li>\n  <li><a href=\"#final-notes\" id=\"markdown-toc-final-notes\">Final Notes</a></li>\n</ol>\n\n</blockquote>\n\n<h1 id=\"pipes-and-filtering\">Pipes and Filtering</h1>\n\n<p>Now that we know a few basic commands,\nwe can finally look at the shell’s most powerful feature:\nthe ease with which it lets us combine existing programs in new ways.\nWe’ll start with the directory called <code class=\"language-plaintext highlighter-rouge\">shell-lesson-data/molecules</code>\nthat contains six files describing some simple organic molecules.\nThe <code class=\"language-plaintext highlighter-rouge\">.pdb</code> extension indicates that these files are in Protein Data Bank format,\na simple text format that specifies the type and position of each atom in the molecule.</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">cd</span> ~/Desktop/shell-lesson-data/\n<span class=\"nb\">ls </span>molecules\n</code></pre></div></div>\n\n<p>Let’s go into that directory with <code class=\"language-plaintext highlighter-rouge\">cd</code> and run an example command <code class=\"language-plaintext highlighter-rouge\">wc cubane.pdb</code>:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">cd </span>molecules\n<span class=\"nb\">wc </span>cubane\n</code></pre></div></div>\n\n<p><code class=\"language-plaintext highlighter-rouge\">wc</code> is the ‘word count’ command:\nit counts the number of lines, words, and characters in files (from left to right, in that order).</p>\n\n<p>If we run the command <code class=\"language-plaintext highlighter-rouge\">wc *.pdb</code>, the <code class=\"language-plaintext highlighter-rouge\">*</code> in <code class=\"language-plaintext highlighter-rouge\">*.pdb</code> matches zero or more characters,\nso the shell turns <code class=\"language-plaintext highlighter-rouge\">*.pdb</code> into a list of all <code class=\"language-plaintext highlighter-rouge\">.pdb</code> files in the current directory:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">wc</span> <span class=\"k\">*</span>.pdb\n</code></pre></div></div>\n\n<p>Note that <code class=\"language-plaintext highlighter-rouge\">wc *.pdb</code> also shows the total number of all lines in the last line of the output.</p>\n\n<p>If we run <code class=\"language-plaintext highlighter-rouge\">wc -l</code> instead of just <code class=\"language-plaintext highlighter-rouge\">wc</code>,\nthe output shows only the number of lines per file:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">wc</span> <span class=\"nt\">-l</span> <span class=\"k\">*</span>.pdb\n</code></pre></div></div>\n\n<p>The <code class=\"language-plaintext highlighter-rouge\">-m</code> and <code class=\"language-plaintext highlighter-rouge\">-w</code> options can also be used with the <code class=\"language-plaintext highlighter-rouge\">wc</code> command, to show\nonly the number of characters or the number of words in the files.</p>\n\n<blockquote class=\"tip\">\n  <tip-title>Why Isn't It Doing Anything?</tip-title>\n\n  <p>What happens if a command is supposed to process a file, but we\ndon’t give it a filename? For example, what if we type:</p>\n\n  <div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nv\">$ </span><span class=\"nb\">wc</span> <span class=\"nt\">-l</span>\n</code></pre></div>  </div>\n\n  <p>but don’t type <code class=\"language-plaintext highlighter-rouge\">*.pdb</code> (or anything else) after the command?\nSince it doesn’t have any filenames, <code class=\"language-plaintext highlighter-rouge\">wc</code> assumes it is supposed to\nprocess input given at the command prompt, so it just sits there and waits for us to give\nit some data interactively. From the outside, though, all we see is it\nsitting there: the command doesn’t appear to do anything.</p>\n\n  <p>If you make this kind of mistake, you can escape out of this state by holding down\nthe control key (<kbd>Ctrl</kbd>) and typing the letter <kbd>C</kbd> once and\nletting go of the <kbd>Ctrl</kbd> key.\n<kbd>Ctrl</kbd>+<kbd>C</kbd></p>\n</blockquote>\n\n<h2 id=\"capturing-output-from-commands\">Capturing output from commands</h2>\n\n<p>Which of these files contains the fewest lines?\nIt’s an easy question to answer when there are only six files,\nbut what if there were 6000?\nOur first step toward a solution is to run the command:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">wc</span> <span class=\"nt\">-l</span> <span class=\"k\">*</span>.pdb <span class=\"o\">&gt;</span> lengths.txt\n</code></pre></div></div>\n\n<p>The greater than symbol, <code class=\"language-plaintext highlighter-rouge\">&gt;</code>, tells the shell to <strong>redirect</strong> the command’s output\nto a file instead of printing it to the screen. (This is why there is no screen output:\neverything that <code class=\"language-plaintext highlighter-rouge\">wc</code> would have printed has gone into the\nfile <code class=\"language-plaintext highlighter-rouge\">lengths.txt</code> instead.)  The shell will create\nthe file if it doesn’t exist. If the file exists, it will be\nsilently overwritten, which may lead to data loss and thus requires\nsome caution.</p>\n\n<blockquote class=\"tip\">\n  <tip-title>No <code>&gt;</code> on an AZERTY keyboard?</tip-title>\n  <p>You can rewrite this using the tee command which writes out a file, while also showing the output to <code class=\"language-plaintext highlighter-rouge\">stdout</code>.</p>\n  <div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">wc</span> <span class=\"nt\">-l</span> <span class=\"k\">*</span>.pdb | <span class=\"nb\">tee </span>lengths.txt\n</code></pre></div>  </div>\n  <p>Or you can use copy and paste to copy the <code class=\"language-plaintext highlighter-rouge\">&gt;</code> character from the materials.</p>\n</blockquote>\n\n<p><code class=\"language-plaintext highlighter-rouge\">ls lengths.txt</code> confirms that the file exists:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">ls </span>lengths.txt\n</code></pre></div></div>\n\n<p>We can now send the content of <code class=\"language-plaintext highlighter-rouge\">lengths.txt</code> to the screen using <code class=\"language-plaintext highlighter-rouge\">cat lengths.txt</code>.\nThe <code class=\"language-plaintext highlighter-rouge\">cat</code> command gets its name from ‘concatenate’ i.e. join together,\nand it prints the contents of files one after another.\nThere’s only one file in this case,\nso <code class=\"language-plaintext highlighter-rouge\">cat</code> just shows us what it contains:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">cat </span>lengths.txt\n</code></pre></div></div>\n\n<blockquote class=\"tip\">\n  <tip-title>Output Page by Page</tip-title>\n\n  <p>We’ll continue to use <code class=\"language-plaintext highlighter-rouge\">cat</code> in this lesson, for convenience and consistency,\nbut it has the disadvantage that it always dumps the whole file onto your screen.\nMore useful in practice is the command <code class=\"language-plaintext highlighter-rouge\">less</code>,\nwhich you use with <code class=\"language-plaintext highlighter-rouge\">less lengths.txt</code>.\nThis displays a screenful of the file, and then stops.\nYou can go forward one screenful by pressing the spacebar,\nor back one by pressing <code class=\"language-plaintext highlighter-rouge\">b</code>.  Press <code class=\"language-plaintext highlighter-rouge\">q</code> to quit.</p>\n</blockquote>\n\n<h2 id=\"filtering-output\">Filtering output</h2>\n\n<p>Next we’ll use the <code class=\"language-plaintext highlighter-rouge\">sort</code> command to sort the contents of the <code class=\"language-plaintext highlighter-rouge\">lengths.txt</code> file.\nBut first we’ll use an exercise to learn a little about the sort command:</p>\n\n<blockquote class=\"question\">\n  <question-title>What Does `sort -n` Do?</question-title>\n\n  <p>The file <code class=\"language-plaintext highlighter-rouge\">shell-lesson-data/numbers.txt</code>\ncontains the following lines:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>10\n2\n19\n22\n6\n</code></pre></div>  </div>\n\n  <p>If we run <code class=\"language-plaintext highlighter-rouge\">sort</code> on this file, the output is:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>10\n19\n2\n22\n6\n</code></pre></div>  </div>\n\n  <p>If we run <code class=\"language-plaintext highlighter-rouge\">sort -n</code> on the same file, we get this instead:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>2\n6\n10\n19\n22\n</code></pre></div>  </div>\n\n  <p>Explain why <code class=\"language-plaintext highlighter-rouge\">-n</code> has this effect.</p>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n    <p>The <code class=\"language-plaintext highlighter-rouge\">-n</code> option specifies a numerical rather than an alphanumerical sort.</p>\n  </blockquote>\n</blockquote>\n\n<p>We will also use the <code class=\"language-plaintext highlighter-rouge\">-n</code> option to specify that the sort is\nnumerical instead of alphanumerical.\nThis does <em>not</em> change the file;\ninstead, it sends the sorted result to the screen:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">sort</span> <span class=\"nt\">-n</span> lengths.txt\n</code></pre></div></div>\n\n<p>We can put the sorted list of lines in another temporary file called <code class=\"language-plaintext highlighter-rouge\">sorted-lengths.txt</code>\nby putting <code class=\"language-plaintext highlighter-rouge\">&gt; sorted-lengths.txt</code> after the command,\njust as we used <code class=\"language-plaintext highlighter-rouge\">&gt; lengths.txt</code> to put the output of <code class=\"language-plaintext highlighter-rouge\">wc</code> into <code class=\"language-plaintext highlighter-rouge\">lengths.txt</code>.\nOnce we’ve done that,\nwe can run another command called <code class=\"language-plaintext highlighter-rouge\">head</code> to get the first few lines in <code class=\"language-plaintext highlighter-rouge\">sorted-lengths.txt</code>:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">sort</span> <span class=\"nt\">-n</span> lengths.txt <span class=\"o\">&gt;</span> sorted-lengths.txt\n</code></pre></div></div>\n\n<p>Using <code class=\"language-plaintext highlighter-rouge\">-n 1</code> with <code class=\"language-plaintext highlighter-rouge\">head</code> tells it that\nwe only want the first line of the file;\n<code class=\"language-plaintext highlighter-rouge\">-n 20</code> would get the first 20,\nand so on.\nSince <code class=\"language-plaintext highlighter-rouge\">sorted-lengths.txt</code> contains the lengths of our files ordered from least to greatest,\nthe output of <code class=\"language-plaintext highlighter-rouge\">head</code> must be the file with the fewest lines.</p>\n\n<blockquote class=\"tip\">\n  <tip-title>Redirecting to the same file</tip-title>\n\n  <p>It’s a very bad idea to try redirecting\nthe output of a command that operates on a file\nto the same file. For example:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ sort -n lengths.txt &gt; lengths.txt\n</code></pre></div>  </div>\n\n  <p>Doing something like this may give you\nincorrect results and/or delete\nthe contents of <code class=\"language-plaintext highlighter-rouge\">lengths.txt</code>.</p>\n</blockquote>\n\n<blockquote class=\"question\">\n  <question-title>What Does `&gt;&gt;` Mean?</question-title>\n\n  <p>We have seen the use of <code class=\"language-plaintext highlighter-rouge\">&gt;</code>, but there is a similar operator <code class=\"language-plaintext highlighter-rouge\">&gt;&gt;</code>\nwhich works slightly differently.\nWe’ll learn about the differences between these two operators by printing some strings.\nWe can use the <code class=\"language-plaintext highlighter-rouge\">echo</code> command to print strings e.g.</p>\n\n  <blockquote class=\"code-in\">\n    <code-in-title>Bash</code-in-title>\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ echo The echo command prints text\n</code></pre></div>    </div>\n  </blockquote>\n\n  <blockquote class=\"code-out\">\n    <code-out-title></code-out-title>\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>The echo command prints text\n</code></pre></div>    </div>\n  </blockquote>\n\n  <p>Now test the commands below to reveal the difference between the two operators:</p>\n\n  <blockquote class=\"code-in\">\n    <code-in-title>Bash</code-in-title>\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ echo hello &gt; testfile01.txt\n</code></pre></div>    </div>\n  </blockquote>\n\n  <p>and:</p>\n\n  <blockquote class=\"code-in\">\n    <code-in-title>Bash</code-in-title>\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ echo hello &gt;&gt; testfile02.txt\n</code></pre></div>    </div>\n  </blockquote>\n\n  <p><strong>Hint</strong>: Try executing each command twice in a row and then examining the output files.</p>\n\n  <blockquote class=\"solution\">\n    <h2 id=\"solution\">Solution</h2>\n    <p>In the first example with <code class=\"language-plaintext highlighter-rouge\">&gt;</code>, the string ‘hello’ is written to <code class=\"language-plaintext highlighter-rouge\">testfile01.txt</code>,\nbut the file gets overwritten each time we run the command.</p>\n\n    <p>We see from the second example that the <code class=\"language-plaintext highlighter-rouge\">&gt;&gt;</code> operator also writes ‘hello’ to a file\n(in this case<code class=\"language-plaintext highlighter-rouge\">testfile02.txt</code>),\nbut appends the string to the file if it already exists\n(i.e. when we run it for the second time).</p>\n  </blockquote>\n</blockquote>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Explore the possible solutions here!</span>\n</code></pre></div></div>\n\n<blockquote class=\"question\">\n  <question-title>Appending Data</question-title>\n\n  <p>We have already met the <code class=\"language-plaintext highlighter-rouge\">head</code> command, which prints lines from the start of a file.\n<code class=\"language-plaintext highlighter-rouge\">tail</code> is similar, but prints lines from the end of a file instead.</p>\n\n  <p>Consider the file <code class=\"language-plaintext highlighter-rouge\">shell-lesson-data/data/animals.txt</code>.\nAfter these commands, select the answer that\ncorresponds to the file <code class=\"language-plaintext highlighter-rouge\">animals-subset.txt</code>:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ head -n 3 animals.txt &gt; animals-subset.txt\n$ tail -n 2 animals.txt &gt;&gt; animals-subset.txt\n</code></pre></div>  </div>\n\n  <ol>\n    <li>The first three lines of <code class=\"language-plaintext highlighter-rouge\">animals.txt</code></li>\n    <li>The last two lines of <code class=\"language-plaintext highlighter-rouge\">animals.txt</code></li>\n    <li>The first three lines and the last two lines of <code class=\"language-plaintext highlighter-rouge\">animals.txt</code></li>\n    <li>The second and third lines of <code class=\"language-plaintext highlighter-rouge\">animals.txt</code></li>\n  </ol>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n    <p>Option 3 is correct.\nFor option 1 to be correct we would only run the <code class=\"language-plaintext highlighter-rouge\">head</code> command.\nFor option 2 to be correct we would only run the <code class=\"language-plaintext highlighter-rouge\">tail</code> command.\nFor option 4 to be correct we would have to pipe the output of <code class=\"language-plaintext highlighter-rouge\">head</code> into <code class=\"language-plaintext highlighter-rouge\">tail -n 2</code>\nby doing <code class=\"language-plaintext highlighter-rouge\">head -n 3 animals.txt | tail -n 2 &gt; animals-subset.txt</code></p>\n  </blockquote>\n</blockquote>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Explore the possible solutions here!</span>\n</code></pre></div></div>\n\n<h2 id=\"passing-output-to-another-command\">Passing output to another command</h2>\n<p>In our example of finding the file with the fewest lines,\nwe are using two intermediate files <code class=\"language-plaintext highlighter-rouge\">lengths.txt</code> and <code class=\"language-plaintext highlighter-rouge\">sorted-lengths.txt</code> to store output.\nThis is a confusing way to work because\neven once you understand what <code class=\"language-plaintext highlighter-rouge\">wc</code>, <code class=\"language-plaintext highlighter-rouge\">sort</code>, and <code class=\"language-plaintext highlighter-rouge\">head</code> do,\nthose intermediate files make it hard to follow what’s going on.\nWe can make it easier to understand by running <code class=\"language-plaintext highlighter-rouge\">sort</code> and <code class=\"language-plaintext highlighter-rouge\">head</code> together:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">sort</span> <span class=\"nt\">-n</span> lengths.txt | <span class=\"nb\">head</span> <span class=\"nt\">-n</span> 1\n</code></pre></div></div>\n\n<p>The vertical bar, <code class=\"language-plaintext highlighter-rouge\">|</code>, between the two commands is called a <strong>pipe</strong>.\nIt tells the shell that we want to use\nthe output of the command on the left\nas the input to the command on the right.</p>\n\n<p>This has removed the need for the <code class=\"language-plaintext highlighter-rouge\">sorted-lengths.txt</code> file.</p>\n\n<h2 id=\"combining-multiple-commands\">Combining multiple commands</h2>\n<p>Nothing prevents us from chaining pipes consecutively.\nWe can for example send the output of <code class=\"language-plaintext highlighter-rouge\">wc</code> directly to <code class=\"language-plaintext highlighter-rouge\">sort</code>,\nand then the resulting output to <code class=\"language-plaintext highlighter-rouge\">head</code>.\nThis removes the need for any intermediate files.</p>\n\n<p>We’ll start by using a pipe to send the output of <code class=\"language-plaintext highlighter-rouge\">wc</code> to <code class=\"language-plaintext highlighter-rouge\">sort</code>:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">wc</span> <span class=\"nt\">-l</span> <span class=\"k\">*</span>.pdb | <span class=\"nb\">sort</span> <span class=\"nt\">-n</span>\n</code></pre></div></div>\n\n<p>We can then send that output through another pipe, to <code class=\"language-plaintext highlighter-rouge\">head</code>, so that the full pipeline becomes:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">wc</span> <span class=\"nt\">-l</span> <span class=\"k\">*</span>.pdb | <span class=\"nb\">sort</span> <span class=\"nt\">-n</span> | <span class=\"nb\">head</span> <span class=\"nt\">-n</span> 1\n</code></pre></div></div>\n\n<p>This is exactly like a mathematician nesting functions like <em>log(3x)</em>\nand saying ‘the log of three times <em>x</em>’.\nIn our case,\nthe calculation is ‘head of sort of line count of <code class=\"language-plaintext highlighter-rouge\">*.pdb</code>’.</p>\n\n<p>The redirection and pipes used in the last few commands are illustrated below:</p>\n\n<p><a href=\"../../images/carpentries-cli/redirects-and-pipes.svg\" rel=\"noopener noreferrer\"><img src=\"../../images/carpentries-cli/redirects-and-pipes.svg\" alt=\"Redirects and Pipes of different commands. \" width=\"800\" height=\"560\" loading=\"lazy\" /></a></p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">wc -l *.pdb</code> will direct the output to the shell. <code class=\"language-plaintext highlighter-rouge\">wc -l *.pdb &gt; lengths</code> will\ndirect output to the file lengths. <code class=\"language-plaintext highlighter-rouge\">wc -l *.pdb | sort -n | head -n 1</code> will\nbuild a pipeline where the output of the wc command is the input to the sort\ncommand, the output of the sort command is the input to the head command and\nthe output of the head command is directed to the shell</p>\n\n<blockquote class=\"question\">\n  <question-title>Piping Commands Together</question-title>\n\n  <p>In our current directory, we want to find the 3 files which have the least number of\nlines. Which command listed below would work?</p>\n\n  <ol>\n    <li><code class=\"language-plaintext highlighter-rouge\">wc -l * &gt; sort -n &gt; head -n 3</code></li>\n    <li><code class=\"language-plaintext highlighter-rouge\">wc -l * | sort -n | head -n 1-3</code></li>\n    <li><code class=\"language-plaintext highlighter-rouge\">wc -l * | head -n 3 | sort -n</code></li>\n    <li><code class=\"language-plaintext highlighter-rouge\">wc -l * | sort -n | head -n 3</code></li>\n  </ol>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n    <p>Option 4 is the solution.\nThe pipe character <code class=\"language-plaintext highlighter-rouge\">|</code> is used to connect the output from one command to\nthe input of another.\n<code class=\"language-plaintext highlighter-rouge\">&gt;</code> is used to redirect standard output to a file.\nTry it in the <code class=\"language-plaintext highlighter-rouge\">shell-lesson-data/molecules</code> directory!</p>\n  </blockquote>\n</blockquote>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Explore the possible solutions here!</span>\n</code></pre></div></div>\n\n<h2 id=\"tools-designed-to-work-together\">Tools designed to work together</h2>\n<p>This idea of linking programs together is why Unix has been so successful.\nInstead of creating enormous programs that try to do many different things,\nUnix programmers focus on creating lots of simple tools that each do one job well,\nand that work well with each other.\nThis programming model is called ‘pipes and filters’.\nWe’ve already seen pipes;\na <strong>filter</strong> is a program like <code class=\"language-plaintext highlighter-rouge\">wc</code> or <code class=\"language-plaintext highlighter-rouge\">sort</code>\nthat transforms a stream of input into a stream of output.\nAlmost all of the standard Unix tools can work this way:\nunless told to do otherwise,\nthey read from standard input,\ndo something with what they’ve read,\nand write to standard output.</p>\n\n<p>The key is that any program that reads lines of text from standard input\nand writes lines of text to standard output\ncan be combined with every other program that behaves this way as well.\nYou can <em>and should</em> write your programs this way\nso that you and other people can put those programs into pipes to multiply their power.</p>\n\n<blockquote class=\"question\">\n  <question-title>Pipe Reading Comprehension</question-title>\n\n  <p>A file called <code class=\"language-plaintext highlighter-rouge\">animals.txt</code> (in the <code class=\"language-plaintext highlighter-rouge\">shell-lesson-data/data</code> folder) contains the following data:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>2012-11-05,deer\n2012-11-05,rabbit\n2012-11-05,raccoon\n2012-11-06,rabbit\n2012-11-06,deer\n2012-11-06,fox\n2012-11-07,rabbit\n2012-11-07,bear\n</code></pre></div>  </div>\n\n  <p>What text passes through each of the pipes and the final redirect in the pipeline below?</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ cat animals.txt | head -n 5 | tail -n 3 | sort -r &gt; final.txt\n</code></pre></div>  </div>\n\n  <p>Hint: build the pipeline up one command at a time to test your understanding</p>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n    <p>The <code class=\"language-plaintext highlighter-rouge\">head</code> command extracts the first 5 lines from <code class=\"language-plaintext highlighter-rouge\">animals.txt</code>.\nThen, the last 3 lines are extracted from the previous 5 by using the <code class=\"language-plaintext highlighter-rouge\">tail</code> command.\nWith the <code class=\"language-plaintext highlighter-rouge\">sort -r</code> command those 3 lines are sorted in reverse order and finally,\nthe output is redirected to a file <code class=\"language-plaintext highlighter-rouge\">final.txt</code>.\nThe content of this file can be checked by executing <code class=\"language-plaintext highlighter-rouge\">cat final.txt</code>.\nThe file should contain the following lines:</p>\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>2012-11-06,rabbit\n2012-11-06,deer\n2012-11-05,raccoon\n</code></pre></div>    </div>\n  </blockquote>\n</blockquote>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Explore the possible solutions here!</span>\n</code></pre></div></div>\n\n<blockquote class=\"question\">\n  <question-title>Pipe Construction</question-title>\n\n  <p>For the file <code class=\"language-plaintext highlighter-rouge\">animals.txt</code> from the previous exercise, consider the following command:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ cut -d , -f 2 animals.txt\n</code></pre></div>  </div>\n\n  <p>The <code class=\"language-plaintext highlighter-rouge\">cut</code> command is used to remove or ‘cut out’ certain sections of each line in the file,\nand <code class=\"language-plaintext highlighter-rouge\">cut</code> expects the lines to be separated into columns by a <kbd>Tab</kbd> character.\nA character used in this way is a called a <strong>delimiter</strong>.\nIn the example above we use the <code class=\"language-plaintext highlighter-rouge\">-d</code> option to specify the comma as our delimiter character.\nWe have also used the <code class=\"language-plaintext highlighter-rouge\">-f</code> option to specify that we want to extract the second field (column).\nThis gives the following output:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>deer\nrabbit\nraccoon\nrabbit\ndeer\nfox\nrabbit\nbear\n</code></pre></div>  </div>\n\n  <p>The <code class=\"language-plaintext highlighter-rouge\">uniq</code> command filters out adjacent matching lines in a file.\nHow could you extend this pipeline (using <code class=\"language-plaintext highlighter-rouge\">uniq</code> and another command) to find\nout what animals the file contains (without any duplicates in their\nnames)?</p>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ cut -d , -f 2 animals.txt | sort | uniq\n</code></pre></div>    </div>\n  </blockquote>\n</blockquote>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Explore the possible solutions here!</span>\n</code></pre></div></div>\n\n<blockquote class=\"question\">\n  <question-title>Which Pipe?</question-title>\n\n  <p>The file <code class=\"language-plaintext highlighter-rouge\">animals.txt</code> contains 8 lines of data formatted as follows:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>2012-11-05,deer\n2012-11-05,rabbit\n2012-11-05,raccoon\n2012-11-06,rabbit\n...\n</code></pre></div>  </div>\n\n  <p>The <code class=\"language-plaintext highlighter-rouge\">uniq</code> command has a <code class=\"language-plaintext highlighter-rouge\">-c</code> option which gives a count of the\nnumber of times a line occurs in its input.  Assuming your current\ndirectory is <code class=\"language-plaintext highlighter-rouge\">shell-lesson-data/data/</code>, what command would you use to produce\na table that shows the total count of each type of animal in the file?</p>\n\n  <ol>\n    <li><code class=\"language-plaintext highlighter-rouge\">sort animals.txt | uniq -c</code></li>\n    <li><code class=\"language-plaintext highlighter-rouge\">sort -t, -k2,2 animals.txt | uniq -c</code></li>\n    <li><code class=\"language-plaintext highlighter-rouge\">cut -d, -f 2 animals.txt | uniq -c</code></li>\n    <li><code class=\"language-plaintext highlighter-rouge\">cut -d, -f 2 animals.txt | sort | uniq -c</code></li>\n    <li><code class=\"language-plaintext highlighter-rouge\">cut -d, -f 2 animals.txt | sort | uniq -c | wc -l</code></li>\n  </ol>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n    <p>Option 4. is the correct answer.\nIf you have difficulty understanding why, try running the commands, or sub-sections of\nthe pipelines (make sure you are in the <code class=\"language-plaintext highlighter-rouge\">shell-lesson-data/data</code> directory).</p>\n  </blockquote>\n</blockquote>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Explore the possible solutions here!</span>\n</code></pre></div></div>\n\n<h2 id=\"nelles-pipeline-checking-files\">Nelle’s Pipeline: Checking Files</h2>\n\n<p>Nelle has run her samples through the assay machines\nand created 17 files in the <code class=\"language-plaintext highlighter-rouge\">north-pacific-gyre/2012-07-03</code> directory described earlier.\nAs a quick check, starting from her home directory, Nelle types:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">cd</span> ~/Desktop/shell-lesson-data/north-pacific-gyre/2012-07-03\n<span class=\"nb\">wc</span> <span class=\"nt\">-l</span> <span class=\"k\">*</span>.txt\n</code></pre></div></div>\n\n<p>The output is 18 lines that look like this:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>300 NENE01729A.txt\n300 NENE01729B.txt\n300 NENE01736A.txt\n300 NENE01751A.txt\n300 NENE01751B.txt\n300 NENE01812A.txt\n... ...\n</code></pre></div></div>\n\n<p>Now she types this:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">wc</span> <span class=\"nt\">-l</span> <span class=\"k\">*</span>.txt | <span class=\"nb\">sort</span> <span class=\"nt\">-n</span> | <span class=\"nb\">head</span> <span class=\"nt\">-n</span> 5\n</code></pre></div></div>\n\n<p>Whoops: one of the files is 60 lines shorter than the others.\nWhen she goes back and checks it,\nshe sees that she did that assay at 8:00 on a Monday morning — someone\nwas probably in using the machine on the weekend,\nand she forgot to reset it.\nBefore re-running that sample,\nshe checks to see if any files have too much data:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">wc</span> <span class=\"nt\">-l</span> <span class=\"k\">*</span>.txt | <span class=\"nb\">sort</span> <span class=\"nt\">-n</span> | <span class=\"nb\">tail</span> <span class=\"nt\">-n</span> 5\n</code></pre></div></div>\n\n<p>Those numbers look good — but what’s that ‘Z’ doing there in the third-to-last line?\nAll of her samples should be marked ‘A’ or ‘B’;\nby convention,\nher lab uses ‘Z’ to indicate samples with missing information.\nTo find others like it, she does this:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">ls</span> <span class=\"k\">*</span>Z.txt\n</code></pre></div></div>\n\n<p>Sure enough,\nwhen she checks the log on her laptop,\nthere’s no depth recorded for either of those samples.\nSince it’s too late to get the information any other way,\nshe must exclude those two files from her analysis.\nShe could delete them using <code class=\"language-plaintext highlighter-rouge\">rm</code>,\nbut there are actually some analyses she might do later where depth doesn’t matter,\nso instead, she’ll have to be careful later on to select files using the wildcard expressions\n<code class=\"language-plaintext highlighter-rouge\">NENE*A.txt NENE*B.txt</code>.</p>\n\n<blockquote class=\"question\">\n  <question-title>Removing Unneeded Files</question-title>\n\n  <p>Suppose you want to delete your processed data files, and only keep\nyour raw files and processing script to save storage.\nThe raw files end in <code class=\"language-plaintext highlighter-rouge\">.dat</code> and the processed files end in <code class=\"language-plaintext highlighter-rouge\">.txt</code>.\nWhich of the following would remove all the processed data files,\nand <em>only</em> the processed data files?</p>\n\n  <ol>\n    <li><code class=\"language-plaintext highlighter-rouge\">rm ?.txt</code></li>\n    <li><code class=\"language-plaintext highlighter-rouge\">rm *.txt</code></li>\n    <li><code class=\"language-plaintext highlighter-rouge\">rm * .txt</code></li>\n    <li><code class=\"language-plaintext highlighter-rouge\">rm *.*</code></li>\n  </ol>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n    <ol>\n      <li>This would remove <code class=\"language-plaintext highlighter-rouge\">.txt</code> files with one-character names</li>\n      <li>This is correct answer</li>\n      <li>The shell would expand <code class=\"language-plaintext highlighter-rouge\">*</code> to match everything in the current directory,\nso the command would try to remove all matched files and an additional\nfile called <code class=\"language-plaintext highlighter-rouge\">.txt</code></li>\n      <li>The shell would expand <code class=\"language-plaintext highlighter-rouge\">*.*</code> to match all files with any extension,\nso this command would delete all files</li>\n    </ol>\n  </blockquote>\n</blockquote>\n\n<h1 id=\"loops\">Loops</h1>\n\n<p><strong>Loops</strong> are a programming construct which allow us to repeat a command or set of commands\nfor each item in a list.\nAs such they are key to productivity improvements through automation.\nSimilar to wildcards and tab completion, using loops also reduces the\namount of typing required (and hence reduces the number of typing mistakes).</p>\n\n<p>Suppose we have several hundred genome data files named <code class=\"language-plaintext highlighter-rouge\">basilisk.dat</code>, <code class=\"language-plaintext highlighter-rouge\">minotaur.dat</code>, and\n<code class=\"language-plaintext highlighter-rouge\">unicorn.dat</code>.\nFor this example, we’ll use the <code class=\"language-plaintext highlighter-rouge\">creatures</code> directory which only has three example files,\nbut the principles can be applied to many many more files at once. First, go\ninto the creatures directory.</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Change directories here!</span>\n\n</code></pre></div></div>\n\n<p>The structure of these files is the same: the common name, classification, and updated date are\npresented on the first three lines, with DNA sequences on the following lines.\nLet’s look at the files:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">head</span> <span class=\"nt\">-n</span> 5 basilisk.dat minotaur.dat unicorn.dat\n</code></pre></div></div>\n\n<p>We would like to print out the classification for each species, which is given on the second\nline of each file.\nFor each file, we would need to execute the command <code class=\"language-plaintext highlighter-rouge\">head -n 2</code> and pipe this to <code class=\"language-plaintext highlighter-rouge\">tail -n 1</code>.\nWe’ll use a loop to solve this problem, but first let’s look at the general form of a loop:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for thing in list_of_things\ndo\n    operation_using $thing    # Indentation within the loop is not required, but aids legibility\ndone\n</code></pre></div></div>\n\n<p>and we can apply this to our example like this:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">for </span>filename <span class=\"k\">in </span>basilisk.dat minotaur.dat unicorn.dat\n<span class=\"k\">do\n    </span><span class=\"nb\">head</span> <span class=\"nt\">-n</span> 2 <span class=\"nv\">$filename</span> | <span class=\"nb\">tail</span> <span class=\"nt\">-n</span> 1\n<span class=\"k\">done</span>\n</code></pre></div></div>\n\n<blockquote class=\"tip\">\n  <tip-title>Follow the Prompt</tip-title>\n\n  <p>The shell prompt changes from <code class=\"language-plaintext highlighter-rouge\">$</code> to <code class=\"language-plaintext highlighter-rouge\">&gt;</code> and back again as we were\ntyping in our loop. The second prompt, <code class=\"language-plaintext highlighter-rouge\">&gt;</code>, is different to remind\nus that we haven’t finished typing a complete command yet. A semicolon, <code class=\"language-plaintext highlighter-rouge\">;</code>,\ncan be used to separate two commands written on a single line.</p>\n</blockquote>\n\n<p>When the shell sees the keyword <code class=\"language-plaintext highlighter-rouge\">for</code>,\nit knows to repeat a command (or group of commands) once for each item in a list.\nEach time the loop runs (called an iteration), an item in the list is assigned in sequence to\nthe <strong>variable</strong>, and the commands inside the loop are executed, before moving on to\nthe next item in the list.\nInside the loop,\nwe call for the variable’s value by putting <code class=\"language-plaintext highlighter-rouge\">$</code> in front of it.\nThe <code class=\"language-plaintext highlighter-rouge\">$</code> tells the shell interpreter to treat\nthe variable as a variable name and substitute its value in its place,\nrather than treat it as text or an external command.</p>\n\n<p>In this example, the list is three filenames: <code class=\"language-plaintext highlighter-rouge\">basilisk.dat</code>, <code class=\"language-plaintext highlighter-rouge\">minotaur.dat</code>, and <code class=\"language-plaintext highlighter-rouge\">unicorn.dat</code>.\nEach time the loop iterates, it will assign a file name to the variable <code class=\"language-plaintext highlighter-rouge\">filename</code>\nand run the <code class=\"language-plaintext highlighter-rouge\">head</code> command.\nThe first time through the loop,\n<code class=\"language-plaintext highlighter-rouge\">$filename</code> is <code class=\"language-plaintext highlighter-rouge\">basilisk.dat</code>.\nThe interpreter runs the command <code class=\"language-plaintext highlighter-rouge\">head</code> on <code class=\"language-plaintext highlighter-rouge\">basilisk.dat</code>\nand pipes the first two lines to the <code class=\"language-plaintext highlighter-rouge\">tail</code> command,\nwhich then prints the second line of <code class=\"language-plaintext highlighter-rouge\">basilisk.dat</code>.\nFor the second iteration, <code class=\"language-plaintext highlighter-rouge\">$filename</code> becomes\n<code class=\"language-plaintext highlighter-rouge\">minotaur.dat</code>. This time, the shell runs <code class=\"language-plaintext highlighter-rouge\">head</code> on <code class=\"language-plaintext highlighter-rouge\">minotaur.dat</code>\nand pipes the first two lines to the <code class=\"language-plaintext highlighter-rouge\">tail</code> command,\nwhich then prints the second line of <code class=\"language-plaintext highlighter-rouge\">minotaur.dat</code>.\nFor the third iteration, <code class=\"language-plaintext highlighter-rouge\">$filename</code> becomes\n<code class=\"language-plaintext highlighter-rouge\">unicorn.dat</code>, so the shell runs the <code class=\"language-plaintext highlighter-rouge\">head</code> command on that file,\nand <code class=\"language-plaintext highlighter-rouge\">tail</code> on the output of that.\nSince the list was only three items, the shell exits the <code class=\"language-plaintext highlighter-rouge\">for</code> loop.</p>\n\n<blockquote class=\"tip\">\n  <tip-title>Same Symbols, Different Meanings</tip-title>\n\n  <p>Here we see <code class=\"language-plaintext highlighter-rouge\">&gt;</code> being used as a shell prompt, whereas <code class=\"language-plaintext highlighter-rouge\">&gt;</code> is also\nused to redirect output.\nSimilarly, <code class=\"language-plaintext highlighter-rouge\">$</code> is used as a shell prompt, but, as we saw earlier,\nit is also used to ask the shell to get the value of a variable.</p>\n\n  <p>If the <em>shell</em> prints <code class=\"language-plaintext highlighter-rouge\">&gt;</code> or <code class=\"language-plaintext highlighter-rouge\">$</code> then it expects you to type something,\nand the symbol is a prompt.</p>\n\n  <p>If <em>you</em> type <code class=\"language-plaintext highlighter-rouge\">&gt;</code> or <code class=\"language-plaintext highlighter-rouge\">$</code> yourself, it is an instruction from you that\nthe shell should redirect output or get the value of a variable.</p>\n</blockquote>\n\n<p>When using variables it is also\npossible to put the names into curly braces to clearly delimit the variable\nname: <code class=\"language-plaintext highlighter-rouge\">$filename</code> is equivalent to <code class=\"language-plaintext highlighter-rouge\">${filename}</code>, but is different from\n<code class=\"language-plaintext highlighter-rouge\">${file}name</code>. You may find this notation in other people’s programs.</p>\n\n<p>We have called the variable in this loop <code class=\"language-plaintext highlighter-rouge\">filename</code>\nin order to make its purpose clearer to human readers.\nThe shell itself doesn’t care what the variable is called;\nif we wrote this loop as:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">for </span>x <span class=\"k\">in </span>basilisk.dat minotaur.dat unicorn.dat\n<span class=\"k\">do\n    </span><span class=\"nb\">head</span> <span class=\"nt\">-n</span> 2 <span class=\"nv\">$x</span> | <span class=\"nb\">tail</span> <span class=\"nt\">-n</span> 1\n<span class=\"k\">done</span>\n</code></pre></div></div>\n\n<p>or:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">for </span>temperature <span class=\"k\">in </span>basilisk.dat minotaur.dat unicorn.dat\n<span class=\"k\">do\n    </span><span class=\"nb\">head</span> <span class=\"nt\">-n</span> 2 <span class=\"nv\">$temperature</span> | <span class=\"nb\">tail</span> <span class=\"nt\">-n</span> 1\n<span class=\"k\">done</span>\n</code></pre></div></div>\n\n<p>it would work exactly the same way.</p>\n\n<h1 id=\"dont-do-this\">Don’t do this.</h1>\n\n<p>Programs are only useful if people can understand them,\nso meaningless names (like <code class=\"language-plaintext highlighter-rouge\">x</code>) or misleading names (like <code class=\"language-plaintext highlighter-rouge\">temperature</code>)\nincrease the odds that the program won’t do what its readers think it does.</p>\n\n<blockquote class=\"question\">\n  <question-title>Variables in Loops</question-title>\n\n  <p>This exercise refers to the <code class=\"language-plaintext highlighter-rouge\">shell-lesson-data/molecules</code> directory.\n<code class=\"language-plaintext highlighter-rouge\">ls</code> gives the following output:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n</code></pre></div>  </div>\n\n  <p>What is the output of the following code?</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for datafile in *.pdb\ndo\n    ls *.pdb\ndone\n</code></pre></div>  </div>\n\n  <p>Now, what is the output of the following code?</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for datafile in *.pdb\ndo\n   ls $datafile\ndone\n</code></pre></div>  </div>\n\n  <p>Why do these two loops give different outputs?</p>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n    <p>The first code block gives the same output on each iteration through\nthe loop.\nBash expands the wildcard <code class=\"language-plaintext highlighter-rouge\">*.pdb</code> within the loop body (as well as\nbefore the loop starts) to match all files ending in <code class=\"language-plaintext highlighter-rouge\">.pdb</code>\nand then lists them using <code class=\"language-plaintext highlighter-rouge\">ls</code>.\nThe expanded loop would look like this:</p>\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ for datafile in cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n&gt; do\n&gt;     ls cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n&gt; done\n</code></pre></div>    </div>\n\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\ncubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\ncubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\ncubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\ncubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\ncubane.pdb  ethane.pdb  methane.pdb  octane.pdb  pentane.pdb  propane.pdb\n</code></pre></div>    </div>\n\n    <p>The second code block lists a different file on each loop iteration.\nThe value of the <code class=\"language-plaintext highlighter-rouge\">datafile</code> variable is evaluated using <code class=\"language-plaintext highlighter-rouge\">$datafile</code>,\nand then listed using <code class=\"language-plaintext highlighter-rouge\">ls</code>.</p>\n\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cubane.pdb\nethane.pdb\nmethane.pdb\noctane.pdb\npentane.pdb\npropane.pdb\n</code></pre></div>    </div>\n  </blockquote>\n</blockquote>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Explore the possible solutions here!</span>\n</code></pre></div></div>\n\n<blockquote class=\"question\">\n  <question-title>Limiting Sets of Files</question-title>\n\n  <p>What would be the output of running the following loop in thei\n<code class=\"language-plaintext highlighter-rouge\">shell-lesson-data/molecules</code> directory?</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for filename in c*\ndo\n    ls $filename\ndone\n</code></pre></div>  </div>\n\n  <ol>\n    <li>No files are listed.</li>\n    <li>All files are listed.</li>\n    <li>Only <code class=\"language-plaintext highlighter-rouge\">cubane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">octane.pdb</code> and <code class=\"language-plaintext highlighter-rouge\">pentane.pdb</code> are listed.</li>\n    <li>Only <code class=\"language-plaintext highlighter-rouge\">cubane.pdb</code> is listed.</li>\n  </ol>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n    <p>4 is the correct answer. <code class=\"language-plaintext highlighter-rouge\">*</code> matches zero or more characters, so any file name starting with\nthe letter c, followed by zero or more other characters will be matched.</p>\n  </blockquote>\n\n  <p>How would the output differ from using this command instead?</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for filename in *c*\ndo\n    ls $filename\ndone\n</code></pre></div>  </div>\n\n  <ol>\n    <li>The same files would be listed.</li>\n    <li>All the files are listed this time.</li>\n    <li>No files are listed this time.</li>\n    <li>The files <code class=\"language-plaintext highlighter-rouge\">cubane.pdb</code> and <code class=\"language-plaintext highlighter-rouge\">octane.pdb</code> will be listed.</li>\n    <li>Only the file <code class=\"language-plaintext highlighter-rouge\">octane.pdb</code> will be listed.</li>\n  </ol>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n    <p>4 is the correct answer. <code class=\"language-plaintext highlighter-rouge\">*</code> matches zero or more characters, so a file name with zero or more\ncharacters before a letter c and zero or more characters after the letter c will be matched.</p>\n  </blockquote>\n</blockquote>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Explore the possible solutions here!</span>\n</code></pre></div></div>\n\n<blockquote class=\"question\">\n  <question-title>Saving to a File in a Loop - Part One</question-title>\n\n  <p>In the <code class=\"language-plaintext highlighter-rouge\">shell-lesson-data/molecules</code> directory, what is the effect of this loop?</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for alkanes in *.pdb\ndo\n    echo $alkanes\n    cat $alkanes &gt; alkanes.pdb\ndone\n</code></pre></div>  </div>\n\n  <ol>\n    <li>Prints <code class=\"language-plaintext highlighter-rouge\">cubane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">ethane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">methane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">octane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">pentane.pdb</code> and\n   <code class=\"language-plaintext highlighter-rouge\">propane.pdb</code>, and the text from <code class=\"language-plaintext highlighter-rouge\">propane.pdb</code> will be saved to a file called <code class=\"language-plaintext highlighter-rouge\">alkanes.pdb</code>.</li>\n    <li>Prints <code class=\"language-plaintext highlighter-rouge\">cubane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">ethane.pdb</code>, and <code class=\"language-plaintext highlighter-rouge\">methane.pdb</code>, and the text from all three files\nwould be concatenated and saved to a file called <code class=\"language-plaintext highlighter-rouge\">alkanes.pdb</code>.</li>\n    <li>Prints <code class=\"language-plaintext highlighter-rouge\">cubane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">ethane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">methane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">octane.pdb</code>, and <code class=\"language-plaintext highlighter-rouge\">pentane.pdb</code>,\nand the text from <code class=\"language-plaintext highlighter-rouge\">propane.pdb</code> will be saved to a file called <code class=\"language-plaintext highlighter-rouge\">alkanes.pdb</code>.</li>\n    <li>None of the above.</li>\n  </ol>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n    <p>1 is correct. The text from each file in turn gets written to the <code class=\"language-plaintext highlighter-rouge\">alkanes.pdb</code> file.\nHowever, the file gets overwritten on each loop iteration, so the final content of <code class=\"language-plaintext highlighter-rouge\">alkanes.pdb</code>\nis the text from the <code class=\"language-plaintext highlighter-rouge\">propane.pdb</code> file.</p>\n  </blockquote>\n</blockquote>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Explore the possible solutions here!</span>\n</code></pre></div></div>\n\n<blockquote class=\"question\">\n  <question-title>Saving to a File in a Loop - Part Two</question-title>\n\n  <p>Also in the <code class=\"language-plaintext highlighter-rouge\">shell-lesson-data/molecules</code> directory,\nwhat would be the output of the following loop?</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for datafile in *.pdb\ndo\n    cat $datafile &gt;&gt; all.pdb\ndone\n</code></pre></div>  </div>\n\n  <ol>\n    <li>All of the text from <code class=\"language-plaintext highlighter-rouge\">cubane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">ethane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">methane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">octane.pdb</code>, and\n<code class=\"language-plaintext highlighter-rouge\">pentane.pdb</code> would be concatenated and saved to a file called <code class=\"language-plaintext highlighter-rouge\">all.pdb</code>.</li>\n    <li>The text from <code class=\"language-plaintext highlighter-rouge\">ethane.pdb</code> will be saved to a file called <code class=\"language-plaintext highlighter-rouge\">all.pdb</code>.</li>\n    <li>All of the text from <code class=\"language-plaintext highlighter-rouge\">cubane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">ethane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">methane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">octane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">pentane.pdb</code>\nand <code class=\"language-plaintext highlighter-rouge\">propane.pdb</code> would be concatenated and saved to a file called <code class=\"language-plaintext highlighter-rouge\">all.pdb</code>.</li>\n    <li>All of the text from <code class=\"language-plaintext highlighter-rouge\">cubane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">ethane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">methane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">octane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">pentane.pdb</code>\nand <code class=\"language-plaintext highlighter-rouge\">propane.pdb</code> would be printed to the screen and saved to a file called <code class=\"language-plaintext highlighter-rouge\">all.pdb</code>.</li>\n  </ol>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n    <p>3 is the correct answer. <code class=\"language-plaintext highlighter-rouge\">&gt;&gt;</code> appends to a file, rather than overwriting it with the redirected\noutput from a command.\nGiven the output from the <code class=\"language-plaintext highlighter-rouge\">cat</code> command has been redirected, nothing is printed to the screen.</p>\n  </blockquote>\n</blockquote>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Explore the possible solutions here!</span>\n</code></pre></div></div>\n\n<p>Let’s continue with our example in the <code class=\"language-plaintext highlighter-rouge\">shell-lesson-data/creatures</code> directory.\nHere’s a slightly more complicated loop:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">for </span>filename <span class=\"k\">in</span> <span class=\"k\">*</span>.dat\n<span class=\"k\">do\n    </span><span class=\"nb\">echo</span> <span class=\"nv\">$filename</span>\n    <span class=\"nb\">head</span> <span class=\"nt\">-n</span> 100 <span class=\"nv\">$filename</span> | <span class=\"nb\">tail</span> <span class=\"nt\">-n</span> 20\n<span class=\"k\">done</span>\n</code></pre></div></div>\n\n<p>The shell starts by expanding <code class=\"language-plaintext highlighter-rouge\">*.dat</code> to create the list of files it will process.\nThe <strong>loop body</strong>\nthen executes two commands for each of those files.\nThe first command, <code class=\"language-plaintext highlighter-rouge\">echo</code>, prints its command-line arguments to standard output.\nFor example:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">echo </span>hello there\n</code></pre></div></div>\n\n<p>prints:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>hello there\n</code></pre></div></div>\n\n<p>In this case,\nsince the shell expands <code class=\"language-plaintext highlighter-rouge\">$filename</code> to be the name of a file,\n<code class=\"language-plaintext highlighter-rouge\">echo $filename</code> prints the name of the file.\nNote that we can’t write this as:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">for </span>filename <span class=\"k\">in</span> <span class=\"k\">*</span>.dat\n<span class=\"k\">do</span>\n    <span class=\"nv\">$filename</span>\n    <span class=\"nb\">head</span> <span class=\"nt\">-n</span> 100 <span class=\"nv\">$filename</span> | <span class=\"nb\">tail</span> <span class=\"nt\">-n</span> 20\n<span class=\"k\">done</span>\n</code></pre></div></div>\n\n<p>because then the first time through the loop,\nwhen <code class=\"language-plaintext highlighter-rouge\">$filename</code> expanded to <code class=\"language-plaintext highlighter-rouge\">basilisk.dat</code>, the shell would try to run <code class=\"language-plaintext highlighter-rouge\">basilisk.dat</code> as a program.\nFinally,\nthe <code class=\"language-plaintext highlighter-rouge\">head</code> and <code class=\"language-plaintext highlighter-rouge\">tail</code> combination selects lines 81-100\nfrom whatever file is being processed\n(assuming the file has at least 100 lines).</p>\n\n<blockquote class=\"tip\">\n  <tip-title>Spaces in Names</tip-title>\n\n  <p>Spaces are used to separate the elements of the list\nthat we are going to loop over. If one of those elements\ncontains a space character, we need to surround it with\nquotes, and do the same thing to our loop variable.\nSuppose our data files are named:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>red dragon.dat\npurple unicorn.dat\n</code></pre></div>  </div>\n\n  <p>To loop over these files, we would need to add double quotes like so:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ for filename in \"red dragon.dat\" \"purple unicorn.dat\"\n&gt; do\n&gt;     head -n 100 \"$filename\" | tail -n 20\n&gt; done\n</code></pre></div>  </div>\n\n  <p>It is simpler to avoid using spaces (or other special characters) in filenames.</p>\n\n  <p>The files above don’t exist, so if we run the above code, the <code class=\"language-plaintext highlighter-rouge\">head</code> command will be unable\nto find them, however the error message returned will show the name of the files it is\nexpecting:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>head: cannot open ‘red dragon.dat’ for reading: No such file or directory\nhead: cannot open ‘purple unicorn.dat’ for reading: No such file or directory\n</code></pre></div>  </div>\n\n  <p>Try removing the quotes around <code class=\"language-plaintext highlighter-rouge\">$filename</code> in the loop above to see the effect of the quote\nmarks on spaces. Note that we get a result from the loop command for unicorn.dat\nwhen we run this code in the <code class=\"language-plaintext highlighter-rouge\">creatures</code> directory:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>head: cannot open ‘red’ for reading: No such file or directory\nhead: cannot open ‘dragon.dat’ for reading: No such file or directory\nhead: cannot open ‘purple’ for reading: No such file or directory\nCGGTACCGAA\nAAGGGTCGCG\nCAAGTGTTCC\n...\n</code></pre></div>  </div>\n</blockquote>\n\n<p>We would like to modify each of the files in <code class=\"language-plaintext highlighter-rouge\">shell-lesson-data/creatures</code>, but also save a version\nof the original files, naming the copies <code class=\"language-plaintext highlighter-rouge\">original-basilisk.dat</code> and <code class=\"language-plaintext highlighter-rouge\">original-unicorn.dat</code>.\nWe can’t use:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cp *.dat original-*.dat\n</code></pre></div></div>\n\n<p>because that would expand to:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">cp </span>basilisk.dat minotaur.dat unicorn.dat original-<span class=\"k\">*</span>.dat\n</code></pre></div></div>\n\n<p>This wouldn’t back up our files, instead we get an error.</p>\n\n<p>This problem arises when <code class=\"language-plaintext highlighter-rouge\">cp</code> receives more than two inputs. When this happens, it\nexpects the last input to be a directory where it can copy all the files it was passed.\nSince there is no directory named <code class=\"language-plaintext highlighter-rouge\">original-*.dat</code> in the <code class=\"language-plaintext highlighter-rouge\">creatures</code> directory we get an\nerror.</p>\n\n<p>Instead, we can use a loop:</p>\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">for </span>filename <span class=\"k\">in</span> <span class=\"k\">*</span>.dat\n<span class=\"k\">do\n    </span><span class=\"nb\">cp</span> <span class=\"nv\">$filename</span> original-<span class=\"nv\">$filename</span>\n<span class=\"k\">done</span>\n</code></pre></div></div>\n\n<p>This loop runs the <code class=\"language-plaintext highlighter-rouge\">cp</code> command once for each filename.\nThe first time,\nwhen <code class=\"language-plaintext highlighter-rouge\">$filename</code> expands to <code class=\"language-plaintext highlighter-rouge\">basilisk.dat</code>,\nthe shell executes:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cp basilisk.dat original-basilisk.dat\n</code></pre></div></div>\n\n<p>The second time, the command is:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cp minotaur.dat original-minotaur.dat\n</code></pre></div></div>\n\n<p>The third and last time, the command is:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cp unicorn.dat original-unicorn.dat\n</code></pre></div></div>\n\n<p>Since the <code class=\"language-plaintext highlighter-rouge\">cp</code> command does not normally produce any output, it’s hard to check\nthat the loop is doing the correct thing.\nHowever, we learned earlier how to print strings using <code class=\"language-plaintext highlighter-rouge\">echo</code>, and we can modify the loop\nto use <code class=\"language-plaintext highlighter-rouge\">echo</code> to print our commands without actually executing them.\nAs such we can check what commands <em>would be</em> run in the unmodified loop.</p>\n\n<p>The following diagram\nshows what happens when the modified loop is executed, and demonstrates how the\njudicious use of <code class=\"language-plaintext highlighter-rouge\">echo</code> is a good debugging technique.</p>\n\n<p><a href=\"../../images/carpentries-cli/shell_script_for_loop_flow_chart.svg\" rel=\"noopener noreferrer\"><img src=\"../../images/carpentries-cli/shell_script_for_loop_flow_chart.svg\" alt=\"The for loop 'for filename in *.dat; do echo cp $filename original-$filename; done' will successively assign the names of all '*.dat' files in your current directory to the variable '$filename' and then execute the command. With the files 'basilisk.dat', 'minotaur.dat' and 'unicorn.dat' in the current directory the loop will successively call the echo command three times and print three lines: 'cp basislisk.dat original-basilisk.dat', then 'cp minotaur.dat original-minotaur.dat' and finally 'cp unicorn.dat original-unicorn.dat'. \" width=\"10\" height=\"5\" loading=\"lazy\" /></a></p>\n\n<h2 id=\"nelles-pipeline-processing-files\">Nelle’s Pipeline: Processing Files</h2>\n\n<p>Nelle is now ready to process her data files using <code class=\"language-plaintext highlighter-rouge\">goostats.sh</code> —\na shell script written by her supervisor.\nThis calculates some statistics from a protein sample file, and takes two arguments:</p>\n\n<ol>\n  <li>an input file (containing the raw data)</li>\n  <li>an output file (to store the calculated statistics)</li>\n</ol>\n\n<p>Since she’s still learning how to use the shell,\nshe decides to build up the required commands in stages.\nHer first step is to make sure that she can select the right input files — remember,\nthese are ones whose names end in ‘A’ or ‘B’, rather than ‘Z’.\nStarting from her home directory, Nelle types:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">cd</span> ~/Desktop/shell-lesson-data/north-pacific-gyre/2012-07-03\n<span class=\"k\">for </span>datafile <span class=\"k\">in </span>NENE<span class=\"k\">*</span>A.txt NENE<span class=\"k\">*</span>B.txt\n<span class=\"k\">do\n    </span><span class=\"nb\">echo</span> <span class=\"nv\">$datafile</span>\n<span class=\"k\">done</span>\n</code></pre></div></div>\n\n<p>Her next step is to decide\nwhat to call the files that the <code class=\"language-plaintext highlighter-rouge\">goostats.sh</code> analysis program will create.\nPrefixing each input file’s name with ‘stats’ seems simple,\nso she modifies her loop to do that:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">for </span>datafile <span class=\"k\">in </span>NENE<span class=\"k\">*</span>A.txt NENE<span class=\"k\">*</span>B.txt\n<span class=\"k\">do\n    </span><span class=\"nb\">echo</span> <span class=\"nv\">$datafile</span> stats-<span class=\"nv\">$datafile</span>\n<span class=\"k\">done</span>\n</code></pre></div></div>\n\n<p>She hasn’t actually run <code class=\"language-plaintext highlighter-rouge\">goostats.sh</code> yet,\nbut now she’s sure she can select the right files and generate the right output filenames.</p>\n\n<blockquote class=\"tip\">\n  <tip-title>Top Terminal Tip: Re-running previous commands</tip-title>\n  <p>Typing in commands over and over again is becoming tedious,\nthough,\nand Nelle is worried about making mistakes,\nso instead of re-entering her loop,\nshe presses <kbd>↑</kbd>.\nIn response,\nthe shell redisplays the whole loop on one line\n(using semi-colons to separate the pieces):</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for datafile in NENE*A.txt NENE*B.txt; do echo $datafile stats-$datafile; done\n</code></pre></div>  </div>\n</blockquote>\n\n<p>Using the left arrow key,\nNelle backs up and changes the command <code class=\"language-plaintext highlighter-rouge\">echo</code> to <code class=\"language-plaintext highlighter-rouge\">bash goostats.sh</code>:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for datafile in NENE*A.txt NENE*B.txt; do bash goostats.sh $datafile stats-$datafile; done\n</code></pre></div></div>\n\n<p>When she presses <kbd>Enter</kbd>,\nthe shell runs the modified command.\nHowever, nothing appears to happen — there is no output.\nAfter a moment, Nelle realizes that since her script doesn’t print anything to the screen\nany longer, she has no idea whether it is running, much less how quickly.\nShe kills the running command by typing <kbd>Ctrl</kbd>+<kbd>C</kbd>,\nuses <kbd>↑</kbd> to repeat the command,\nand edits it to read:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for datafile in NENE*A.txt NENE*B.txt; do echo $datafile; bash goostats.sh $datafile stats-$datafile; done\n</code></pre></div></div>\n\n<blockquote class=\"tip\">\n  <tip-title>Beginning and End</tip-title>\n\n  <p>We can move to the beginning of a line in the shell by typing <kbd>Ctrl</kbd>+<kbd>A</kbd>\nand to the end using <kbd>Ctrl</kbd>+<kbd>E</kbd>.</p>\n</blockquote>\n\n<p>When she runs her program now,\nit produces one line of output every five seconds or so:</p>\n\n<p>1518 times 5 seconds,\ndivided by 60,\ntells her that her script will take about two hours to run.\nAs a final check,\nshe opens another terminal window,\ngoes into <code class=\"language-plaintext highlighter-rouge\">north-pacific-gyre/2012-07-03</code>,\nand uses <code class=\"language-plaintext highlighter-rouge\">cat stats-NENE01729B.txt</code>\nto examine one of the output files.\nIt looks good,\nso she decides to get some coffee and catch up on her reading.</p>\n\n<blockquote class=\"tip\">\n  <tip-title>Those Who Know History Can Choose to Repeat It</tip-title>\n\n  <p>Another way to repeat previous work is to use the <code class=\"language-plaintext highlighter-rouge\">history</code> command to\nget a list of the last few hundred commands that have been executed, and\nthen to use <code class=\"language-plaintext highlighter-rouge\">!123</code> (where ‘123’ is replaced by the command number) to\nrepeat one of those commands. For example, if Nelle types this:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ history | tail -n 5\n</code></pre></div>  </div>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  456  ls -l NENE0*.txt\n  457  rm stats-NENE01729B.txt.txt\n  458  bash goostats.sh NENE01729B.txt stats-NENE01729B.txt\n  459  ls -l NENE0*.txt\n  460  history\n</code></pre></div>  </div>\n\n  <p>then she can re-run <code class=\"language-plaintext highlighter-rouge\">goostats.sh</code> on <code class=\"language-plaintext highlighter-rouge\">NENE01729B.txt</code> simply by typing\n<code class=\"language-plaintext highlighter-rouge\">!458</code>. This number will be different for you, you should check your history before running it!</p>\n</blockquote>\n\n<blockquote class=\"tip\">\n  <tip-title>Other History Commands</tip-title>\n\n  <p>There are a number of other shortcut commands for getting at the history.</p>\n\n  <ul>\n    <li><kbd>Ctrl</kbd>+<kbd>R</kbd> enters a history search mode ‘reverse-i-search’ and finds the\nmost recent command in your history that matches the text you enter next.\nPress <kbd>Ctrl</kbd>+<kbd>R</kbd> one or more additional times to search for earlier matches.\nYou can then use the left and right arrow keys to choose that line and edit\nit then hit <kbd>Return</kbd> to run the command.</li>\n    <li><code class=\"language-plaintext highlighter-rouge\">!!</code> retrieves the immediately preceding command\n(you may or may not find this more convenient than using <kbd>↑</kbd>)</li>\n    <li><code class=\"language-plaintext highlighter-rouge\">!$</code> retrieves the last word of the last command.\nThat’s useful more often than you might expect: after\n<code class=\"language-plaintext highlighter-rouge\">bash goostats.sh NENE01729B.txt stats-NENE01729B.txt</code>, you can type\n<code class=\"language-plaintext highlighter-rouge\">less !$</code> to look at the file <code class=\"language-plaintext highlighter-rouge\">stats-NENE01729B.txt</code>, which is\nquicker than doing <kbd>↑</kbd> and editing the command-line.</li>\n  </ul>\n</blockquote>\n\n<blockquote class=\"question\">\n  <question-title>Doing a Dry Run</question-title>\n\n  <p>A loop is a way to do many things at once — or to make many mistakes at\nonce if it does the wrong thing. One way to check what a loop <em>would</em> do\nis to <code class=\"language-plaintext highlighter-rouge\">echo</code> the commands it would run instead of actually running them.</p>\n\n  <p>Suppose we want to preview the commands the following loop will execute\nwithout actually running those commands:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cd ~/Desktop/shell-lesson-data/pdb/\nfor datafile in *.pdb\ndo\n    cat $datafile &gt;&gt; all.pdb\ndone\n</code></pre></div>  </div>\n\n  <p>What is the difference between the two loops below, and which one would we\nwant to run?</p>\n\n  <blockquote class=\"code-in\">\n    <code-in-title>Version 1</code-in-title>\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for datafile in *.pdb\ndo\n    echo cat $datafile &gt;&gt; all.pdb\ndone\n</code></pre></div>    </div>\n  </blockquote>\n\n  <blockquote class=\"code-in\">\n    <code-in-title>Version 2</code-in-title>\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for datafile in *.pdb\ndo\n    echo \"cat $datafile &gt;&gt; all.pdb\"\ndone\n</code></pre></div>    </div>\n  </blockquote>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n    <p>The second version is the one we want to run.\nThis prints to screen everything enclosed in the quote marks, expanding the\nloop variable name because we have prefixed it with a dollar sign.</p>\n\n    <p>The first version appends the output from the command <code class=\"language-plaintext highlighter-rouge\">echo cat $datafile</code>\nto the file, <code class=\"language-plaintext highlighter-rouge\">all.pdb</code>. This file will just contain the list;\n<code class=\"language-plaintext highlighter-rouge\">cat cubane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">cat ethane.pdb</code>, <code class=\"language-plaintext highlighter-rouge\">cat methane.pdb</code> etc.</p>\n\n    <p>Try both versions for yourself to see the output! Be sure to open the\n<code class=\"language-plaintext highlighter-rouge\">all.pdb</code> file to view its contents.</p>\n  </blockquote>\n</blockquote>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Explore the possible solutions here!</span>\n</code></pre></div></div>\n\n<blockquote class=\"question\">\n  <question-title>Nested Loops</question-title>\n\n  <p>Suppose we want to set up a directory structure to organize\nsome experiments measuring reaction rate constants with different compounds\n<em>and</em> different temperatures.  What would be the\nresult of the following code:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for species in cubane ethane methane\ndo\n    for temperature in 25 30 37 40\n    do\n        mkdir $species-$temperature\n    done\ndone\n</code></pre></div>  </div>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n    <p>We have a nested loop, i.e. contained within another loop, so for each species\nin the outer loop, the inner loop (the nested loop) iterates over the list of\ntemperatures, and creates a new directory for each combination.</p>\n\n    <p>Try running the code for yourself to see which directories are created!</p>\n  </blockquote>\n</blockquote>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Explore the possible solutions here!</span>\n</code></pre></div></div>\n\n<h1 id=\"finding-things\">Finding Things</h1>\n\n<p>In the same way that many of us now use ‘Google’ as a\nverb meaning ‘to find’, Unix programmers often use the\nword ‘grep’.\n‘grep’ is a contraction of ‘global/regular expression/print’,\na common sequence of operations in early Unix text editors.\nIt is also the name of a very useful command-line program.</p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">grep</code> finds and prints lines in files that match a pattern.\nFor our examples,\nwe will use a file that contains three haiku taken from a\n1998 competition in <em>Salon</em> magazine. For this set of examples,\nwe’re going to be working in the writing subdirectory:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">cd\ncd </span>Desktop/shell-lesson-data/writing\n<span class=\"nb\">cat </span>haiku.txt\n</code></pre></div></div>\n\n<blockquote class=\"tip\">\n  <tip-title>Forever, or Five Years</tip-title>\n\n  <p>We haven’t linked to the original haiku because\nthey don’t appear to be on <em>Salon</em>’s site any longer.\nAs <a href=\"https://www.clir.org/wp-content/uploads/sites/6/ensuring.pdf\">Jeff Rothenberg said</a>,\n‘Digital information lasts forever — or five years, whichever comes first.’\nLuckily, popular content often <a href=\"http://wiki.c2.com/?ComputerErrorHaiku\">has backups</a>.</p>\n</blockquote>\n\n<p>Let’s find lines that contain the word ‘not’:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">grep </span>not haiku.txt\n</code></pre></div></div>\n\n<p>Here, <code class=\"language-plaintext highlighter-rouge\">not</code> is the pattern we’re searching for.\nThe grep command searches through the file, looking for matches to the pattern specified.\nTo use it type <code class=\"language-plaintext highlighter-rouge\">grep</code>, then the pattern we’re searching for and finally\nthe name of the file (or files) we’re searching in.</p>\n\n<p>The output is the three lines in the file that contain the letters ‘not’.</p>\n\n<p>By default, grep searches for a pattern in a case-sensitive way.\nIn addition, the search pattern we have selected does not have to form a complete word,\nas we will see in the next example.</p>\n\n<p>Let’s search for the pattern: ‘The’.</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">grep </span>The haiku.txt\n</code></pre></div></div>\n\n<p>This time, two lines that include the letters ‘The’ are outputted,\none of which contained our search pattern within a larger word, ‘Thesis’.</p>\n\n<p>To restrict matches to lines containing the word ‘The’ on its own,\nwe can give <code class=\"language-plaintext highlighter-rouge\">grep</code> with the <code class=\"language-plaintext highlighter-rouge\">-w</code> option.\nThis will limit matches to word boundaries.</p>\n\n<p>Later in this lesson, we will also see how we can change the search behavior of grep\nwith respect to its case sensitivity.</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">grep</span> <span class=\"nt\">-w</span> The haiku.txt\n</code></pre></div></div>\n\n<p>Note that a ‘word boundary’ includes the start and end of a line, so not\njust letters surrounded by spaces.\nSometimes we don’t\nwant to search for a single word, but a phrase. This is also easy to do with\n<code class=\"language-plaintext highlighter-rouge\">grep</code> by putting the phrase in quotes.</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">grep</span> <span class=\"nt\">-w</span> <span class=\"s2\">\"is not\"</span> haiku.txt\n</code></pre></div></div>\n\n<p>We’ve now seen that you don’t have to have quotes around single words,\nbut it is useful to use quotes when searching for multiple words.\nIt also helps to make it easier to distinguish between the search term or phrase\nand the file being searched.\nWe will use quotes in the remaining examples.</p>\n\n<p>Another useful option is <code class=\"language-plaintext highlighter-rouge\">-n</code>, which numbers the lines that match:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">grep</span> <span class=\"nt\">-n</span> <span class=\"s2\">\"it\"</span> haiku.txt\n</code></pre></div></div>\n\n<p>Here, we can see that lines 5, 9, and 10 contain the letters ‘it’.</p>\n\n<p>We can combine options (i.e. flags) as we do with other Unix commands.\nFor example, let’s find the lines that contain the word ‘the’.\nWe can combine the option <code class=\"language-plaintext highlighter-rouge\">-w</code> to find the lines that contain the word ‘the’\nand <code class=\"language-plaintext highlighter-rouge\">-n</code> to number the lines that match:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">grep</span> <span class=\"nt\">-n</span> <span class=\"nt\">-w</span> <span class=\"s2\">\"the\"</span> haiku.txt\n</code></pre></div></div>\n\n<p>Now we want to use the option <code class=\"language-plaintext highlighter-rouge\">-i</code> to make our search case-insensitive:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">grep</span> <span class=\"nt\">-n</span> <span class=\"nt\">-w</span> <span class=\"nt\">-i</span> <span class=\"s2\">\"the\"</span> haiku.txt\n</code></pre></div></div>\n\n<p>Now, we want to use the option <code class=\"language-plaintext highlighter-rouge\">-v</code> to invert our search, i.e., we want to output\nthe lines that do not contain the word ‘the’.</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">grep</span> <span class=\"nt\">-n</span> <span class=\"nt\">-w</span> <span class=\"nt\">-v</span> <span class=\"s2\">\"the\"</span> haiku.txt\n</code></pre></div></div>\n\n<p>If we use the <code class=\"language-plaintext highlighter-rouge\">-r</code> (recursive) option,\n<code class=\"language-plaintext highlighter-rouge\">grep</code> can search for a pattern recursively through a set of files in subdirectories.</p>\n\n<p>Let’s search recursively for <code class=\"language-plaintext highlighter-rouge\">Yesterday</code> in the <code class=\"language-plaintext highlighter-rouge\">shell-lesson-data/writing</code> directory:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">grep</span> <span class=\"nt\">-r</span> Yesterday <span class=\"nb\">.</span>\n</code></pre></div></div>\n\n<p><code class=\"language-plaintext highlighter-rouge\">grep</code> has lots of other options. To find out what they are, we can type:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">grep</span> <span class=\"nt\">--help</span>\n</code></pre></div></div>\n\n<blockquote class=\"question\">\n  <question-title>Using `grep`</question-title>\n\n  <p>Which command would result in the following output:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>and the presence of absence:\n</code></pre></div>  </div>\n\n  <ol>\n    <li><code class=\"language-plaintext highlighter-rouge\">grep \"of\" haiku.txt</code></li>\n    <li><code class=\"language-plaintext highlighter-rouge\">grep -E \"of\" haiku.txt</code></li>\n    <li><code class=\"language-plaintext highlighter-rouge\">grep -w \"of\" haiku.txt</code></li>\n    <li><code class=\"language-plaintext highlighter-rouge\">grep -i \"of\" haiku.txt</code></li>\n  </ol>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n    <p>The correct answer is 3, because the <code class=\"language-plaintext highlighter-rouge\">-w</code> option looks only for whole-word matches.\nThe other options will also match ‘of’ when part of another word.</p>\n  </blockquote>\n</blockquote>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Explore the possible solutions here!</span>\n</code></pre></div></div>\n\n<blockquote class=\"tip\">\n  <tip-title>Wildcards</tip-title>\n\n  <p><code class=\"language-plaintext highlighter-rouge\">grep</code>’s real power doesn’t come from its options, though; it comes from\nthe fact that patterns can include wildcards. (The technical name for\nthese is <strong>regular expressions</strong>, which\nis what the ‘re’ in ‘grep’ stands for.) Regular expressions are both complex\nand powerful; if you want to do complex searches, please look at the lesson\non <a href=\"http://v4.software-carpentry.org/regexp/index.html\">our website</a>. As a taster, we can\nfind lines that have an ‘o’ in the second position like this:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ grep -E \"^.o\" haiku.txt\n</code></pre></div>  </div>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>You bring fresh toner.\nToday it is not working\nSoftware is like that.\n</code></pre></div>  </div>\n\n  <p>We use the <code class=\"language-plaintext highlighter-rouge\">-E</code> option and put the pattern in quotes to prevent the shell\nfrom trying to interpret it. (If the pattern contained a <code class=\"language-plaintext highlighter-rouge\">*</code>, for\nexample, the shell would try to expand it before running <code class=\"language-plaintext highlighter-rouge\">grep</code>.) The\n<code class=\"language-plaintext highlighter-rouge\">^</code> in the pattern anchors the match to the start of the line. The <code class=\"language-plaintext highlighter-rouge\">.</code>\nmatches a single character (just like <code class=\"language-plaintext highlighter-rouge\">?</code> in the shell), while the <code class=\"language-plaintext highlighter-rouge\">o</code>\nmatches an actual ‘o’.</p>\n</blockquote>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Explore the possible solutions here!</span>\n</code></pre></div></div>\n\n<blockquote class=\"question\">\n  <question-title>Tracking a Species</question-title>\n\n  <p>Leah has several hundred\ndata files saved in one directory, each of which is formatted like this:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>2013-11-05,deer,5\n2013-11-05,rabbit,22\n2013-11-05,raccoon,7\n2013-11-06,rabbit,19\n2013-11-06,deer,2\n</code></pre></div>  </div>\n\n  <p>She wants to write a shell script that takes a species as the first command-line argument\nand a directory as the second argument. The script should return one file called <code class=\"language-plaintext highlighter-rouge\">species.txt</code>\ncontaining a list of dates and the number of that species seen on each date.\nFor example using the data shown above, <code class=\"language-plaintext highlighter-rouge\">rabbit.txt</code> would contain:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>2013-11-05,22\n2013-11-06,19\n</code></pre></div>  </div>\n\n  <p>Put these commands and pipes in the right order to achieve this:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cut -d : -f 2\n&gt;\n|\ngrep -w $1 -r $2\n|\n$1.txt\ncut -d , -f 1,3\n</code></pre></div>  </div>\n\n  <p>Hint: use <code class=\"language-plaintext highlighter-rouge\">man grep</code> to look for how to grep text recursively in a directory\nand <code class=\"language-plaintext highlighter-rouge\">man cut</code> to select more than one field in a line.</p>\n\n  <p>An example of such a file is provided in <code class=\"language-plaintext highlighter-rouge\">shell-lesson-data/data/animal-counts/animals.txt</code></p>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>grep -w $1 -r $2 | cut -d : -f 2 | cut -d , -f 1,3 &gt; $1.txt\n</code></pre></div>    </div>\n\n    <p>Actually, you can swap the order of the two cut commands and it still works. At the\ncommand line, try changing the order of the cut commands, and have a look at the output\nfrom each step to see why this is the case.</p>\n\n    <p>You would call the script above like this:</p>\n\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ bash count-species.sh bear .\n</code></pre></div>    </div>\n  </blockquote>\n</blockquote>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Explore the possible solutions here!</span>\n</code></pre></div></div>\n\n<blockquote class=\"question\">\n  <question-title>Little Women</question-title>\n\n  <p>You and your friend, having just finished reading <em>Little Women</em> by\nLouisa May Alcott, are in an argument.  Of the four sisters in the\nbook, Jo, Meg, Beth, and Amy, your friend thinks that Jo was the\nmost mentioned.  You, however, are certain it was Amy.  Luckily, you\nhave a file <code class=\"language-plaintext highlighter-rouge\">LittleWomen.txt</code> containing the full text of the novel\n(<code class=\"language-plaintext highlighter-rouge\">shell-lesson-data/writing/data/LittleWomen.txt</code>).\nUsing a <code class=\"language-plaintext highlighter-rouge\">for</code> loop, how would you tabulate the number of times each\nof the four sisters is mentioned?</p>\n\n  <p>Hint: one solution might employ\nthe commands <code class=\"language-plaintext highlighter-rouge\">grep</code> and <code class=\"language-plaintext highlighter-rouge\">wc</code> and a <code class=\"language-plaintext highlighter-rouge\">|</code>, while another might utilize\n<code class=\"language-plaintext highlighter-rouge\">grep</code> options.\nThere is often more than one way to solve a programming task, so a\nparticular solution is usually chosen based on a combination of\nyielding the correct result, elegance, readability, and speed.</p>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for sis in Jo Meg Beth Amy\ndo\n\techo $sis:\n\tgrep -ow $sis LittleWomen.txt | wc -l\ndone\n</code></pre></div>    </div>\n\n    <p>Alternative, slightly inferior solution:</p>\n    <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>for sis in Jo Meg Beth Amy\ndo\n\techo $sis:\n\tgrep -ocw $sis LittleWomen.txt\ndone\n</code></pre></div>    </div>\n\n    <p>This solution is inferior because <code class=\"language-plaintext highlighter-rouge\">grep -c</code> only reports the number of lines matched.\nThe total number of matches reported by this method will be lower if there is more\nthan one match per line.</p>\n\n    <p>Perceptive observers may have noticed that character names sometimes appear in all-uppercase\nin chapter titles (e.g. ‘MEG GOES TO VANITY FAIR’).\nIf you wanted to count these as well, you could add the <code class=\"language-plaintext highlighter-rouge\">-i</code> option for case-insensitivity\n(though in this case, it doesn’t affect the answer to which sister is mentioned\nmost frequently).</p>\n  </blockquote>\n</blockquote>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Explore the possible solutions here!</span>\n</code></pre></div></div>\n\n<p>While <code class=\"language-plaintext highlighter-rouge\">grep</code> finds lines in files,\nthe <code class=\"language-plaintext highlighter-rouge\">find</code> command finds files themselves.\nAgain,\nit has a lot of options;\nto show how the simplest ones work, we’ll use the directory tree shown below.</p>\n\n<p><a href=\"../../images/carpentries-cli/find-file-tree.svg\" rel=\"noopener noreferrer\"><img src=\"../../images/carpentries-cli/find-file-tree.svg\" alt=\"A file tree under the directory 'writing' contians several sub-directories and files such that 'writing' contains directories 'data', 'thesis', 'tools' and a file 'haiku.txt'; 'writing/data' contains the files 'Little Women.txt', 'one.txt' and 'two.txt'; 'writing/thesis' contains the file 'empty-draft.md'; 'writing/tools' contains the directory 'old' and the files 'format' and 'stats'; and 'writing/tools/old' contains a file 'oldtool'. \" width=\"172\" height=\"139\" loading=\"lazy\" /></a></p>\n\n<p>Nelle’s <code class=\"language-plaintext highlighter-rouge\">writing</code> directory contains one file called <code class=\"language-plaintext highlighter-rouge\">haiku.txt</code> and three subdirectories:\n<code class=\"language-plaintext highlighter-rouge\">thesis</code> (which contains a sadly empty file, <code class=\"language-plaintext highlighter-rouge\">empty-draft.md</code>);\n<code class=\"language-plaintext highlighter-rouge\">data</code> (which contains three files <code class=\"language-plaintext highlighter-rouge\">LittleWomen.txt</code>, <code class=\"language-plaintext highlighter-rouge\">one.txt</code> and <code class=\"language-plaintext highlighter-rouge\">two.txt</code>);\nand a <code class=\"language-plaintext highlighter-rouge\">tools</code> directory that contains the programs <code class=\"language-plaintext highlighter-rouge\">format</code> and <code class=\"language-plaintext highlighter-rouge\">stats</code>,\nand a subdirectory called <code class=\"language-plaintext highlighter-rouge\">old</code>, with a file <code class=\"language-plaintext highlighter-rouge\">oldtool</code>.</p>\n\n<p>For our first command,\nlet’s run <code class=\"language-plaintext highlighter-rouge\">find .</code> (remember to run this command from the <code class=\"language-plaintext highlighter-rouge\">shell-lesson-data/writing</code> folder).</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>find <span class=\"nb\">.</span>\n</code></pre></div></div>\n\n<p>As always,\nthe <code class=\"language-plaintext highlighter-rouge\">.</code> on its own means the current working directory,\nwhich is where we want our search to start.\n<code class=\"language-plaintext highlighter-rouge\">find</code>’s output is the names of every file <strong>and</strong> directory\nunder the current working directory.\nThis can seem useless at first but <code class=\"language-plaintext highlighter-rouge\">find</code> has many options\nto filter the output and in this lesson we will discover some\nof them.</p>\n\n<p>The first option in our list is\n<code class=\"language-plaintext highlighter-rouge\">-type d</code> that means ‘things that are directories’.\nSure enough,\n<code class=\"language-plaintext highlighter-rouge\">find</code>’s output is the names of the five directories in our little tree\n(including <code class=\"language-plaintext highlighter-rouge\">.</code>):</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>find <span class=\"nb\">.</span> <span class=\"nt\">-type</span> d\n</code></pre></div></div>\n\n<p>Notice that the objects <code class=\"language-plaintext highlighter-rouge\">find</code> finds are not listed in any particular order.\nIf we change <code class=\"language-plaintext highlighter-rouge\">-type d</code> to <code class=\"language-plaintext highlighter-rouge\">-type f</code>,\nwe get a listing of all the files instead:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>find <span class=\"nb\">.</span> <span class=\"nt\">-type</span> f\n</code></pre></div></div>\n\n<p>Now let’s try matching by name:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>find <span class=\"nb\">.</span> <span class=\"nt\">-name</span> <span class=\"k\">*</span>.txt\n</code></pre></div></div>\n\n<p>We expected it to find all the text files,\nbut it only prints out <code class=\"language-plaintext highlighter-rouge\">./haiku.txt</code>.\nThe problem is that the shell expands wildcard characters like <code class=\"language-plaintext highlighter-rouge\">*</code> <em>before</em> commands run.\nSince <code class=\"language-plaintext highlighter-rouge\">*.txt</code> in the current directory expands to <code class=\"language-plaintext highlighter-rouge\">haiku.txt</code>,\nthe command we actually ran was:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>find <span class=\"nb\">.</span> <span class=\"nt\">-name</span> haiku.txt\n</code></pre></div></div>\n\n<p><code class=\"language-plaintext highlighter-rouge\">find</code> did what we asked; we just asked for the wrong thing.</p>\n\n<p>To get what we want,\nlet’s do what we did with <code class=\"language-plaintext highlighter-rouge\">grep</code>:\nput <code class=\"language-plaintext highlighter-rouge\">*.txt</code> in quotes to prevent the shell from expanding the <code class=\"language-plaintext highlighter-rouge\">*</code> wildcard.\nThis way,\n<code class=\"language-plaintext highlighter-rouge\">find</code> actually gets the pattern <code class=\"language-plaintext highlighter-rouge\">*.txt</code>, not the expanded filename <code class=\"language-plaintext highlighter-rouge\">haiku.txt</code>:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>find <span class=\"nb\">.</span> <span class=\"nt\">-name</span> <span class=\"s2\">\"*.txt\"</span>\n</code></pre></div></div>\n\n<blockquote class=\"tip\">\n  <tip-title>Listing vs. Finding</tip-title>\n\n  <p><code class=\"language-plaintext highlighter-rouge\">ls</code> and <code class=\"language-plaintext highlighter-rouge\">find</code> can be made to do similar things given the right options,\nbut under normal circumstances,\n<code class=\"language-plaintext highlighter-rouge\">ls</code> lists everything it can,\nwhile <code class=\"language-plaintext highlighter-rouge\">find</code> searches for things with certain properties and shows them.</p>\n</blockquote>\n\n<p>As we said earlier,\nthe command line’s power lies in combining tools.\nWe’ve seen how to do that with pipes;\nlet’s look at another technique.\nAs we just saw,\n<code class=\"language-plaintext highlighter-rouge\">find . -name \"*.txt\"</code> gives us a list of all text files in or below the current directory.\nHow can we combine that with <code class=\"language-plaintext highlighter-rouge\">wc -l</code> to count the lines in all those files?</p>\n\n<p>The simplest way is to put the <code class=\"language-plaintext highlighter-rouge\">find</code> command inside <code class=\"language-plaintext highlighter-rouge\">$()</code>:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">wc</span> <span class=\"nt\">-l</span> <span class=\"si\">$(</span>find <span class=\"nb\">.</span> <span class=\"nt\">-name</span> <span class=\"s2\">\"*.txt\"</span><span class=\"si\">)</span>\n</code></pre></div></div>\n\n<p>When the shell executes this command,\nthe first thing it does is run whatever is inside the <code class=\"language-plaintext highlighter-rouge\">$()</code>.\nIt then replaces the <code class=\"language-plaintext highlighter-rouge\">$()</code> expression with that command’s output.\nSince the output of <code class=\"language-plaintext highlighter-rouge\">find</code> is the four filenames <code class=\"language-plaintext highlighter-rouge\">./data/one.txt</code>, <code class=\"language-plaintext highlighter-rouge\">./data/LittleWomen.txt</code>,\n<code class=\"language-plaintext highlighter-rouge\">./data/two.txt</code>, and <code class=\"language-plaintext highlighter-rouge\">./haiku.txt</code>, the shell constructs the command:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">wc</span> <span class=\"nt\">-l</span> ./data/one.txt ./data/LittleWomen.txt ./data/two.txt ./haiku.txt\n</code></pre></div></div>\n\n<p>which is what we wanted.\nThis expansion is exactly what the shell does when it expands wildcards like <code class=\"language-plaintext highlighter-rouge\">*</code> and <code class=\"language-plaintext highlighter-rouge\">?</code>,\nbut lets us use any command we want as our own ‘wildcard’.</p>\n\n<p>It’s very common to use <code class=\"language-plaintext highlighter-rouge\">find</code> and <code class=\"language-plaintext highlighter-rouge\">grep</code> together.\nThe first finds files that match a pattern;\nthe second looks for lines inside those files that match another pattern.\nHere, for example, we can find PDB files that contain iron atoms\nby looking for the string ‘FE’ in all the <code class=\"language-plaintext highlighter-rouge\">.pdb</code> files above the current directory:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">grep</span> <span class=\"s2\">\"FE\"</span> <span class=\"si\">$(</span>find .. <span class=\"nt\">-name</span> <span class=\"s2\">\"*.pdb\"</span><span class=\"si\">)</span>\n</code></pre></div></div>\n\n<blockquote class=\"question\">\n  <question-title>Matching and Subtracting</question-title>\n\n  <p>The <code class=\"language-plaintext highlighter-rouge\">-v</code> option to <code class=\"language-plaintext highlighter-rouge\">grep</code> inverts pattern matching, so that only lines\nwhich do <em>not</em> match the pattern are printed. Given that, which of\nthe following commands will find all files in <code class=\"language-plaintext highlighter-rouge\">/data</code> whose names\nend in <code class=\"language-plaintext highlighter-rouge\">s.txt</code> but whose names also do <em>not</em> contain the string <code class=\"language-plaintext highlighter-rouge\">net</code>?\n(For example, <code class=\"language-plaintext highlighter-rouge\">animals.txt</code> or <code class=\"language-plaintext highlighter-rouge\">amino-acids.txt</code> but not <code class=\"language-plaintext highlighter-rouge\">planets.txt</code>.)\nOnce you have thought about your answer, you can test the commands in the <code class=\"language-plaintext highlighter-rouge\">shell-lesson-data</code>\ndirectory.</p>\n\n  <ol>\n    <li><code class=\"language-plaintext highlighter-rouge\">find data -name \"*s.txt\" | grep -v net</code></li>\n    <li><code class=\"language-plaintext highlighter-rouge\">find data -name *s.txt | grep -v net</code></li>\n    <li><code class=\"language-plaintext highlighter-rouge\">grep -v \"net\" $(find data -name \"*s.txt\")</code></li>\n    <li>None of the above.</li>\n  </ol>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n    <p>The correct answer is 1. Putting the match expression in quotes prevents the shell\nexpanding it, so it gets passed to the <code class=\"language-plaintext highlighter-rouge\">find</code> command.</p>\n\n    <p>Option 2 is incorrect because the shell expands <code class=\"language-plaintext highlighter-rouge\">*s.txt</code> instead of passing the wildcard\nexpression to <code class=\"language-plaintext highlighter-rouge\">find</code>.</p>\n\n    <p>Option 3 is incorrect because it searches the contents of the files for lines which\ndo not match ‘net’, rather than searching the file names.</p>\n  </blockquote>\n</blockquote>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Explore the possible solutions here!</span>\n</code></pre></div></div>\n\n<blockquote class=\"tip\">\n  <tip-title>Binary Files</tip-title>\n\n  <p>We have focused exclusively on finding patterns in text files. What if\nyour data is stored as images, in databases, or in some other format?</p>\n\n  <p>A handful of tools extend <code class=\"language-plaintext highlighter-rouge\">grep</code> to handle a few non text formats. But a\nmore generalizable approach is to convert the data to text, or\nextract the text-like elements from the data. On the one hand, it makes simple\nthings easy to do. On the other hand, complex things are usually impossible. For\nexample, it’s easy enough to write a program that will extract X and Y\ndimensions from image files for <code class=\"language-plaintext highlighter-rouge\">grep</code> to play with, but how would you\nwrite something to find values in a spreadsheet whose cells contained\nformulas?</p>\n\n  <p>A last option is to recognize that the shell and text processing have\ntheir limits, and to use another programming language.\nWhen the time comes to do this, don’t be too hard on the shell: many\nmodern programming languages have borrowed a lot of\nideas from it, and imitation is also the sincerest form of praise.</p>\n</blockquote>\n\n<p>The Unix shell is older than most of the people who use it. It has\nsurvived so long because it is one of the most productive programming\nenvironments ever created — maybe even <em>the</em> most productive. Its syntax\nmay be cryptic, but people who have mastered it can experiment with\ndifferent commands interactively, then use what they have learned to\nautomate their work. Graphical user interfaces may be easier to use at\nfirst, but once learned, the productivity in the shell is unbeatable.\nAnd as Alfred North Whitehead wrote in 1911, ‘Civilization advances by\nextending the number of important operations which we can perform\nwithout thinking about them.’</p>\n\n<blockquote class=\"question\">\n  <question-title>`find` Pipeline Reading Comprehension</question-title>\n\n  <p>Write a short explanatory comment for the following shell script:</p>\n\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>wc -l $(find . -name \"*.dat\") | sort -n\n</code></pre></div>  </div>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n    <ol>\n      <li>Find all files with a <code class=\"language-plaintext highlighter-rouge\">.dat</code> extension recursively from the current directory</li>\n      <li>Count the number of lines each of these files contains</li>\n      <li>Sort the output from step 2. numerically</li>\n    </ol>\n  </blockquote>\n</blockquote>\n\n<h1 id=\"final-notes\">Final Notes</h1>\n\n<p>All of the commands you have run up until now were ad-hoc, interactive commands.</p>\n"],"ref_slides":[],"hands_on":true,"slides":false,"mod_date":"2023-10-23 09:44:54 +0000","pub_date":"2021-09-30 08:53:07 +0000","version":14,"api":"https://training.galaxyproject.org/training-material/api/topics/data-science/tutorials/cli-advanced/tutorial.json","tools":[],"supported_servers":{"exact":[],"inexact":[{"name":"UseGalaxy.eu","url":"https://usegalaxy.eu","id":"eu","human":"Galaxy Europe","usegalaxy":true},{"name":"UseGalaxy.org","url":"https://usegalaxy.org","id":"us","human":"Galaxy Main","usegalaxy":true},{"name":"UseGalaxy.org.au","url":"https://usegalaxy.org.au","id":"au","human":"Galaxy Australia","usegalaxy":true},{"name":"UseGalaxy.fr","url":"https://usegalaxy.fr","id":"fr","human":"Galaxy France","usegalaxy":true}]},"topic_name_human":"Foundations of Data Science","admin_install":{"install_tool_dependencies":true,"install_repository_dependencies":true,"install_resolver_dependencies":true,"tools":[]},"admin_install_yaml":"---\ninstall_tool_dependencies: true\ninstall_repository_dependencies: true\ninstall_resolver_dependencies: true\ntools: []\n","tours":false,"video":false,"slides_recordings":false,"translations":{"tutorial":[],"slides":[],"video":false},"license":"CC-BY-4.0","type":"tutorial"}
{"layout":"tutorial_hands_on","title":"Generating a single cell matrix using Alevin and combining datasets (bash + R)","subtopic":"single-cell-CS-code","priority":1,"zenodo_link":null,"questions":["I have some single cell FASTQ files I want to analyse. Where do I start?","How to generate a single cell matrix using command line?"],"objectives":["Generate a cellxgene matrix for droplet-based single cell sequencing data","Interpret quality control (QC) plots to make informed decisions on cell thresholds","Find relevant information in GTF files for the particulars of their study, and include this in data matrix metadata"],"time_estimation":"2H","key_points":["Create a SCE object from FASTQ files, including relevant gene and cell metadata, and do it all in Jupyter Notebook!"],"requirements":[{"type":"internal","topic_name":"single-cell","tutorials":["scrna-case_alevin"]}],"follow_up_training":[{"type":"internal","topic_name":"single-cell","tutorials":["scrna-case_alevin-combine-datasets"]}],"tags":["10x","paper-replication","jupyter-notebook"],"contributions":{"authorship":["wee-snufkin","nomadscientist"],"editing":["pavanvidem","mtekman"],"testing":["pavanvidem"],"funding":["eosc-life"]},"notebook":{"language":"bash","snippet":"topics/single-cell/tutorials/alevin-commandline/preamble.md"},"js_requirements":{"mathjax":null,"mermaid":false},"short_id":"T00378","url":"/topics/single-cell/tutorials/alevin-commandline/tutorial.html","topic_name":"single-cell","tutorial_name":"alevin-commandline","dir":"topics/single-cell/tutorials/alevin-commandline","symlink":null,"id":"single-cell/alevin-commandline","ref_tutorials":["<h1 id=\"setting-up-the-environment\">Setting up the environment</h1>\n\n<p>Alevin is a tool integrated with the <a href=\"https://salmon.readthedocs.io/en/latest/salmon.html\">Salmon software</a>, so first we need to get Salmon. You can install Salmon using conda, but in this tutorial we will show an alternative method - downloading the pre-compiled binaries from the <a href=\"https://github.com/COMBINE-lab/salmon/releases\">releases page</a>. Note that binaries are usually compiled for specific CPU architectures, such as the 64-bit (x86_64) machine release referenced below .</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>wget <span class=\"nt\">-nv</span> https://github.com/COMBINE-lab/salmon/releases/download/v1.10.0/salmon-1.10.0_linux_x86_64.tar.gz\n</code></pre></div></div>\n\n<p>Once you’ve downloaded a specific binary (here we’re using version 1.10.0), just extract it like so:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nb\">tar</span> <span class=\"nt\">-xvzf</span> salmon-1.10.0_linux_x86_64.tar.gz\n</code></pre></div></div>\n\n<blockquote class=\"details\">\n  <details-title>Conda installation</details-title>\n\n  <p>As mentioned, installing salmon using conda is also an option, and you can do it using the following command in the terminal:</p>\n  <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>conda install -c bioconda salmon\n</code></pre></div>  </div>\n\n  <p>However, for this tutorial, it would be easier and quicker to use the downloaded pre-compiled binaries, as shown above.</p>\n\n</blockquote>\n\n<p>We’re going to use Alevin for demonstration purposes, but we do not endorse one method over another.</p>\n\n<h1 id=\"get-data\">Get Data</h1>\n\n<p>We continue working on the same example data - a very small subset of the reads in a mouse dataset of fetal growth restriction <span class=\"citation\"><a href=\"#Bacon2018\">Bacon <i>et al.</i> 2018</a></span> (see the <a href=\"https://www.ebi.ac.uk/gxa/sc/experiments/E-MTAB-6945/results/tsne\">study in Single Cell Expression Atlas</a> and the <a href=\"https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-6945/\">project submission</a>). For the purposes of this tutorial, the datasets have been subsampled to only 50k reads (around 1% of the original files). Those are two fastq files - one with transcripts and the another one with cell barcodes. You can download the files by running the code below:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>wget <span class=\"nt\">-nv</span> https://zenodo.org/records/10116786/files/transcript_701.fastq\nwget <span class=\"nt\">-nv</span> https://zenodo.org/records/10116786/files/barcodes_701.fastq\n</code></pre></div></div>\n\n<blockquote class=\"question\">\n  <question-title></question-title>\n\n  <p>How to differentiate between the two files if they are just called ‘Read 1’ and ‘Read 2’?</p>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n\n    <p>The file which contains the cell barcodes and UMI is significantly shorter (indeed, 20 bp!) compared to the other file containing longer, transcript read. For ease, we will use explicit file names.</p>\n\n  </blockquote>\n\n</blockquote>\n\n<p>Additionally, to map your reads, you will need a transcriptome to align against (a FASTA) as well as the gene information for each transcript (a gtf) file. These files are included in the data import step below. You can also download these for your species of interest <a href=\"https://www.ensembl.org/info/data/ftp/index.html\">from Ensembl</a>.</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>wget <span class=\"nt\">-c</span> https://zenodo.org/record/4574153/files/Mus_musculus.GRCm38.100.gtf.gff <span class=\"nt\">-O</span> GRCm38_gtf.gff\nwget <span class=\"nt\">-c</span> https://zenodo.org/record/4574153/files/Mus_musculus.GRCm38.cdna.all.fa.fasta <span class=\"nt\">-O</span> GRCm38_cdna.fasta\n</code></pre></div></div>\n\n<p>Why do we need FASTA and GTF files? \nTo generate gene-level quantifications based on transcriptome quantification, Alevin and similar tools require a conversion between transcript and gene identifiers. We can derive a transcript-gene conversion from the gene annotations available in genome resources such as Ensembl. The transcripts in such a list need to match the ones we will use later to build a binary transcriptome index. If you were using spike-ins, you’d need to add these to the transcriptome and the transcript-gene mapping.</p>\n\n<p>We will use the murine reference annotation as retrieved from Ensembl (<em>GRCm38</em> or <em>mm10</em>) in GTF format. This annotation contains gene, exon, transcript and all sorts of other information on the sequences. We will use these to generate the transcript-gene mapping by passing that information to a tool that extracts just the transcript identifiers we need.</p>\n\n<h1 id=\"generate-a-transcript-to-gene-map-and-filtered-fasta\">Generate a transcript to gene map and filtered FASTA</h1>\n\n<p>You can have a look at the Terminal tab again. Has the package <code class=\"language-plaintext highlighter-rouge\">atlas-gene-annotation-manipulation</code> been installed yet? If yes, you can execute the code cell below and while it’s running, I’ll explain all the parameters we set here.</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>gtf2featureAnnotation.R <span class=\"nt\">-g</span> GRCm38_gtf.gff <span class=\"nt\">-c</span> GRCm38_cdna.fasta <span class=\"nt\">-d</span> <span class=\"s2\">\"transcript_id\"</span> <span class=\"nt\">-t</span> <span class=\"s2\">\"transcript\"</span> <span class=\"nt\">-f</span> <span class=\"s2\">\"transcript_id\"</span> <span class=\"nt\">-o</span> map <span class=\"nt\">-l</span> <span class=\"s2\">\"transcript_id,gene_id\"</span> <span class=\"nt\">-r</span> <span class=\"nt\">-e</span> filtered_fasta\n</code></pre></div></div>\n\n<p>In essence, <a href=\"https://github.com/ebi-gene-expression-group/atlas-gene-annotation-manipulation\">gtf2featureAnnotation.R script</a> takes a GTF annotation file and creates a table of annotation by feature, optionally filtering a cDNA file supplied at the same time. Therefore the first parameter <code class=\"language-plaintext highlighter-rouge\">-g</code> stands for “gtf-file” and requires a path to a valid GTF file. Then <code class=\"language-plaintext highlighter-rouge\">-c</code> takes a cDNA file for extracting meta info and/or filtering - that’s our FASTA! Where –parse-cdnas (that’s our <code class=\"language-plaintext highlighter-rouge\">-c</code>) is specified, we need to specify, using <code class=\"language-plaintext highlighter-rouge\">-d</code>, which field should be used to compare to identfiers from the FASTA. We set that to “transcript_id” - feel free to inspect the GTF file to explore other attributes. We pass the same value in <code class=\"language-plaintext highlighter-rouge\">-f</code>, meaning first-field, ie. the name of the field to place first in output table. To specify which other fields to retain in the output table, we provide comma-separated list of those fields, and since we’re only interested in transcript to gene map, we put those two names (“transcript_id,gene_id”) into <code class=\"language-plaintext highlighter-rouge\">-l</code>. <code class=\"language-plaintext highlighter-rouge\">-t</code> stands for the feature type to use, and in our case we’re using “transcript”. Guess what <code class=\"language-plaintext highlighter-rouge\">-o</code> is! Indeed, that’s the output annotation table - here we specify the file path of our transcript to gene map. We will also have another output denoted by <code class=\"language-plaintext highlighter-rouge\">-e</code> and that’s the path to a filtered FASTA. Finally, we also put <code class=\"language-plaintext highlighter-rouge\">-r</code> which is there only to suppress header on output. Summarising, output will be a an annotation table, and a FASTA-format cDNAs file with unannotated transcripts removed.</p>\n\n<p>Why filtered FASTA?\nSometimes it’s important that there are no transcripts in a FASTA-format transcriptome that cannot be matched to a transcript/gene mapping. Salmon, for example,  used to produce errors when this mismatch was present. We can synchronise the cDNA file by removing mismatches as we have done above.</p>\n\n<h1 id=\"generate-a-transcriptome-index\">Generate a transcriptome index</h1>\n\n<p>We will use Salmon in mapping-based mode, so first we have to build a Salmon index for our transcriptome. We will run the Salmon indexer as so:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>salmon-latest_linux_x86_64/bin/salmon index <span class=\"nt\">-t</span> filtered_fasta <span class=\"nt\">-i</span> salmon_index <span class=\"nt\">-k</span> 31\n</code></pre></div></div>\n\n<p>Where <code class=\"language-plaintext highlighter-rouge\">-t</code> stands for our filtered FASTA file, and <code class=\"language-plaintext highlighter-rouge\">-i</code> is the output of the mapping-based index. To build it, the function is using an auxiliary k-mer hash over k-mers of length 31. While the mapping algorithms will make use of arbitrarily long matches between the query and reference, the k size selected here will act as the minimum acceptable length for a valid match. Thus, a smaller value of k may slightly improve sensitivity. We find that a k of 31 seems to work well for reads of 75bp or longer, but you might consider a smaller k if you plan to deal with shorter reads. Also, a shorter value of k may improve sensitivity even more when using selective alignment (enabled via the –validateMappings flag). So, if you are seeing a smaller mapping rate than you might expect, consider building the index with a slightly smaller k.</p>\n\n<blockquote class=\"details\">\n  <details-title>What is the index?</details-title>\n\n  <p>To be able to search a transcriptome quickly, Salmon needs to convert the text (FASTA) format sequences into something it can search quickly, called an ‘index’. The index is in a binary rather than human-readable format, but allows fast lookup by Alevin. Because the types of biological and technical sequences we need to include in the index can vary between experiments, and because we often want to use the most up-to-date reference sequences from Ensembl or NCBI, we can end up re-making the indices quite often.</p>\n\n</blockquote>\n\n<h1 id=\"use-alevin\">Use Alevin</h1>\n\n<p>Time to use Alevin now! Alevin works under the same indexing scheme (as Salmon) for the reference, and consumes the set of FASTA/Q files(s) containing the Cellular Barcode(CB) + Unique Molecule identifier (UMI) in one read file and the read sequence in the other. Given just the transcriptome and the raw read files, Alevin generates a cell-by-gene count matrix (in a fraction of the time compared to other tools).</p>\n\n<blockquote class=\"details\">\n  <details-title>How does Alevin work in detail?</details-title>\n\n  <p>Alevin works in two phases. In the first phase it quickly parses the read file containing the CB and UMI information to generate the frequency distribution of all the observed CBs, and creates a lightweight data-structure for fast-look up and correction of the CB. In the second round, Alevin utilizes the read-sequences contained in the files to map the reads to the transcriptome, identify potential PCR/sequencing errors in the UMIs, and performs hybrid de-duplication while accounting for UMI collisions. Finally, a post-abundance estimation CB whitelisting procedure is done and a cell-by-gene count matrix is generated.</p>\n\n</blockquote>\n\n<p>Alevin can be run using the following command:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>salmon-latest_linux_x86_64/bin/salmon alevin <span class=\"nt\">-l</span> ISR <span class=\"nt\">-1</span> barcodes_701.fastq <span class=\"nt\">-2</span> transcript_701.fastq <span class=\"nt\">--dropseq</span>  <span class=\"nt\">-i</span> salmon_index <span class=\"nt\">-p</span> 10 <span class=\"nt\">-o</span> alevin_output <span class=\"nt\">--tgMap</span> map <span class=\"nt\">--freqThreshold</span> 3 <span class=\"nt\">--keepCBFraction</span> 1 <span class=\"nt\">--dumpFeatures</span>\n</code></pre></div></div>\n\n<p>All the required input parameters are described in <a href=\"https://salmon.readthedocs.io/en/latest/alevin.html\">the documentation</a>, but for the ease of use, they are presented below as well:</p>\n\n<blockquote class=\"details\">\n  <details-title>Alevin input parameters</details-title>\n  <ul>\n    <li>\n      <p><code class=\"language-plaintext highlighter-rouge\">-l</code>: library type (same as Salmon), we recommend using ISR for both Drop-seq and 10x-v2 chemistry.</p>\n    </li>\n    <li>\n      <p><code class=\"language-plaintext highlighter-rouge\">-1</code>: CB+UMI file(s), alevin requires the path to the FASTQ file containing CB+UMI raw sequences to be given under this command line flag. Alevin also supports parsing of data from multiple files as long as the order is the same as in -2 flag. That’s our barcodes_701.fastq file.</p>\n    </li>\n    <li>\n      <p><code class=\"language-plaintext highlighter-rouge\">-2</code>: Read-sequence file(s), alevin requires the path to the FASTQ file containing raw read-sequences to be given under this command line flag. Alevin also supports parsing of data from multiple files as long as the order is the same as in -1 flag. That’s our transcript_701.fastq file.</p>\n    </li>\n    <li>\n      <p><code class=\"language-plaintext highlighter-rouge\">--dropseq</code> / <code class=\"language-plaintext highlighter-rouge\">--chromium</code> / <code class=\"language-plaintext highlighter-rouge\">--chromiumV3</code>: the protocol, this flag tells the type of single-cell protocol of the input sequencing-library. This is a study using the Drop-seq chemistry, so we specify that in the flag.</p>\n    </li>\n    <li>\n      <p><code class=\"language-plaintext highlighter-rouge\">-i</code>: index, file containing the salmon index of the reference transcriptome, as generated by salmon index command.</p>\n    </li>\n    <li>\n      <p><code class=\"language-plaintext highlighter-rouge\">-p</code>: number of threads, the number of threads which can be used by alevin to perform the quantification, by default alevin utilizes all the available threads in the system, although we recommend using ~10 threads which in our testing gave the best memory-time trade-off.</p>\n    </li>\n    <li>\n      <p><code class=\"language-plaintext highlighter-rouge\">-o</code>: output, path to folder where the output gene-count matrix (along with other meta-data) would be dumped. We simply call it alevin_output</p>\n    </li>\n    <li>\n      <p><code class=\"language-plaintext highlighter-rouge\">--tgMap</code>: transcript to gene map file, a tsv (tab-separated) file — with no header, containing two columns mapping of each transcript present in the reference to the corresponding gene (the first column is a transcript and the second is the corresponding gene). In our case, that’s map_code generated by using gtf2featureAnnotation.R function.</p>\n    </li>\n    <li>\n      <p><code class=\"language-plaintext highlighter-rouge\">--freqThreshold</code> - minimum frequency for a barcode to be considered. We’ve chosen 3 as this will only remove cell barcodes with a frequency of less than 3, a low bar to pass but useful way of avoiding processing a bunch of almost certainly empty barcodes.</p>\n    </li>\n    <li>\n      <p><code class=\"language-plaintext highlighter-rouge\">--keepCBFraction</code> - fraction of cellular barcodes to keep. We’re using 1 to quantify all!</p>\n    </li>\n    <li>\n      <p><code class=\"language-plaintext highlighter-rouge\">--dumpFeatures</code> - if activated, alevin dumps all the features used by the CB classification and their counts at each cell level. It’s generally used in pair with other command line flags.</p>\n    </li>\n  </ul>\n\n</blockquote>\n\n<p>We have also added some additional parameters (<code class=\"language-plaintext highlighter-rouge\">--freqThreshold</code>, <code class=\"language-plaintext highlighter-rouge\">--keepCBFraction</code>) and their values are derived from the <a href=\"/training-material/topics/single-cell/tutorials/scrna-case_alevin/tutorial.html\">Alevin Galaxy tutorial</a> after QC to stop Alevin from applying its own thresholds. However, if you’re not sure what value to pick, you can simply allow Alevin to make its own calls on what constitutes empty droplets.</p>\n\n<p>This tool will take a while to run. Alevin produces many file outputs, not all of which we’ll use. You can refer to the <a href=\"https://salmon.readthedocs.io/en/latest/alevin.html\">Alevin documentation</a> if you’re curious what they all are, you can look through all the different files to find information such as the mapping rate, but we’ll just pass the whole output folder directory for downstream analysis.</p>\n\n<blockquote class=\"question\">\n  <question-title></question-title>\n\n  <ol>\n    <li>Can you find the information what was the mapping rate?</li>\n    <li>How many transcripts did Alevin find?</li>\n  </ol>\n\n  <blockquote class=\"solution\">\n    <solution-title></solution-title>\n\n    <ol>\n      <li>As mentioned above, in <em>alevin_output</em> folder there will be many different files, including the log files. To check the mapping rate, go to <em>alevin_output</em> -&gt; <em>logs</em> and open <em>salmon_quant</em> file. There you will find not only information about mapping rate, but also many more, calculated at salmon indexing step.</li>\n      <li>Alevin log can be found in <em>alevin_output</em> -&gt; <em>alevin</em> and the file name is also <em>alevin</em>. You can find many details about the alevin process there, including the number of transcripts found.</li>\n    </ol>\n\n  </blockquote>\n\n</blockquote>\n\n<blockquote class=\"warning\">\n  <warning-title>Process stopping</warning-title>\n\n  <p>The command above will display the log of the process and will say “Analyzed X cells (Y% of all)”. For some reason, running Alevin may sometimes cause problems in Jupyter Notebook and this process will stop and not go to completion. This is the reason why we use hugely subsampled dataset here - bigger ones couldn’t be fully analysed (they worked fine locally though). The dataset used in this tutorial shouldn’t make any issues when you’re using Jupyter notebook through galaxy.eu, however might not work properly on galaxy.org. If you’re accessing Jupyter notebook via galaxy.eu and alevin process stopped, just restart the kernel and that should help.</p>\n\n</blockquote>\n\n<!---\ncheck if we can get alevinQC to work - and paste the info from the first Alevin tutorial?\n-->\n\n<h1 id=\"alevin-output-to-summarizedexperiment\">Alevin output to SummarizedExperiment</h1>\n\n<p>Let’s change gear a little bit. We’ve done the work in bash, and now we’re switching to R to complete the processing. To do so, you have to change Kernel to R (either click on <code class=\"language-plaintext highlighter-rouge\">Kernel</code> -&gt; <code class=\"language-plaintext highlighter-rouge\">Change Kernel...</code> in the upper left corner of your JupyterLab or click on the displayed current kernel in the upper right corner and change it).</p>\n<figure id=\"figure-1\" style=\"max-width: 90%;\"><img src=\"../../images/scrna-pre-processing/switch_kernel.jpg\" alt=\"Figure showing the JupyterLab interface with an arrow pointing to the left corner, showing the option 'Kernel' -&gt; 'Change Kernel...' and another arrow pointing to the right corner, showing the icon of the current kernel. The pop-up window asks which kernel should be chosen instead.\" width=\"1760\" height=\"580\" loading=\"lazy\" /><a target=\"_blank\" href=\"../../images/scrna-pre-processing/switch_kernel.jpg\" rel=\"noopener noreferrer\"><small>Open image in new tab</small></a><br /><br /><figcaption><span class=\"figcaption-prefix\"><strong>Figure 1</strong>:</span> Two ways of switching kernel.</figcaption></figure>\n\n<p>Now load the library that we have previously installed in terminal:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>library<span class=\"o\">(</span>tximeta<span class=\"o\">)</span>\n</code></pre></div></div>\n\n<p>The <a href=\"https://bioconductor.org/packages/devel/bioc/vignettes/tximeta/inst/doc/tximeta.html\">tximeta package</a> created by <span class=\"citation\"><a href=\"#Love2020\">Love <i>et al.</i> 2020</a></span> is used for import of transcript-level quantification data into R/Bioconductor and requires that the entire output of alevin is present and unmodified.</p>\n\n<p>In the <em>alevin_output</em> -&gt; <em>alevin</em> folder you can find the following files:</p>\n<ul>\n  <li><em>quants_mat.gz</em>- Compressed count matrix</li>\n  <li><em>quants_mat_rows.txt</em>- Row Index (CB-ids) of the matrix.</li>\n  <li><em>quants_mat_cols.txt</em> - Column Header (Gene-ids) of the matrix.</li>\n  <li><em>quants_tier_mat.gz</em> – Tier categorization of the matrix.</li>\n</ul>\n\n<p>We will only focus on <em>quants_mat.gz</em> though. First, let’s specify the path to that file:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>path &lt;- <span class=\"s1\">'alevin_output/alevin/quants_mat.gz'</span>\n</code></pre></div></div>\n\n<p>We will specify the following arguments when running <em>tximeta</em>:</p>\n<ul>\n  <li>‘coldata’ a data.frame with at least two columns:\n    <ul>\n      <li>files - character, paths of quantification files</li>\n      <li>names - character, sample names</li>\n    </ul>\n  </li>\n  <li>‘type’ - what quantifier was used (can be ‘salomon’, ‘alevin’, etc.)</li>\n</ul>\n\n<p>With that we can create a dataframe and pass it to tximeta to create SummarizedExperiment object.</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>coldata &lt;- data.frame<span class=\"o\">(</span>files <span class=\"o\">=</span> path, <span class=\"nv\">names</span><span class=\"o\">=</span><span class=\"s2\">\"sample701\"</span><span class=\"o\">)</span>\nalevin_se &lt;- tximeta<span class=\"o\">(</span>coldata, <span class=\"nb\">type</span> <span class=\"o\">=</span> <span class=\"s2\">\"alevin\"</span><span class=\"o\">)</span>\n</code></pre></div></div>\n\n<p>Inspect the created object:</p>\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>alevin_se\n</code></pre></div></div>\n\n<p>As you can see, <em>rowData names</em> and <em>colData names</em> are still empty. Before we add some metadata,  we will first identify barcodes that correspond to non-empty droplets.</p>\n\n<h1 id=\"identify-barcodes-that-correspond-to-non-empty-droplets\">Identify barcodes that correspond to non-empty droplets</h1>\n\n<p>Some sub-populations of small cells may not be distinguished from empty droplets based purely on counts by barcode. Some libraries produce multiple ‘knees’ (see the <a href=\"/training-material/topics/single-cell/tutorials/scrna-case_alevin/tutorial.html#basic-qc\">Alevin Galaxy tutorial</a> for multiple sub-populations. The <code class=\"language-plaintext highlighter-rouge\">emptyDrops</code> method (<span class=\"citation\"><a href=\"#Lun2019\">Lun <i>et al.</i> 2019</a></span>) has become a popular way of dealing with this. <code class=\"language-plaintext highlighter-rouge\">emptyDrops</code> still retains barcodes with very high counts, but also adds in barcodes that can be statistically distinguished from the ambient profiles, even if total counts are similar.</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>library<span class=\"o\">(</span>DropletUtils<span class=\"o\">)</span>               <span class=\"c\"># load the library and required packages</span>\n</code></pre></div></div>\n\n<p>emptyDrops takes multiple arguments that you can read about in the <a href=\"https://rdrr.io/github/MarioniLab/DropletUtils/man/emptyDrops.html\">documentation</a>. However, in this case, we will only specify the following arguments:</p>\n\n<blockquote class=\"details\">\n  <details-title>emptyDrops input parameters</details-title>\n\n  <ul>\n    <li><code class=\"language-plaintext highlighter-rouge\">m</code> -\tA numeric matrix-like object - usually a dgTMatrix or dgCMatrix - containing droplet data prior to any filtering or cell calling. Columns represent barcoded droplets, rows represent genes.</li>\n    <li><code class=\"language-plaintext highlighter-rouge\">lower</code> - A numeric scalar specifying the lower bound on the total UMI count, at or below which all barcodes are assumed to correspond to empty droplets.</li>\n    <li><code class=\"language-plaintext highlighter-rouge\">niters</code> - An integer scalar specifying the number of iterations to use for the Monte Carlo p-value calculations.</li>\n    <li><code class=\"language-plaintext highlighter-rouge\">retain</code> - A numeric scalar specifying the threshold for the total UMI count above which all barcodes are assumed to contain cells.</li>\n  </ul>\n\n</blockquote>\n\n<p>Let’s then extract the matrix from our <code class=\"language-plaintext highlighter-rouge\">alevin_se</code> object. It’s stored in <em>assays</em> -&gt; <em>counts</em>.</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>matrix_alevin &lt;- assays<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span><span class=\"nv\">$counts</span>\n</code></pre></div></div>\n\n<p>And now run emptyDrops:</p>\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># Identify likely cell-containing droplets</span>\nout &lt;- emptyDrops<span class=\"o\">(</span>matrix_alevin, lower <span class=\"o\">=</span> 100, niters <span class=\"o\">=</span> 1000, retain <span class=\"o\">=</span> 20<span class=\"o\">)</span>\nout\n</code></pre></div></div>\n\n<p>We also correct for multiple testing by controlling the false discovery rate (FDR) using the Benjamini-Hochberg (BH) method (<span class=\"citation\"><a href=\"#Benjamini1995\">Benjamini and Hochberg 1995</a></span>). Putative cells are defined as those barcodes that have significantly poor fits to the ambient model at a specified FDR threshold. Here, we will use an FDR threshold of 0.01. This means that the expected proportion of empty droplets in the set of retained barcodes is no greater than 1%, which we consider to be acceptably low for downstream analyses.</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>is.cell &lt;- out<span class=\"nv\">$FDR</span> &lt;<span class=\"o\">=</span> 0.01                           \n<span class=\"nb\">sum</span><span class=\"o\">(</span>is.cell, na.rm<span class=\"o\">=</span>TRUE<span class=\"o\">)</span>                              <span class=\"c\"># check how many cells left after filtering</span>\n</code></pre></div></div>\n\n<p>We got rid of the background droplets containing no cells, so now we will filter the matrix that we passed on to emptyDrops, so that it corresponds to the remaining cells.</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>emptied_matrix &lt;- matrix_alevin[,which<span class=\"o\">(</span>is.cell<span class=\"o\">)</span>,drop<span class=\"o\">=</span>FALSE]          <span class=\"c\"># filter the matrix</span>\n</code></pre></div></div>\n\n<p>From here, we can move on to adding metadata and we’ll return to <code class=\"language-plaintext highlighter-rouge\">emptied_matrix</code> soon.</p>\n\n<h1 id=\"adding-cell-metadata\">Adding cell metadata</h1>\n\n<p>The cells barcodes are stored in <em>colnames</em>. Let’s exctract them into a separate object:</p>\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>barcode &lt;- colnames<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span>\n</code></pre></div></div>\n\n<p>Now, we can simply add those barcodes into <em>colData names</em> where we will keep the cell metadata. To do this, we will create a column called <code class=\"language-plaintext highlighter-rouge\">barcode</code> in <em>colData</em> and pass the stored values into there.</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>colData<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span><span class=\"nv\">$barcode</span> &lt;- barcode\ncolData<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span>\n</code></pre></div></div>\n\n<p>That’s only cell barcodes for now! However, after running <em>emptyDrops</em>, we generated lots of cell information that is currently stored in <code class=\"language-plaintext highlighter-rouge\">out</code> object (Total, LogProb, PValue, Limited, FDR). Let’s add those values to cell metadata! Since we already have <em>barcodes</em> in there, we will simply bind the emptyDrops output to the existing dataframe:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>colData<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span> &lt;- cbind<span class=\"o\">(</span>colData<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span>,out<span class=\"o\">)</span>\ncolData<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span>\n</code></pre></div></div>\n\n<p>As you can see, the new columns were appended successfully and now the dataframe has 6 columns.</p>\n\n<p>If you have a look at the Experimental Design from that study, you might notice that there is actually more information about the cells. The most important for us would be batch, genotype and sex, summarised in the small table below.</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Index</th>\n      <th>Batch</th>\n      <th>Genotype</th>\n      <th>Sex</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>N701</td>\n      <td>0</td>\n      <td>wildtype</td>\n      <td>male</td>\n    </tr>\n    <tr>\n      <td>N702</td>\n      <td>1</td>\n      <td>knockout</td>\n      <td>male</td>\n    </tr>\n    <tr>\n      <td>N703</td>\n      <td>2</td>\n      <td>knockout</td>\n      <td>female</td>\n    </tr>\n    <tr>\n      <td>N704</td>\n      <td>3</td>\n      <td>wildtype</td>\n      <td>male</td>\n    </tr>\n    <tr>\n      <td>N705</td>\n      <td>4</td>\n      <td>wildtype</td>\n      <td>male</td>\n    </tr>\n    <tr>\n      <td>N706</td>\n      <td>5</td>\n      <td>wildtype</td>\n      <td>male</td>\n    </tr>\n    <tr>\n      <td>N707</td>\n      <td>6</td>\n      <td>knockout</td>\n      <td>male</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>We are currently analysing sample N701, so let’s add its information from the table.</p>\n\n<h2 id=\"batch\">Batch</h2>\n\n<p>We will label batch as an integer - “0” for sample N701, “1” for N702 etc. The way to do it is creating a list with zeros of the length corresponding to the number of cells that we have in our SummarizedExperiment object, like so:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>batch &lt;- rep<span class=\"o\">(</span><span class=\"s2\">\"0\"</span>, length<span class=\"o\">(</span>colnames<span class=\"o\">(</span>alevin_se<span class=\"o\">)))</span>\n</code></pre></div></div>\n\n<p>And now create a batch slot in the <em>colData names</em> and append the <code class=\"language-plaintext highlighter-rouge\">batch</code> list in the same way as we did with barcodes:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>colData<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span><span class=\"nv\">$batch</span> &lt;- batch\ncolData<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span>\n</code></pre></div></div>\n\n<p>A new column appeared, full of zeros - as expected!</p>\n\n<h2 id=\"genotype\">Genotype</h2>\n\n<p>It’s all the same for genotype, but instead creating a list with zeros, we’ll create a list with string “wildtype” and append it into genotype slot:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>genotype &lt;- rep<span class=\"o\">(</span><span class=\"s2\">\"wildtype\"</span>, length<span class=\"o\">(</span>colnames<span class=\"o\">(</span>alevin_se<span class=\"o\">)))</span>\ncolData<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span><span class=\"nv\">$genotype</span> &lt;- genotype\n</code></pre></div></div>\n\n<h2 id=\"sex\">Sex</h2>\n\n<p>You already know what to do, right? A list with string “male” and then adding it into a new slot!</p>\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>sex &lt;- rep<span class=\"o\">(</span><span class=\"s2\">\"male\"</span>, length<span class=\"o\">(</span>colnames<span class=\"o\">(</span>alevin_se<span class=\"o\">)))</span>\ncolData<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span><span class=\"nv\">$sex</span> &lt;- sex\n</code></pre></div></div>\n\n<p>Check if all looks fine:</p>\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>colData<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span>\n</code></pre></div></div>\n\n<p>3 new columns appeared with the information that we’ve just added - perfect! You can add any information you need in this way, as long as it’s the same for all the cells from one sample.</p>\n\n<h1 id=\"adding-gene-metadata\">Adding gene metadata</h1>\n\n<p>The genes IDs are stored in <em>rownames</em>. Let’s exctract them into a separate object:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>gene_ID &lt;- rownames<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span>\n</code></pre></div></div>\n\n<p>Analogically, we will add those genes IDs into <em>rowData names</em> which stores gene metadata. To do this, we will create a column called <code class=\"language-plaintext highlighter-rouge\">gene_ID</code> in <em>rowData</em> and pass the stored values into there.</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>rowData<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span><span class=\"nv\">$gene_ID</span> &lt;- gene_ID\n</code></pre></div></div>\n\n<h2 id=\"adding-genes-symbols-based-on-their-ids\">Adding genes symbols based on their IDs</h2>\n\n<p>Since gene symbols are much more informative than only gene IDs, we will add them to our metadata. We will base this annotation on Ensembl - the genome database – with the use of the library BioMart. We will use the archive Genome assembly GRCm38 to get the gene names. Please note that the updated version (GRCm39) is available, but some of the gene IDs are not in that EnsEMBL database. The code below is written in a way that it will work for the updated dataset too, but will produce ‘NA’ where the corresponding gene name couldn’t be found.</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># get relevant gene names</span>\nlibrary<span class=\"o\">(</span><span class=\"s2\">\"biomaRt\"</span><span class=\"o\">)</span>                                      <span class=\"c\"># load the BioMart library</span>\nensembl.ids &lt;- gene_ID                               \nmart &lt;- useEnsembl<span class=\"o\">(</span>biomart <span class=\"o\">=</span> <span class=\"s2\">\"ENSEMBL_MART_ENSEMBL\"</span><span class=\"o\">)</span>    <span class=\"c\"># connect to a specified BioMart database and dataset hosted by Ensembl</span>\nensembl_m <span class=\"o\">=</span> useMart<span class=\"o\">(</span><span class=\"s2\">\"ensembl\"</span>, <span class=\"nv\">dataset</span><span class=\"o\">=</span><span class=\"s2\">\"mmusculus_gene_ensembl\"</span>, <span class=\"nv\">version</span><span class=\"o\">=</span>100<span class=\"o\">)</span>\n\n<span class=\"c\"># The line above connects to a specified BioMart database and dataset within this database.</span>\n<span class=\"c\"># In our case we choose the mus musculus database and to get the desired Genome assembly GRCm38,</span>\n<span class=\"c\"># we specify the host with this archive. If you want to use the most recent version of the dataset, just run:</span>\n<span class=\"c\"># ensembl_m = useMart(\"ensembl\", dataset=\"mmusculus_gene_ensembl\")</span>\n</code></pre></div></div>\n\n<blockquote class=\"warning\">\n  <warning-title>Ensembl connection problems</warning-title>\n  <p>Sometimes you may encounter some connection issues with Ensembl. To improve performance Ensembl provides several mirrors of their site distributed around the globe. When you use the default settings for useEnsembl() your queries will be directed to your closest mirror geographically. In theory this should give you the best performance, however this is not always the case in practice. For example, if the nearest mirror is experiencing many queries from other users it may perform poorly for you. In such cases, the other mirrors should be chosen automatically.</p>\n\n</blockquote>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>genes &lt;- getBM<span class=\"o\">(</span><span class=\"nv\">attributes</span><span class=\"o\">=</span>c<span class=\"o\">(</span><span class=\"s1\">'ensembl_gene_id'</span>,<span class=\"s1\">'external_gene_name'</span><span class=\"o\">)</span>,\n               filters <span class=\"o\">=</span> <span class=\"s1\">'ensembl_gene_id'</span>,\n               values <span class=\"o\">=</span> ensembl.ids,\n               mart <span class=\"o\">=</span> ensembl_m<span class=\"o\">)</span>\n\n<span class=\"c\"># The line above retrieves the specified attributes from the connected BioMart database;</span>\n<span class=\"c\"># 'ensembl_gene_id' are genes IDs,</span>\n<span class=\"c\"># 'external_gene_name' are the genes symbols that we want to get for our values stored in ‘ensembl.ids’.</span>\n</code></pre></div></div>\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># see the resulting data</span>\n<span class=\"nb\">head</span><span class=\"o\">(</span>genes<span class=\"o\">)</span>                          \n</code></pre></div></div>\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># replace IDs for gene names</span>\ngene_names &lt;- ensembl.ids\t \ncount <span class=\"o\">=</span> 1 \t \n<span class=\"k\">for</span> <span class=\"o\">(</span>geneID <span class=\"k\">in </span>gene_names<span class=\"o\">)</span>\n<span class=\"o\">{</span>\n index &lt;- which<span class=\"o\">(</span><span class=\"nv\">genes</span><span class=\"o\">==</span>geneID<span class=\"o\">)</span>    <span class=\"c\"># finds an index of geneID in the genes object created by getBM()</span>\n <span class=\"k\">if</span> <span class=\"o\">(</span>length<span class=\"o\">(</span>index<span class=\"o\">)==</span>0<span class=\"o\">)</span>            <span class=\"c\"># condition in case if there is no corresponding gene name in the chosen dataset</span>\n  <span class=\"o\">{</span>\n    gene_names[count] &lt;- <span class=\"s1\">'NA'</span>\n  <span class=\"o\">}</span>\n  <span class=\"k\">else</span>\n  <span class=\"o\">{</span>\n    gene_names[count] &lt;- genes<span class=\"nv\">$external_gene_name</span><span class=\"o\">[</span>index] \t<span class=\"c\"># replaces gene ID by the corresponding gene name based on the found geneID’s index</span>\n  <span class=\"o\">}</span>\n count <span class=\"o\">=</span> count + 1                <span class=\"c\"># increased count so that every element in gene_names is replaced</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># add the gene names into rowData in a new column gene_name</span>\nrowData<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span><span class=\"nv\">$gene_name</span> &lt;- gene_names\n</code></pre></div></div>\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># see the changes</span>\nrowData<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span>                  \n</code></pre></div></div>\n\n<p>If you are working on your own data and it’s not mouse data, you can check available datasets for other species and just use relevant dataset in <code class=\"language-plaintext highlighter-rouge\">useMart()</code> function.</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>listDatasets<span class=\"o\">(</span>mart<span class=\"o\">)</span>                <span class=\"c\"># available datasets</span>\n</code></pre></div></div>\n\n<h2 id=\"flag-mitochondrial-genes\">Flag mitochondrial genes</h2>\n\n<p>We can also flag mitochondrial genes. Usually those are the genes whose name starts with ‘mt-‘ or ‘MT-‘. Therefore, we will store those characters in <code class=\"language-plaintext highlighter-rouge\">mito_genes_names</code> and then use <em>grepl()</em> to find those genes stored in <em>gene_name</em> slot.</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>mito_genes_names &lt;- <span class=\"s1\">'^mt-|^MT-'</span>                                    <span class=\"c\"># how mitochondrial gene names can start</span>\nmito &lt;- grepl<span class=\"o\">(</span>mito_genes_names, rowData<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span><span class=\"nv\">$gene_name</span><span class=\"o\">)</span>      <span class=\"c\"># find mito genes </span>\nmito                                                               <span class=\"c\"># see the resulting boolean list</span>\n</code></pre></div></div>\n\n<p>Now we can add another slot in <em>rowData</em> and call it <em>mito</em> that will keep boolean values (true/false) to indicate which genes are mitochondrial.</p>\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>rowData<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span><span class=\"nv\">$mito</span> &lt;- mito\nrowData<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span>\n</code></pre></div></div>\n\n<h1 id=\"subsetting-the-object\">Subsetting the object</h1>\n\n<p>Let’s go back to the <code class=\"language-plaintext highlighter-rouge\">emptied_matrix</code> object. Do you remember how many cells were left after filtering? We can check that by looking at the matrix’ dimensions:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>dim<span class=\"o\">(</span>matrix_alevin<span class=\"o\">)</span>                                                  <span class=\"c\"># check the dimension of the unfiltered matrix</span>\ndim<span class=\"o\">(</span>emptied_matrix<span class=\"o\">)</span>                                                 <span class=\"c\"># check the dimension of the filtered matrix</span>\n</code></pre></div></div>\n\n<p>We’ve gone from 3608 to 35 cells. We’ve filtered the matrix, but not our SummarizedExperiment. We can subset <code class=\"language-plaintext highlighter-rouge\">alevin_se</code> based on the cells that were left after filtering. We will store them in a separate list, as we did with the barcodes:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>retained_cells &lt;- colnames<span class=\"o\">(</span>emptied_matrix<span class=\"o\">)</span>\nretained_cells\n</code></pre></div></div>\n\n<p>And now we can subset our SummarizedExperiment based on the barcodes that are in the <code class=\"language-plaintext highlighter-rouge\">retained_cells</code> list:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>alevin_subset &lt;- alevin_se[, colData<span class=\"o\">(</span>alevin_se<span class=\"o\">)</span><span class=\"nv\">$barcode</span> %in% retained_cells]\nalevin_701 &lt;- alevin_subset\nalevin_701\n</code></pre></div></div>\n\n<p>And that’s our subset, ready for downstream analysis!</p>\n\n<h1 id=\"more-datasets\">More datasets</h1>\n\n<p>We’ve done the analysis for one sample. But there are 7 samples in this experiment and it would be very handy to have all the information in one place. Therefore, you would need to repeat all the steps for the subsequent samples (that’s when you’ll appreciate wrapped tools and automation in Galaxy workflows!). To make your life easier, we will show you how to combine the datasets on smaller scale. Also, to save you some time, we’ve already run Alevin on sample 702 (also subsampled to 50k reads). Let’s quickly repeat the steps we performed in R to complete the analysis of sample 702 in the same way as we did with 701.</p>\n\n<p>But first, we have to save the results of our hard work on sample 701!</p>\n\n<h2 id=\"saving-sample-701-data\">Saving sample 701 data</h2>\n\n<p>Saving files is quite straightforward. Just specify which object you want to save and how you want the file to be named. Don’t forget the extension!</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>save<span class=\"o\">(</span>alevin_701, file <span class=\"o\">=</span> <span class=\"s2\">\"alevin_701.rdata\"</span><span class=\"o\">)</span>\n</code></pre></div></div>\n\n<p>You will see the new file in the panel on the left.</p>\n\n<h2 id=\"analysis-of-sample-702\">Analysis of sample 702</h2>\n\n<p>Normally, at this point you would switch kernel to bash to run alevin, and then back to R to complete the analysis of another sample. Here, we are providing you with the alevin output for the next sample, but to give you some practise in switching kernels and saving data, we will use bash to unzip the folder with that output data.</p>\n\n<blockquote class=\"warning\">\n  <warning-title>Switching kernels &amp; losing variables</warning-title>\n\n  <p>Be aware that every time when you switch kernel, you will lose variables you store in the objects that you’ve created, unless you save them. Therefore, if you want to switch from R to bash, make sure you save your R objects! You can then load them anytime.</p>\n\n</blockquote>\n\n<p>Let’s <strong>switch the kernel back to bash</strong> and run the following code to unzip the alevin output for sample 702:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># we're in bash again!</span>\nwget https://zenodo.org/records/10116786/files/alevin_output_702.zip\n</code></pre></div></div>\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>unzip alevin_output_702.zip\n</code></pre></div></div>\n\n<p>The files are there! Now <strong>back to R - switch kernel again</strong>.</p>\n\n<p>Above we described all the steps done in R and explained what each bit of code does. Below all those steps are in one block of code, so read carefully and make sure you understand everything!</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># we're in R now!</span>\n\n<span class=\"c\">## load libraries again ##</span>\nlibrary<span class=\"o\">(</span>tximeta<span class=\"o\">)</span>\nlibrary<span class=\"o\">(</span>DropletUtils<span class=\"o\">)</span>\nlibrary<span class=\"o\">(</span>biomaRt<span class=\"o\">)</span>\n\n<span class=\"c\">## running tximeta ##</span>\npath2 &lt;- <span class=\"s1\">'alevin_output_702/alevin/quants_mat.gz'</span>                                                    <span class=\"c\"># path to alevin output for N702</span>\nalevin2 &lt;- tximeta<span class=\"o\">(</span>coldata <span class=\"o\">=</span> data.frame<span class=\"o\">(</span>files <span class=\"o\">=</span> path2, names <span class=\"o\">=</span> <span class=\"s2\">\"sample702\"</span><span class=\"o\">)</span>, <span class=\"nb\">type</span> <span class=\"o\">=</span> <span class=\"s2\">\"alevin\"</span><span class=\"o\">)</span>        <span class=\"c\"># create SummarizedExperiment from Alevin output</span>\n\n<span class=\"c\">## running emptyDrops ##</span>\nmatrix_alevin2 &lt;- assays<span class=\"o\">(</span>alevin2<span class=\"o\">)</span><span class=\"nv\">$counts</span>                                                             <span class=\"c\"># extract matrix from SummarizedExperiment</span>\nout2 &lt;- emptyDrops<span class=\"o\">(</span>matrix_alevin2, lower <span class=\"o\">=</span> 100, niters <span class=\"o\">=</span> 1000, retain <span class=\"o\">=</span> 20<span class=\"o\">)</span>                          <span class=\"c\"># apply emptyDrops</span>\nis.cell2 &lt;- out2<span class=\"nv\">$FDR</span> &lt;<span class=\"o\">=</span> 0.01                                                                         <span class=\"c\"># apply FDR threshold</span>\nemptied_matrix2 &lt;- matrix_alevin2[,which<span class=\"o\">(</span>is.cell2<span class=\"o\">)</span>,drop<span class=\"o\">=</span>FALSE]                                       <span class=\"c\"># subset the matrix to the cell-containing droplets</span>\n\n<span class=\"c\">## adding cell metadata ##</span>\nbarcode2 &lt;- colnames<span class=\"o\">(</span>alevin2<span class=\"o\">)</span>\ncolData<span class=\"o\">(</span>alevin2<span class=\"o\">)</span><span class=\"nv\">$barcode</span> &lt;- barcode2                                             <span class=\"c\"># add barcodes</span>\n\ncolData<span class=\"o\">(</span>alevin2<span class=\"o\">)</span> &lt;- cbind<span class=\"o\">(</span>colData<span class=\"o\">(</span>alevin2<span class=\"o\">)</span>,out2<span class=\"o\">)</span>                                 <span class=\"c\"># add emptyDrops info</span>\n\nbatch2 &lt;- rep<span class=\"o\">(</span><span class=\"s2\">\"1\"</span>, length<span class=\"o\">(</span>colnames<span class=\"o\">(</span>alevin2<span class=\"o\">)))</span>\ncolData<span class=\"o\">(</span>alevin2<span class=\"o\">)</span><span class=\"nv\">$batch</span> &lt;- batch2                                                <span class=\"c\"># add batch info</span>\n\ngenotype2 &lt;- rep<span class=\"o\">(</span><span class=\"s2\">\"wildtype\"</span>, length<span class=\"o\">(</span>colnames<span class=\"o\">(</span>alevin2<span class=\"o\">)))</span>\ncolData<span class=\"o\">(</span>alevin2<span class=\"o\">)</span><span class=\"nv\">$genotype</span> &lt;- genotype2                                          <span class=\"c\"># add genotype info</span>\n\nsex2 &lt;- rep<span class=\"o\">(</span><span class=\"s2\">\"male\"</span>, length<span class=\"o\">(</span>colnames<span class=\"o\">(</span>alevin2<span class=\"o\">)))</span>\ncolData<span class=\"o\">(</span>alevin2<span class=\"o\">)</span><span class=\"nv\">$sex</span> &lt;- sex2                                                    <span class=\"c\"># add sex info</span>\n\n<span class=\"c\">## adding gene metadata ##</span>\ngene_ID2 &lt;- rownames<span class=\"o\">(</span>alevin2<span class=\"o\">)</span>\nrowData<span class=\"o\">(</span>alevin2<span class=\"o\">)</span><span class=\"nv\">$gene_ID</span> &lt;- gene_ID2\n\n<span class=\"c\"># get relevant gene names</span>\nensembl.ids2 &lt;- gene_ID2               \nmart &lt;- useEnsembl<span class=\"o\">(</span>biomart <span class=\"o\">=</span> <span class=\"s2\">\"ENSEMBL_MART_ENSEMBL\"</span><span class=\"o\">)</span>    <span class=\"c\"># connect to a specified BioMart database and dataset hosted by Ensembl</span>\nensembl_m2 <span class=\"o\">=</span> useMart<span class=\"o\">(</span><span class=\"s2\">\"ensembl\"</span>, <span class=\"nv\">dataset</span><span class=\"o\">=</span><span class=\"s2\">\"mmusculus_gene_ensembl\"</span>, <span class=\"nv\">version</span><span class=\"o\">=</span>100<span class=\"o\">)</span> \t\n\ngenes2 &lt;- getBM<span class=\"o\">(</span><span class=\"nv\">attributes</span><span class=\"o\">=</span>c<span class=\"o\">(</span><span class=\"s1\">'ensembl_gene_id'</span>,<span class=\"s1\">'external_gene_name'</span><span class=\"o\">)</span>,\n               filters <span class=\"o\">=</span> <span class=\"s1\">'ensembl_gene_id'</span>,\n               values <span class=\"o\">=</span> ensembl.ids2,\n               mart <span class=\"o\">=</span> ensembl_m2<span class=\"o\">)</span>\n\n<span class=\"c\"># replace IDs for gene names</span>\ngene_names2 &lt;- ensembl.ids2\ncount <span class=\"o\">=</span> 1 \t \n<span class=\"k\">for</span> <span class=\"o\">(</span>geneID <span class=\"k\">in </span>gene_names2<span class=\"o\">)</span>\n<span class=\"o\">{</span>\n index &lt;- which<span class=\"o\">(</span><span class=\"nv\">genes2</span><span class=\"o\">==</span>geneID<span class=\"o\">)</span>    <span class=\"c\"># finds an index of geneID in the genes object created by getBM()</span>\n <span class=\"k\">if</span> <span class=\"o\">(</span>length<span class=\"o\">(</span>index<span class=\"o\">)==</span>0<span class=\"o\">)</span>            <span class=\"c\"># condition in case if there is no corresponding gene name in the chosen dataset</span>\n  <span class=\"o\">{</span>\n    gene_names2[count] &lt;- <span class=\"s1\">'NA'</span>\n  <span class=\"o\">}</span>\n  <span class=\"k\">else</span>\n  <span class=\"o\">{</span>\n    gene_names2[count] &lt;- genes2<span class=\"nv\">$external_gene_name</span><span class=\"o\">[</span>index] \t<span class=\"c\"># replaces gene ID by the corresponding gene name based on the found geneID’s index</span>\n  <span class=\"o\">}</span>\n count <span class=\"o\">=</span> count + 1                <span class=\"c\"># increased count so that every element in gene_names is replaced</span>\n<span class=\"o\">}</span>\n\nrowData<span class=\"o\">(</span>alevin2<span class=\"o\">)</span><span class=\"nv\">$gene_name</span> &lt;- gene_names2                              <span class=\"c\"># add gene names to gene metadata</span>\n\nmito_genes_names &lt;- <span class=\"s1\">'^mt-|^MT-'</span>                                        <span class=\"c\"># how mitochondrial gene names can start</span>\nmito2 &lt;- grepl<span class=\"o\">(</span>mito_genes_names, rowData<span class=\"o\">(</span>alevin2<span class=\"o\">)</span><span class=\"nv\">$gene_name</span><span class=\"o\">)</span>           <span class=\"c\"># find mito genes </span>\nrowData<span class=\"o\">(</span>alevin2<span class=\"o\">)</span><span class=\"nv\">$mito</span> &lt;- mito2                                         <span class=\"c\"># add mitochondrial information to gene metadata</span>\n\n<span class=\"c\">## create a subset of filtered object ##</span>\nretained_cells2 &lt;- colnames<span class=\"o\">(</span>emptied_matrix2<span class=\"o\">)</span>\nalevin_subset2 &lt;- alevin2[, colData<span class=\"o\">(</span>alevin2<span class=\"o\">)</span><span class=\"nv\">$barcode</span> %in% retained_cells2]\n\nalevin_702 &lt;- alevin_subset2\nalevin_702\n</code></pre></div></div>\n\n<p>Alright, another sample pre-processed!</p>\n\n<h1 id=\"combining-datasets\">Combining datasets</h1>\n\n<p>Pre-processed sample 702 is there, but we still need to load sample 701 that we saved before switching kernels. It’s equally easy as saving the object:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>load<span class=\"o\">(</span><span class=\"s2\">\"alevin_701.rdata\"</span><span class=\"o\">)</span>\n</code></pre></div></div>\n\n<p>Check if it was loaded ok:</p>\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>alevin_701\n</code></pre></div></div>\n\n<p>Now we can combine those two objects into one using one simple command:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>alevin_combined &lt;- cbind<span class=\"o\">(</span>alevin_701, alevin_702<span class=\"o\">)</span>\nalevin_combined\n</code></pre></div></div>\n\n<p>If you have more samples, just append them in the same way. We won’t process another sample here, but pretending that we have third sample, we would combine it like this:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>alevin_subset3 &lt;- alevin_702                        <span class=\"c\"># copy dataset for demonstration purposes</span>\nalevin_combined_demo &lt;- cbind<span class=\"o\">(</span>alevin_combined, alevin_subset3<span class=\"o\">)</span>\nalevin_combined_demo\n</code></pre></div></div>\n\n<p>You get the point, right? It’s important though that the rowData names and colData names are the same in each sample.</p>\n\n<h1 id=\"saving-and-exporting-the-files\">Saving and exporting the files</h1>\n\n<p>It is generally more common to use SingleCellExperiment format rather than SummarizedExperiment. The conversion is quick and easy, and goes like this:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>library<span class=\"o\">(</span>SingleCellExperiment<span class=\"o\">)</span>                                 <span class=\"c\"># might need to load this library</span>\nalevin_sce &lt;- as<span class=\"o\">(</span>alevin_combined, <span class=\"s2\">\"SingleCellExperiment\"</span><span class=\"o\">)</span>\nalevin_sce\n</code></pre></div></div>\n<p>As you can see, all the embeddings have been successfully transfered during this conversion and believe me, sce object will be more useful for you!</p>\n\n<p>You’ve already learned how to save and load objects in Jupyter notebook, let’s then save the SCE file:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>save<span class=\"o\">(</span>alevin_sce, file <span class=\"o\">=</span> <span class=\"s2\">\"alevin_sce.rdata\"</span><span class=\"o\">)</span>\n</code></pre></div></div>\n\n<p>The last thing that might be useful is exporting the files into your Galaxy history. To do it… guess what! Yes - <strong>switching kernels again</strong>! But this time we choose <strong>Python 3</strong> kernel and run the following command:</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c\"># that's Python now! </span>\nput<span class=\"o\">(</span><span class=\"s2\">\"alevin_sce.rdata\"</span><span class=\"o\">)</span>\n</code></pre></div></div>\n\n<h1 id=\"conclusion\">Conclusion</h1>\n\n<p>Well done! In this tutorial we have:</p>\n<ul>\n  <li>examined raw read data, annotations and necessary input files for quantification</li>\n  <li>created an index in Salmon and run Alevin</li>\n  <li>identified barcodes that correspond to non-empty droplets</li>\n  <li>added gene and cell metadata</li>\n  <li>applied the necessary conversion to pass these data to downstream processes.</li>\n</ul>\n\n<p>As you might now appreciate, some tasks are much quicker and easier when run in the code, but the reproducibility and automation of Galaxy workflows is a huge advantage that helps in dealing with many samples more quickly and efficiently.</p>\n"],"ref_slides":[],"hands_on":true,"slides":false,"mod_date":"2024-01-17 14:06:50 +0000","pub_date":"2023-12-08 14:46:22 +0000","version":31,"api":"https://training.galaxyproject.org/training-material/api/topics/single-cell/tutorials/alevin-commandline/tutorial.json","tools":[],"supported_servers":{"exact":[],"inexact":[{"name":"UseGalaxy.eu","url":"https://usegalaxy.eu","id":"eu","human":"Galaxy Europe","usegalaxy":true},{"name":"UseGalaxy.org","url":"https://usegalaxy.org","id":"us","human":"Galaxy Main","usegalaxy":true},{"name":"UseGalaxy.org.au","url":"https://usegalaxy.org.au","id":"au","human":"Galaxy Australia","usegalaxy":true},{"name":"UseGalaxy.fr","url":"https://usegalaxy.fr","id":"fr","human":"Galaxy France","usegalaxy":true}]},"topic_name_human":"Single Cell","admin_install":{"install_tool_dependencies":true,"install_repository_dependencies":true,"install_resolver_dependencies":true,"tools":[]},"admin_install_yaml":"---\ninstall_tool_dependencies: true\ninstall_repository_dependencies: true\ninstall_resolver_dependencies: true\ntools: []\n","tours":false,"video":false,"slides_recordings":false,"translations":{"tutorial":[],"slides":[],"video":false},"license":"CC-BY-4.0","type":"tutorial","contributors":[{"name":"Julia Jakiela","email":"juliajot36@gmail.com","joined":"2022-06","id":"wee-snufkin","url":"https://training.galaxyproject.org/training-material/api/contributors/wee-snufkin.json","page":"https://training.galaxyproject.org/training-material/hall-of-fame/wee-snufkin/"},{"name":"Wendi Bacon","email":"wendi.bacon@open.ac.uk","twitter":"WendiBacon1","matrix":"nomadscientist:matrix.org","joined":"2020-03","elixir_node":"uk","orcid":"0000-0002-8170-8806","bio":"Lecturer at The Open University","fediverse":"https://mstdn.science/@wendibacon1","fediverse_flavor":"mastodon","affiliations":["elixir-europe"],"id":"nomadscientist","url":"https://training.galaxyproject.org/training-material/api/contributors/nomadscientist.json","page":"https://training.galaxyproject.org/training-material/hall-of-fame/nomadscientist/"},{"name":"Pavankumar Videm","orcid":"0000-0002-5192-126X","joined":"2017-09","affiliations":["uni-freiburg","elixir-europe"],"id":"pavanvidem","url":"https://training.galaxyproject.org/training-material/api/contributors/pavanvidem.json","page":"https://training.galaxyproject.org/training-material/hall-of-fame/pavanvidem/"},{"name":"Mehmet Tekman","email":"mtekman89@gmail.com","joined":"2018-11","elixir_node":"de","affiliations":["uni-freiburg"],"former_affiliations":["elixir-europe"],"id":"mtekman","url":"https://training.galaxyproject.org/training-material/api/contributors/mtekman.json","page":"https://training.galaxyproject.org/training-material/hall-of-fame/mtekman/"},{"name":"Pavankumar Videm","orcid":"0000-0002-5192-126X","joined":"2017-09","affiliations":["uni-freiburg","elixir-europe"],"id":"pavanvidem","url":"https://training.galaxyproject.org/training-material/api/contributors/pavanvidem.json","page":"https://training.galaxyproject.org/training-material/hall-of-fame/pavanvidem/"},{"name":"EOSC-Life","github":false,"joined":"2023-04","avatar":"https://www.eosc-life.eu/wp-content/themes/eosc-life-v2/assets/images/eosclogo.png","funder":true,"funding_id":"824087","funding_system":"cordis","funding_statement":"EOSC-Life has received funding from the European Union’s Horizon 2020 programme under grant agreement number 824087","url":"https://training.galaxyproject.org/training-material/api/funders/eosc-life.json","members":["bgruening"],"id":"eosc-life","page":"https://training.galaxyproject.org/training-material/hall-of-fame/eosc-life/"}]}